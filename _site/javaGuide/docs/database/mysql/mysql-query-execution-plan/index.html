<blockquote>
  <p>本文来自公号 MySQL 技术，JavaGuide 对其做了补充完善。原文地址：<a href="https://mp.weixin.qq.com/s/d5OowNLtXBGEAbT31sSH4g">https://mp.weixin.qq.com/s/d5OowNLtXBGEAbT31sSH4g</a></p>
</blockquote>

<p>优化 SQL 的第一步应该是读懂 SQL 的执行计划。本篇文章，我们一起来学习下 MySQL <code class="language-plaintext highlighter-rouge">EXPLAIN</code> 执行计划相关知识。</p>

<h2 id="什么是执行计划">什么是执行计划？</h2>

<p><strong>执行计划</strong> 是指一条 SQL 语句在经过 <strong>MySQL 查询优化器</strong> 的优化会后，具体的执行方式。</p>

<p>执行计划通常用于 SQL 性能分析、优化等场景。通过 <code class="language-plaintext highlighter-rouge">EXPLAIN</code> 的结果，可以了解到如数据表的查询顺序、数据查询操作的操作类型、哪些索引可以被命中、哪些索引实际会命中、每个数据表有多少行记录被查询等信息。</p>

<h2 id="如何获取执行计划">如何获取执行计划？</h2>

<p>MySQL 为我们提供了 <code class="language-plaintext highlighter-rouge">EXPLAIN</code> 命令，来获取执行计划的相关信息。</p>

<p>需要注意的是，<code class="language-plaintext highlighter-rouge">EXPLAIN</code> 语句并不会真的去执行相关的语句，而是通过查询优化器对语句进行分析，找出最优的查询方案，并显示对应的信息。</p>

<p><code class="language-plaintext highlighter-rouge">EXPLAIN</code> 执行计划支持 <code class="language-plaintext highlighter-rouge">SELECT</code>、<code class="language-plaintext highlighter-rouge">DELETE</code>、<code class="language-plaintext highlighter-rouge">INSERT</code>、<code class="language-plaintext highlighter-rouge">REPLACE</code> 以及 <code class="language-plaintext highlighter-rouge">UPDATE</code> 语句。我们一般多用于分析 <code class="language-plaintext highlighter-rouge">SELECT</code> 查询语句，使用起来非常简单，语法如下：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">EXPLAIN</span> <span class="o">+</span> <span class="k">SELECT</span> <span class="err">查询语句；</span>
</code></pre></div></div>

<p>我们简单来看下一条查询语句的执行计划：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">dept_emp</span> <span class="k">WHERE</span> <span class="n">emp_no</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">emp_no</span> <span class="k">FROM</span> <span class="n">dept_emp</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">emp_no</span> <span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">emp_no</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">);</span>
<span class="o">+</span><span class="c1">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span>    <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span>   <span class="o">|</span> <span class="k">key</span>     <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span>   <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>       <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">PRIMARY</span>     <span class="o">|</span> <span class="n">dept_emp</span> <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ALL</span>   <span class="o">|</span> <span class="k">NULL</span>            <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">331143</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">2</span> <span class="o">|</span> <span class="n">SUBQUERY</span>    <span class="o">|</span> <span class="n">dept_emp</span> <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">index</span> <span class="o">|</span> <span class="k">PRIMARY</span><span class="p">,</span><span class="n">dept_no</span> <span class="o">|</span> <span class="k">PRIMARY</span> <span class="o">|</span> <span class="mi">16</span>      <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">331143</span> <span class="o">|</span>   <span class="mi">100</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">index</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span>
</code></pre></div></div>

<p>可以看到，执行计划结果中共有 12 列，各列代表的含义总结如下表：</p>

<table>
  <thead>
    <tr>
      <th><strong>列名</strong></th>
      <th><strong>含义</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id</td>
      <td>SELECT 查询的序列标识符</td>
    </tr>
    <tr>
      <td>select_type</td>
      <td>SELECT 关键字对应的查询类型</td>
    </tr>
    <tr>
      <td>table</td>
      <td>用到的表名</td>
    </tr>
    <tr>
      <td>partitions</td>
      <td>匹配的分区，对于未分区的表，值为 NULL</td>
    </tr>
    <tr>
      <td>type</td>
      <td>表的访问方法</td>
    </tr>
    <tr>
      <td>possible_keys</td>
      <td>可能用到的索引</td>
    </tr>
    <tr>
      <td>key</td>
      <td>实际用到的索引</td>
    </tr>
    <tr>
      <td>key_len</td>
      <td>所选索引的长度</td>
    </tr>
    <tr>
      <td>ref</td>
      <td>当使用索引等值查询时，与索引作比较的列或常量</td>
    </tr>
    <tr>
      <td>rows</td>
      <td>预计要读取的行数</td>
    </tr>
    <tr>
      <td>filtered</td>
      <td>按表条件过滤后，留存的记录数的百分比</td>
    </tr>
    <tr>
      <td>Extra</td>
      <td>附加信息</td>
    </tr>
  </tbody>
</table>

<h2 id="如何分析-explain-结果">如何分析 EXPLAIN 结果？</h2>

<p>为了分析 <code class="language-plaintext highlighter-rouge">EXPLAIN</code> 语句的执行结果，我们需要搞懂执行计划中的重要字段。</p>

<h3 id="id">id</h3>

<p><code class="language-plaintext highlighter-rouge">SELECT</code> 标识符，用于标识每个 <code class="language-plaintext highlighter-rouge">SELECT</code> 语句的执行顺序。</p>

<p>id 如果相同，从上往下依次执行。id 不同，id 值越大，执行优先级越高，如果行引用其他行的并集结果，则该值可以为 NULL。</p>

<h3 id="select_type">select_type</h3>

<p>查询的类型，主要用于区分普通查询、联合查询、子查询等复杂的查询，常见的值有：</p>

<ul>
  <li><strong>SIMPLE</strong>：简单查询，不包含 UNION 或者子查询。</li>
  <li><strong>PRIMARY</strong>：查询中如果包含子查询或其他部分，外层的 SELECT 将被标记为 PRIMARY。</li>
  <li><strong>SUBQUERY</strong>：子查询中的第一个 SELECT。</li>
  <li><strong>UNION</strong>：在 UNION 语句中，UNION 之后出现的 SELECT。</li>
  <li><strong>DERIVED</strong>：在 FROM 中出现的子查询将被标记为 DERIVED。</li>
  <li><strong>UNION RESULT</strong>：UNION 查询的结果。</li>
</ul>

<h3 id="table">table</h3>

<p>查询用到的表名，每行都有对应的表名，表名除了正常的表之外，也可能是以下列出的值：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">&lt;unionM,N&gt;</code></strong> : 本行引用了 id 为 M 和 N 的行的 UNION 结果；</li>
  <li><strong><code class="language-plaintext highlighter-rouge">&lt;derivedN&gt;</code></strong> : 本行引用了 id 为 N 的表所产生的的派生表结果。派生表有可能产生自 FROM 语句中的子查询。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">&lt;subqueryN&gt;</code></strong> : 本行引用了 id 为 N 的表所产生的的物化子查询结果。</li>
</ul>

<h3 id="type重要">type（重要）</h3>

<p>查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：</p>

<p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>

<p>常见的几种类型具体含义如下：</p>

<ul>
  <li><strong>system</strong>：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。</li>
  <li><strong>const</strong>：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。</li>
  <li><strong>eq_ref</strong>：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。</li>
  <li><strong>ref</strong>：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</li>
  <li><strong>index_merge</strong>：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。</li>
  <li><strong>range</strong>：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。</li>
  <li><strong>index</strong>：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</li>
  <li><strong>ALL</strong>：全表扫描。</li>
</ul>

<h3 id="possible_keys">possible_keys</h3>

<p>possible_keys 列表示 MySQL 执行查询时可能用到的索引。如果这一列为 NULL ，则表示没有可能用到的索引；这种情况下，需要检查 WHERE 语句中所使用的的列，看是否可以通过给这些列中某个或多个添加索引的方法来提高查询性能。</p>

<h3 id="key重要">key（重要）</h3>

<p>key 列表示 MySQL 实际使用到的索引。如果为 NULL，则表示未用到索引。</p>

<h3 id="key_len">key_len</h3>

<p>key_len 列表示 MySQL 实际使用的索引的最大长度；当使用到联合索引时，有可能是多个列的长度和。在满足需求的前提下越短越好。如果 key 列显示 NULL ，则 key_len 列也显示 NULL 。</p>

<h3 id="rows">rows</h3>

<p>rows 列表示根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。</p>

<h3 id="extra重要">Extra（重要）</h3>

<p>这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：</p>

<ul>
  <li><strong>Using filesort</strong>：在排序时使用了外部的索引排序，没有用到表内索引进行排序。</li>
  <li><strong>Using temporary</strong>：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。</li>
  <li><strong>Using index</strong>：表明查询使用了覆盖索引，不用回表，查询效率非常高。</li>
  <li><strong>Using index condition</strong>：表示查询优化器选择使用了索引条件下推这个特性。</li>
  <li><strong>Using where</strong>：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。</li>
  <li><strong>Using join buffer (Block Nested Loop)</strong>：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。</li>
</ul>

<p>这里提醒下，当 Extra 列包含 Using filesort 或 Using temporary 时，MySQL 的性能可能会存在问题，需要尽可能避免。</p>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">https://dev.mysql.com/doc/refman/5.7/en/explain-output.html</a></li>
  <li><a href="https://juejin.cn/post/6953444668973514789">https://juejin.cn/post/6953444668973514789</a></li>
</ul>

<!-- @include: @article-footer.snippet.md -->
