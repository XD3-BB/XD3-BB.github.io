<p>除了 5 种基本的数据类型之外，Redis 还支持 3 种特殊的数据类型：Bitmap、HyperLogLog、GEO。</p>

<h2 id="bitmap-位图">Bitmap （位图）</h2>

<h3 id="介绍">介绍</h3>

<p>根据官网介绍：</p>

<blockquote>
  <p>Bitmaps are not an actual data type, but a set of bit-oriented operations defined on the String type which is treated like a bit vector. Since strings are binary safe blobs and their maximum length is 512 MB, they are suitable to set up to 2^32 different bits.</p>

  <p>Bitmap 不是 Redis 中的实际数据类型，而是在 String 类型上定义的一组面向位的操作，将其视为位向量。由于字符串是二进制安全的块，且最大长度为 512 MB，它们适合用于设置最多 2^32 个不同的位。</p>
</blockquote>

<p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p>

<p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/image-20220720194154133.png" alt="" /></p>

<h3 id="常用命令">常用命令</h3>

<table>
  <thead>
    <tr>
      <th>命令</th>
      <th>介绍</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SETBIT key offset value</td>
      <td>设置指定 offset 位置的值</td>
    </tr>
    <tr>
      <td>GETBIT key offset</td>
      <td>获取指定 offset 位置的值</td>
    </tr>
    <tr>
      <td>BITCOUNT key start end</td>
      <td>获取 start 和 end 之间值为 1 的元素个数</td>
    </tr>
    <tr>
      <td>BITOP operation destkey key1 key2 …</td>
      <td>对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT</td>
    </tr>
  </tbody>
</table>

<p><strong>Bitmap 基本操作演示</strong>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># SETBIT 会返回之前位的值（默认是 0）这里会生成 7 个位</span>
<span class="o">&gt;</span> SETBIT mykey 7 1
<span class="o">(</span>integer<span class="o">)</span> 0
<span class="o">&gt;</span> SETBIT mykey 7 0
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> GETBIT mykey 7
<span class="o">(</span>integer<span class="o">)</span> 0
<span class="o">&gt;</span> SETBIT mykey 6 1
<span class="o">(</span>integer<span class="o">)</span> 0
<span class="o">&gt;</span> SETBIT mykey 8 1
<span class="o">(</span>integer<span class="o">)</span> 0
<span class="c"># 通过 bitcount 统计被被设置为 1 的位的数量。</span>
<span class="o">&gt;</span> BITCOUNT mykey
<span class="o">(</span>integer<span class="o">)</span> 2
</code></pre></div></div>

<h3 id="应用场景">应用场景</h3>

<p><strong>需要保存状态信息（0/1 即可表示）的场景</strong></p>

<ul>
  <li>举例：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li>
  <li>相关命令：<code class="language-plaintext highlighter-rouge">SETBIT</code>、<code class="language-plaintext highlighter-rouge">GETBIT</code>、<code class="language-plaintext highlighter-rouge">BITCOUNT</code>、<code class="language-plaintext highlighter-rouge">BITOP</code>。</li>
</ul>

<h2 id="hyperloglog基数统计">HyperLogLog（基数统计）</h2>

<h3 id="介绍-1">介绍</h3>

<p>HyperLogLog 是一种有名的基数计数概率算法 ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。</p>

<p>Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近<code class="language-plaintext highlighter-rouge">2^64</code>个不同元素。这是真的厉害，这就是数学的魅力么！并且，Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：</p>

<ul>
  <li><strong>稀疏矩阵</strong>：计数较少的时候，占用空间很小。</li>
  <li><strong>稠密矩阵</strong>：计数达到某个阈值的时候，占用 12k 的空间。</li>
</ul>

<p>Redis 官方文档中有对应的详细说明：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/image-20220721091424563.png" alt="" /></p>

<p>基数计数概率算法为了节省内存并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）。因此， HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 <code class="language-plaintext highlighter-rouge">0.81%</code> ）。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/image-20220720194154133.png" alt="" /></p>

<p>HyperLogLog 的使用非常简单，但原理非常复杂。HyperLogLog 的原理以及在 Redis 中的实现可以看这篇文章：<a href="https://juejin.cn/post/6844903785744056333">HyperLogLog 算法的原理讲解以及 Redis 是如何应用它的</a> 。</p>

<p>再推荐一个可以帮助理解 HyperLogLog 原理的工具：<a href="http://content.research.neustar.biz/blog/hll.html">Sketch of the Day: HyperLogLog — Cornerstone of a Big Data Infrastructure</a> 。</p>

<p>除了 HyperLogLog 之外，Redis 还提供了其他的概率数据结构，对应的官方文档地址：<a href="https://redis.io/docs/data-types/probabilistic/">https://redis.io/docs/data-types/probabilistic/</a> 。</p>

<h3 id="常用命令-1">常用命令</h3>

<p>HyperLogLog 相关的命令非常少，最常用的也就 3 个。</p>

<table>
  <thead>
    <tr>
      <th>命令</th>
      <th>介绍</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>PFADD key element1 element2 …</td>
      <td>添加一个或多个元素到 HyperLogLog 中</td>
    </tr>
    <tr>
      <td>PFCOUNT key1 key2</td>
      <td>获取一个或者多个 HyperLogLog 的唯一计数。</td>
    </tr>
    <tr>
      <td>PFMERGE destkey sourcekey1 sourcekey2 …</td>
      <td>将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。</td>
    </tr>
  </tbody>
</table>

<p><strong>HyperLogLog 基本操作演示</strong>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> PFADD hll foo bar zap
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> PFADD hll zap zap zap
<span class="o">(</span>integer<span class="o">)</span> 0
<span class="o">&gt;</span> PFADD hll foo bar
<span class="o">(</span>integer<span class="o">)</span> 0
<span class="o">&gt;</span> PFCOUNT hll
<span class="o">(</span>integer<span class="o">)</span> 3
<span class="o">&gt;</span> PFADD some-other-hll 1 2 3
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> PFCOUNT hll some-other-hll
<span class="o">(</span>integer<span class="o">)</span> 6
<span class="o">&gt;</span> PFMERGE desthll hll some-other-hll
<span class="s2">"OK"</span>
<span class="o">&gt;</span> PFCOUNT desthll
<span class="o">(</span>integer<span class="o">)</span> 6
</code></pre></div></div>

<h3 id="应用场景-1">应用场景</h3>

<p><strong>数量量巨大（百万、千万级别以上）的计数场景</strong></p>

<ul>
  <li>举例：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、</li>
  <li>相关命令：<code class="language-plaintext highlighter-rouge">PFADD</code>、<code class="language-plaintext highlighter-rouge">PFCOUNT</code> 。</li>
</ul>

<h2 id="geospatial-地理位置">Geospatial (地理位置)</h2>

<h3 id="介绍-2">介绍</h3>

<p>Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。</p>

<p>通过 GEO 我们可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/image-20220720194359494.png" alt="" /></p>

<h3 id="常用命令-2">常用命令</h3>

<table>
  <thead>
    <tr>
      <th>命令</th>
      <th>介绍</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>GEOADD key longitude1 latitude1 member1 …</td>
      <td>添加一个或多个元素对应的经纬度信息到 GEO 中</td>
    </tr>
    <tr>
      <td>GEOPOS key member1 member2 …</td>
      <td>返回给定元素的经纬度信息</td>
    </tr>
    <tr>
      <td>GEODIST key member1 member2 M/KM/FT/MI</td>
      <td>返回两个给定元素之间的距离</td>
    </tr>
    <tr>
      <td>GEORADIUS key longitude latitude radius distance</td>
      <td>获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC（由远到近）、Count(数量) 等参数</td>
    </tr>
    <tr>
      <td>GEORADIUSBYMEMBER key member radius distance</td>
      <td>类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素</td>
    </tr>
  </tbody>
</table>

<p><strong>基本操作</strong>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> GEOADD personLocation 116.33 39.89 user1 116.34 39.90 user2 116.35 39.88 user3
3
<span class="o">&gt;</span> GEOPOS personLocation user1
116.3299986720085144
39.89000061669732844
<span class="o">&gt;</span> GEODIST personLocation user1 user2 km
1.4018
</code></pre></div></div>

<p>通过 Redis 可视化工具查看 <code class="language-plaintext highlighter-rouge">personLocation</code> ，果不其然，底层就是 Sorted Set。</p>

<p>GEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score(权重参数)使用。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/image-20220721201545147.png" alt="" /></p>

<p><strong>获取指定位置范围内的其他元素</strong>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> GEORADIUS personLocation 116.33 39.87 3 km
user3
user1
<span class="o">&gt;</span> GEORADIUS personLocation 116.33 39.87 2 km
<span class="o">&gt;</span> GEORADIUS personLocation 116.33 39.87 5 km
user3
user1
user2
<span class="o">&gt;</span> GEORADIUSBYMEMBER personLocation user1 5 km
user3
user1
user2
<span class="o">&gt;</span> GEORADIUSBYMEMBER personLocation user1 2 km
user1
user2
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">GEORADIUS</code> 命令的底层原理解析可以看看阿里的这篇文章：<a href="https://juejin.cn/post/6844903966061363207">Redis 到底是怎么实现“附近的人”这个功能的呢？</a> 。</p>

<p><strong>移除元素</strong>：</p>

<p>GEO 底层是 Sorted Set ，你可以对 GEO 使用 Sorted Set 相关的命令。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> ZREM personLocation user1
1
<span class="o">&gt;</span> ZRANGE personLocation 0 <span class="nt">-1</span>
user3
user2
<span class="o">&gt;</span> ZSCORE personLocation user2
4069879562983946
</code></pre></div></div>

<h3 id="应用场景-2">应用场景</h3>

<p><strong>需要管理使用地理空间数据的场景</strong></p>

<ul>
  <li>举例：附近的人。</li>
  <li>相关命令: <code class="language-plaintext highlighter-rouge">GEOADD</code>、<code class="language-plaintext highlighter-rouge">GEORADIUS</code>、<code class="language-plaintext highlighter-rouge">GEORADIUSBYMEMBER</code> 。</li>
</ul>

<h2 id="总结">总结</h2>

<table>
  <thead>
    <tr>
      <th>数据类型</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Bitmap</td>
      <td>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</td>
    </tr>
    <tr>
      <td>HyperLogLog</td>
      <td>Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近<code class="language-plaintext highlighter-rouge">2^64</code>个不同元素。不过，HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 <code class="language-plaintext highlighter-rouge">0.81%</code> ）。</td>
    </tr>
    <tr>
      <td>Geospatial index</td>
      <td>Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。</td>
    </tr>
  </tbody>
</table>

<h2 id="参考">参考</h2>

<ul>
  <li>Redis Data Structures：<a href="https://redis.com/redis-enterprise/data-structures/">https://redis.com/redis-enterprise/data-structures/</a> 。</li>
  <li>《Redis 深度历险：核心原理与应用实践》1.6 四两拨千斤——HyperLogLog</li>
  <li>布隆过滤器,位图,HyperLogLog：<a href="https://hogwartsrico.github.io/2020/06/08/BloomFilter-HyperLogLog-BitMap/index.html">https://hogwartsrico.github.io/2020/06/08/BloomFilter-HyperLogLog-BitMap/index.html</a></li>
</ul>

<!-- @include: @article-footer.snippet.md -->
