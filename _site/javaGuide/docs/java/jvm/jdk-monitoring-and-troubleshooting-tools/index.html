<h2 id="jdk-命令行工具">JDK 命令行工具</h2>

<p>这些命令在 JDK 安装目录下的 bin 目录下：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">jps</code></strong> (JVM Process Status）: 类似 UNIX 的 <code class="language-plaintext highlighter-rouge">ps</code> 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</li>
  <li><strong><code class="language-plaintext highlighter-rouge">jstat</code></strong>（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">jinfo</code></strong> (Configuration Info for Java) : Configuration Info for Java,显示虚拟机配置信息;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">jmap</code></strong> (Memory Map for Java) : 生成堆转储快照;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">jhat</code></strong> (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。JDK9 移除了 jhat；</li>
  <li><strong><code class="language-plaintext highlighter-rouge">jstack</code></strong> (Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</li>
</ul>

<h3 id="jps查看所有-java-进程"><code class="language-plaintext highlighter-rouge">jps</code>:查看所有 Java 进程</h3>

<p><code class="language-plaintext highlighter-rouge">jps</code>(JVM Process Status) 命令类似 UNIX 的 <code class="language-plaintext highlighter-rouge">ps</code> 命令。</p>

<p><code class="language-plaintext highlighter-rouge">jps</code>：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（Local Virtual Machine Identifier,LVMID）。<code class="language-plaintext highlighter-rouge">jps -q</code>：只输出进程的本地虚拟机唯一 ID。</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">C:\Users\SnailClimb</span><span class="err">&gt;</span><span class="nx">jps</span><span class="w">
</span><span class="mi">7360</span><span class="w"> </span><span class="n">NettyClient2</span><span class="w">
</span><span class="nx">17396</span><span class="w">
</span><span class="mi">7972</span><span class="w"> </span><span class="n">Launcher</span><span class="w">
</span><span class="nx">16504</span><span class="w"> </span><span class="nx">Jps</span><span class="w">
</span><span class="mi">17340</span><span class="w"> </span><span class="n">NettyServer</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">jps -l</code>:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">C:\Users\SnailClimb</span><span class="err">&gt;</span><span class="nx">jps</span><span class="w"> </span><span class="nt">-l</span><span class="w">
</span><span class="mi">7360</span><span class="w"> </span><span class="n">firstNettyDemo.NettyClient2</span><span class="w">
</span><span class="nx">17396</span><span class="w">
</span><span class="mi">7972</span><span class="w"> </span><span class="n">org.jetbrains.jps.cmdline.Launcher</span><span class="w">
</span><span class="nx">16492</span><span class="w"> </span><span class="nx">sun.tools.jps.Jps</span><span class="w">
</span><span class="mi">17340</span><span class="w"> </span><span class="n">firstNettyDemo.NettyServer</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">jps -v</code>：输出虚拟机进程启动时 JVM 参数。</p>

<p><code class="language-plaintext highlighter-rouge">jps -m</code>：输出传递给 Java 进程 main() 函数的参数。</p>

<h3 id="jstat-监视虚拟机各种运行状态信息"><code class="language-plaintext highlighter-rouge">jstat</code>: 监视虚拟机各种运行状态信息</h3>

<p>jstat（JVM Statistics Monitoring Tool） 使用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程（需要远程主机提供 RMI 支持）虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。</p>

<p><strong><code class="language-plaintext highlighter-rouge">jstat</code> 命令使用格式：</strong></p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jstat</span><span class="w"> </span><span class="o">-</span><span class="err">&lt;</span><span class="nx">option</span><span class="err">&gt;</span><span class="w"> </span><span class="p">[</span><span class="nt">-t</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="nt">-h</span><span class="err">&lt;</span><span class="n">lines</span><span class="err">&gt;</span><span class="p">]</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">vmid</span><span class="err">&gt;</span><span class="w"> </span><span class="p">[</span><span class="err">&lt;</span><span class="n">interval</span><span class="err">&gt;</span><span class="w"> </span><span class="p">[</span><span class="err">&lt;</span><span class="n">count</span><span class="err">&gt;</span><span class="p">]]</span><span class="w">
</span></code></pre></div></div>

<p>比如 <code class="language-plaintext highlighter-rouge">jstat -gc -h3 31736 1000 10</code>表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。</p>

<p><strong>常见的 option 如下：</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">jstat -class vmid</code>：显示 ClassLoader 的相关信息；</li>
  <li><code class="language-plaintext highlighter-rouge">jstat -compiler vmid</code>：显示 JIT 编译的相关信息；</li>
  <li><code class="language-plaintext highlighter-rouge">jstat -gc vmid</code>：显示与 GC 相关的堆信息；</li>
  <li><code class="language-plaintext highlighter-rouge">jstat -gccapacity vmid</code>：显示各个代的容量及使用情况；</li>
  <li><code class="language-plaintext highlighter-rouge">jstat -gcnew vmid</code>：显示新生代信息；</li>
  <li><code class="language-plaintext highlighter-rouge">jstat -gcnewcapcacity vmid</code>：显示新生代大小与使用情况；</li>
  <li><code class="language-plaintext highlighter-rouge">jstat -gcold vmid</code>：显示老年代和永久代的行为统计，从 jdk1.8 开始,该选项仅表示老年代，因为永久代被移除了；</li>
  <li><code class="language-plaintext highlighter-rouge">jstat -gcoldcapacity vmid</code>：显示老年代的大小；</li>
  <li><code class="language-plaintext highlighter-rouge">jstat -gcpermcapacity vmid</code>：显示永久代大小，从 jdk1.8 开始,该选项不存在了，因为永久代被移除了；</li>
  <li><code class="language-plaintext highlighter-rouge">jstat -gcutil vmid</code>：显示垃圾收集信息；</li>
</ul>

<p>另外，加上 <code class="language-plaintext highlighter-rouge">-t</code>参数可以在输出信息上加一个 Timestamp 列，显示程序的运行时间。</p>

<h3 id="jinfo-实时地查看和调整虚拟机各项参数"><code class="language-plaintext highlighter-rouge">jinfo</code>: 实时地查看和调整虚拟机各项参数</h3>

<p><code class="language-plaintext highlighter-rouge">jinfo vmid</code> :输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。</p>

<p><code class="language-plaintext highlighter-rouge">jinfo -flag name vmid</code> :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( <code class="language-plaintext highlighter-rouge">-XX:PrintGCDetails</code> :详细 GC 日志模式，这两个都是默认关闭的)。</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">C:\Users\SnailClimb</span><span class="err">&gt;</span><span class="nx">jinfo</span><span class="w">  </span><span class="nt">-flag</span><span class="w"> </span><span class="nx">MaxHeapSize</span><span class="w"> </span><span class="nx">17340</span><span class="w">
</span><span class="nt">-XX</span><span class="p">:</span><span class="n">MaxHeapSize</span><span class="o">=</span><span class="mi">2124414976</span><span class="w">
</span><span class="n">C:\Users\SnailClimb</span><span class="err">&gt;</span><span class="nx">jinfo</span><span class="w">  </span><span class="nt">-flag</span><span class="w"> </span><span class="nx">PrintGC</span><span class="w"> </span><span class="nx">17340</span><span class="w">
</span><span class="nt">-XX</span><span class="p">:</span><span class="nt">-PrintGC</span><span class="w">
</span></code></pre></div></div>

<p>使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用,请看下面的例子：</p>

<p><code class="language-plaintext highlighter-rouge">jinfo -flag [+|-]name vmid</code> 开启或者关闭对应名称的参数。</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">C:\Users\SnailClimb</span><span class="err">&gt;</span><span class="nx">jinfo</span><span class="w">  </span><span class="nt">-flag</span><span class="w">  </span><span class="nx">PrintGC</span><span class="w"> </span><span class="nx">17340</span><span class="w">
</span><span class="nt">-XX</span><span class="p">:</span><span class="nt">-PrintGC</span><span class="w">

</span><span class="n">C:\Users\SnailClimb</span><span class="err">&gt;</span><span class="nx">jinfo</span><span class="w">  </span><span class="nt">-flag</span><span class="w">  </span><span class="o">+</span><span class="nx">PrintGC</span><span class="w"> </span><span class="nx">17340</span><span class="w">

</span><span class="n">C:\Users\SnailClimb</span><span class="err">&gt;</span><span class="nx">jinfo</span><span class="w">  </span><span class="nt">-flag</span><span class="w">  </span><span class="nx">PrintGC</span><span class="w"> </span><span class="nx">17340</span><span class="w">
</span><span class="nt">-XX</span><span class="p">:</span><span class="o">+</span><span class="n">PrintGC</span><span class="w">
</span></code></pre></div></div>

<h3 id="jmap生成堆转储快照"><code class="language-plaintext highlighter-rouge">jmap</code>:生成堆转储快照</h3>

<p><code class="language-plaintext highlighter-rouge">jmap</code>（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 <code class="language-plaintext highlighter-rouge">jmap</code> 命令，要想获取 Java 堆转储，可以使用 <code class="language-plaintext highlighter-rouge">“-XX:+HeapDumpOnOutOfMemoryError”</code> 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 <code class="language-plaintext highlighter-rouge">kill -3</code> 发送进程退出信号也能拿到 dump 文件。</p>

<p><code class="language-plaintext highlighter-rouge">jmap</code> 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和<code class="language-plaintext highlighter-rouge">jinfo</code>一样，<code class="language-plaintext highlighter-rouge">jmap</code>有不少功能在 Windows 平台下也是受限制的。</p>

<p>示例：将指定应用程序的堆快照输出到桌面。后面，可以通过 jhat、Visual VM 等工具分析该堆文件。</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">C:\Users\SnailClimb</span><span class="err">&gt;</span><span class="nx">jmap</span><span class="w"> </span><span class="nt">-dump</span><span class="p">:</span><span class="nx">format</span><span class="o">=</span><span class="n">b</span><span class="p">,</span><span class="nx">file</span><span class="o">=</span><span class="n">C:\Users\SnailClimb\Desktop\heap.hprof</span><span class="w"> </span><span class="nx">17340</span><span class="w">
</span><span class="n">Dumping</span><span class="w"> </span><span class="nx">heap</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">C:\Users\SnailClimb\Desktop\heap.hprof</span><span class="w"> </span><span class="o">...</span><span class="w">
</span><span class="n">Heap</span><span class="w"> </span><span class="nx">dump</span><span class="w"> </span><span class="nx">file</span><span class="w"> </span><span class="nx">created</span><span class="w">
</span></code></pre></div></div>

<h3 id="jhat-分析-heapdump-文件"><strong><code class="language-plaintext highlighter-rouge">jhat</code></strong>: 分析 heapdump 文件</h3>

<p><strong><code class="language-plaintext highlighter-rouge">jhat</code></strong> 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">C:\Users\SnailClimb</span><span class="err">&gt;</span><span class="nx">jhat</span><span class="w"> </span><span class="nx">C:\Users\SnailClimb\Desktop\heap.hprof</span><span class="w">
</span><span class="n">Reading</span><span class="w"> </span><span class="nx">from</span><span class="w"> </span><span class="nx">C:\Users\SnailClimb\Desktop\heap.hprof...</span><span class="w">
</span><span class="n">Dump</span><span class="w"> </span><span class="nx">file</span><span class="w"> </span><span class="nx">created</span><span class="w"> </span><span class="nx">Sat</span><span class="w"> </span><span class="nx">May</span><span class="w"> </span><span class="nx">04</span><span class="w"> </span><span class="nx">12:30:31</span><span class="w"> </span><span class="nx">CST</span><span class="w"> </span><span class="nx">2019</span><span class="w">
</span><span class="n">Snapshot</span><span class="w"> </span><span class="nx">read</span><span class="p">,</span><span class="w"> </span><span class="nx">resolving...</span><span class="w">
</span><span class="n">Resolving</span><span class="w"> </span><span class="nx">131419</span><span class="w"> </span><span class="nx">objects...</span><span class="w">
</span><span class="n">Chasing</span><span class="w"> </span><span class="nx">references</span><span class="p">,</span><span class="w"> </span><span class="nx">expect</span><span class="w"> </span><span class="nx">26</span><span class="w"> </span><span class="nx">dots..........................</span><span class="w">
</span><span class="n">Eliminating</span><span class="w"> </span><span class="nx">duplicate</span><span class="w"> </span><span class="nx">references..........................</span><span class="w">
</span><span class="n">Snapshot</span><span class="w"> </span><span class="nx">resolved.</span><span class="w">
</span><span class="n">Started</span><span class="w"> </span><span class="nx">HTTP</span><span class="w"> </span><span class="nx">server</span><span class="w"> </span><span class="nx">on</span><span class="w"> </span><span class="nx">port</span><span class="w"> </span><span class="nx">7000</span><span class="w">
</span><span class="n">Server</span><span class="w"> </span><span class="nx">is</span><span class="w"> </span><span class="nx">ready.</span><span class="w">
</span></code></pre></div></div>

<p>访问 <a href="http://localhost:7000/">http://localhost:7000/</a></p>

<p>注意⚠️：JDK9 移除了 jhat（<a href="https://openjdk.org/jeps/241">JEP 241: Remove the jhat Tool</a>），你可以使用其替代品 Eclipse Memory Analyzer Tool (MAT) 和 VisualVM，这也是官方所推荐的。</p>

<h3 id="jstack-生成虚拟机当前时刻的线程快照"><strong><code class="language-plaintext highlighter-rouge">jstack</code></strong> :生成虚拟机当前时刻的线程快照</h3>

<p><code class="language-plaintext highlighter-rouge">jstack</code>（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.</p>

<p>生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过<code class="language-plaintext highlighter-rouge">jstack</code>来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。</p>

<p><strong>下面是一个线程死锁的代码。我们下面会通过 <code class="language-plaintext highlighter-rouge">jstack</code> 命令进行死锁检查，输出死锁信息，找到发生死锁的线程。</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DeadLockDemo</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Object</span> <span class="n">resource1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span><span class="c1">//资源 1</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Object</span> <span class="n">resource2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span><span class="c1">//资源 2</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">resource1</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()</span> <span class="o">+</span> <span class="s">"get resource1"</span><span class="o">);</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()</span> <span class="o">+</span> <span class="s">"waiting get resource2"</span><span class="o">);</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="n">resource2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()</span> <span class="o">+</span> <span class="s">"get resource2"</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">},</span> <span class="s">"线程 1"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>

        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">resource2</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()</span> <span class="o">+</span> <span class="s">"get resource2"</span><span class="o">);</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()</span> <span class="o">+</span> <span class="s">"waiting get resource1"</span><span class="o">);</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="n">resource1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()</span> <span class="o">+</span> <span class="s">"get resource1"</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">},</span> <span class="s">"线程 2"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Output</p>

<pre><code class="language-plain">Thread[线程 1,5,main]get resource1
Thread[线程 2,5,main]get resource2
Thread[线程 1,5,main]waiting get resource2
Thread[线程 2,5,main]waiting get resource1
</code></pre>

<p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过<code class="language-plaintext highlighter-rouge">Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p>

<p><strong>通过 <code class="language-plaintext highlighter-rouge">jstack</code> 命令分析：</strong></p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">C:\Users\SnailClimb</span><span class="err">&gt;</span><span class="nx">jps</span><span class="w">
</span><span class="mi">13792</span><span class="w"> </span><span class="n">KotlinCompileDaemon</span><span class="w">
</span><span class="nx">7360</span><span class="w"> </span><span class="nx">NettyClient2</span><span class="w">
</span><span class="mi">17396</span><span class="w">
</span><span class="mi">7972</span><span class="w"> </span><span class="n">Launcher</span><span class="w">
</span><span class="nx">8932</span><span class="w"> </span><span class="nx">Launcher</span><span class="w">
</span><span class="mi">9256</span><span class="w"> </span><span class="n">DeadLockDemo</span><span class="w">
</span><span class="nx">10764</span><span class="w"> </span><span class="nx">Jps</span><span class="w">
</span><span class="mi">17340</span><span class="w"> </span><span class="n">NettyServer</span><span class="w">

</span><span class="n">C:\Users\SnailClimb</span><span class="err">&gt;</span><span class="nx">jstack</span><span class="w"> </span><span class="nx">9256</span><span class="w">
</span></code></pre></div></div>

<p>输出的部分内容如下：</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Found</span><span class="w"> </span><span class="nx">one</span><span class="w"> </span><span class="nx">Java-level</span><span class="w"> </span><span class="nx">deadlock:</span><span class="w">
</span><span class="o">=============================</span><span class="w">
</span><span class="s2">"线程 2"</span><span class="p">:</span><span class="w">
  </span><span class="n">waiting</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">lock</span><span class="w"> </span><span class="nx">monitor</span><span class="w"> </span><span class="nx">0x000000000333e668</span><span class="w"> </span><span class="p">(</span><span class="n">object</span><span class="w"> </span><span class="nx">0x00000000d5efe1c0</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">java.lang.Object</span><span class="p">),</span><span class="w">
  </span><span class="n">which</span><span class="w"> </span><span class="nx">is</span><span class="w"> </span><span class="nx">held</span><span class="w"> </span><span class="nx">by</span><span class="w"> </span><span class="s2">"线程 1"</span><span class="w">
</span><span class="s2">"线程 1"</span><span class="p">:</span><span class="w">
  </span><span class="n">waiting</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">lock</span><span class="w"> </span><span class="nx">monitor</span><span class="w"> </span><span class="nx">0x000000000333be88</span><span class="w"> </span><span class="p">(</span><span class="n">object</span><span class="w"> </span><span class="nx">0x00000000d5efe1d0</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">java.lang.Object</span><span class="p">),</span><span class="w">
  </span><span class="n">which</span><span class="w"> </span><span class="nx">is</span><span class="w"> </span><span class="nx">held</span><span class="w"> </span><span class="nx">by</span><span class="w"> </span><span class="s2">"线程 2"</span><span class="w">

</span><span class="n">Java</span><span class="w"> </span><span class="nx">stack</span><span class="w"> </span><span class="nx">information</span><span class="w"> </span><span class="nx">for</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">threads</span><span class="w"> </span><span class="nx">listed</span><span class="w"> </span><span class="nx">above:</span><span class="w">
</span><span class="o">===================================================</span><span class="w">
</span><span class="s2">"线程 2"</span><span class="p">:</span><span class="w">
        </span><span class="n">at</span><span class="w"> </span><span class="nx">DeadLockDemo.lambda</span><span class="nv">$main$1</span><span class="p">(</span><span class="n">DeadLockDemo.java:31</span><span class="p">)</span><span class="w">
        </span><span class="o">-</span><span class="w"> </span><span class="n">waiting</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">lock</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">0x00000000d5efe1c0</span><span class="err">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="nx">java.lang.Object</span><span class="p">)</span><span class="w">
        </span><span class="o">-</span><span class="w"> </span><span class="n">locked</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">0x00000000d5efe1d0</span><span class="err">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="nx">java.lang.Object</span><span class="p">)</span><span class="w">
        </span><span class="n">at</span><span class="w"> </span><span class="nx">DeadLockDemo</span><span class="bp">$$</span><span class="nx">Lambda</span><span class="nv">$2</span><span class="nx">/1078694789.run</span><span class="p">(</span><span class="n">Unknown</span><span class="w"> </span><span class="nx">Source</span><span class="p">)</span><span class="w">
        </span><span class="n">at</span><span class="w"> </span><span class="nx">java.lang.Thread.run</span><span class="p">(</span><span class="n">Thread.java:748</span><span class="p">)</span><span class="w">
</span><span class="s2">"线程 1"</span><span class="p">:</span><span class="w">
        </span><span class="n">at</span><span class="w"> </span><span class="nx">DeadLockDemo.lambda</span><span class="nv">$main$0</span><span class="p">(</span><span class="n">DeadLockDemo.java:16</span><span class="p">)</span><span class="w">
        </span><span class="o">-</span><span class="w"> </span><span class="n">waiting</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">lock</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">0x00000000d5efe1d0</span><span class="err">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="nx">java.lang.Object</span><span class="p">)</span><span class="w">
        </span><span class="o">-</span><span class="w"> </span><span class="n">locked</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">0x00000000d5efe1c0</span><span class="err">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="nx">java.lang.Object</span><span class="p">)</span><span class="w">
        </span><span class="n">at</span><span class="w"> </span><span class="nx">DeadLockDemo</span><span class="bp">$$</span><span class="nx">Lambda</span><span class="nv">$1</span><span class="nx">/1324119927.run</span><span class="p">(</span><span class="n">Unknown</span><span class="w"> </span><span class="nx">Source</span><span class="p">)</span><span class="w">
        </span><span class="n">at</span><span class="w"> </span><span class="nx">java.lang.Thread.run</span><span class="p">(</span><span class="n">Thread.java:748</span><span class="p">)</span><span class="w">

</span><span class="n">Found</span><span class="w"> </span><span class="nx">1</span><span class="w"> </span><span class="nx">deadlock.</span><span class="w">
</span></code></pre></div></div>

<p>可以看到 <code class="language-plaintext highlighter-rouge">jstack</code> 命令已经帮我们找到发生死锁的线程的具体信息。</p>

<h2 id="jdk-可视化分析工具">JDK 可视化分析工具</h2>

<h3 id="jconsolejava-监视与管理控制台">JConsole:Java 监视与管理控制台</h3>

<p>JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输入<code class="language-plaintext highlighter-rouge">jconsole</code>命令启动或者在 JDK 目录下的 bin 目录找到<code class="language-plaintext highlighter-rouge">jconsole.exe</code>然后双击启动。</p>

<h4 id="连接-jconsole">连接 Jconsole</h4>

<p><img src="./pictures/jdk监控和故障处理工具总结/1JConsole连接.png" alt="连接 Jconsole" /></p>

<p>如果需要使用 JConsole 连接远程进程，可以在远程 Java 程序启动时加上下面这些参数:</p>

<div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">-Djava.rmi.server.hostname</span><span class="p">=</span><span class="s">外网访问 ip 地址</span>
<span class="py">-Dcom.sun.management.jmxremote.port</span><span class="p">=</span><span class="s">60001   //监控的端口号</span>
<span class="py">-Dcom.sun.management.jmxremote.authenticate</span><span class="p">=</span><span class="s">false   //关闭认证</span>
<span class="py">-Dcom.sun.management.jmxremote.ssl</span><span class="p">=</span><span class="s">false</span>
</code></pre></div></div>

<p>在使用 JConsole 连接时，远程进程地址如下：</p>

<pre><code class="language-plain">外网访问 ip 地址:60001
</code></pre>

<h4 id="查看-java-程序概况">查看 Java 程序概况</h4>

<p><img src="./pictures/jdk监控和故障处理工具总结/2查看Java程序概况.png" alt="查看 Java 程序概况 " /></p>

<h4 id="内存监控">内存监控</h4>

<p>JConsole 可以显示当前内存的详细信息。不仅包括堆内存/非堆内存的整体信息，还可以细化到 eden 区、survivor 区等的使用情况，如下图所示。</p>

<p>点击右边的“执行 GC(G)”按钮可以强制应用程序执行一个 Full GC。</p>

<blockquote>
  <ul>
    <li><strong>新生代 GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li>
    <li><strong>老年代 GC（Major GC/Full GC）</strong>:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li>
  </ul>
</blockquote>

<p><img src="./pictures/jdk监控和故障处理工具总结/3内存监控.png" alt="内存监控 " /></p>

<h4 id="线程监控">线程监控</h4>

<p>类似我们前面讲的 <code class="language-plaintext highlighter-rouge">jstack</code> 命令，不过这个是可视化的。</p>

<p>最下面有一个”检测死锁 (D)”按钮，点击这个按钮可以自动为你找到发生死锁的线程以及它们的详细信息 。</p>

<p><img src="./pictures/jdk监控和故障处理工具总结/4线程监控.png" alt="线程监控 " /></p>

<h3 id="visual-vm多合一故障处理工具">Visual VM:多合一故障处理工具</h3>

<p>VisualVM 提供在 Java 虚拟机 (Java Virtual Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。Visual VM 官网：<a href="https://visualvm.github.io/">https://visualvm.github.io/</a> 。Visual VM 中文文档:<a href="https://visualvm.github.io/documentation.html">https://visualvm.github.io/documentation.html</a>。</p>

<p>下面这段话摘自《深入理解 Java 虚拟机》。</p>

<blockquote>
  <p>VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序，官方在 VisualVM 的软件说明中写上了“All-in-One”的描述字样，预示着他除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析（Profiling）。VisualVM 的性能分析功能甚至比起 JProfiler、YourKit 等专业且收费的 Profiling 工具都不会逊色多少，而且 VisualVM 还有一个很大的优点：不需要被监视的程序基于特殊 Agent 运行，因此他对应用程序的实际性能的影响很小，使得他可以直接应用在生产环境中。这个优点是 JProfiler、YourKit 等工具无法与之媲美的。</p>
</blockquote>

<p>VisualVM 基于 NetBeans 平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM 可以做到：</p>

<ul>
  <li>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</li>
  <li>监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。</li>
  <li>dump 以及分析堆转储快照（jmap、jhat）。</li>
  <li>方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。</li>
  <li>离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。</li>
  <li>其他 plugins 的无限的可能性……</li>
</ul>

<p>这里就不具体介绍 VisualVM 的使用，如果想了解的话可以看:</p>

<ul>
  <li><a href="https://visualvm.github.io/documentation.html">https://visualvm.github.io/documentation.html</a></li>
  <li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html">https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html</a></li>
</ul>

<h3 id="mat内存分析器工具">MAT：内存分析器工具</h3>

<p>MAT（Memory Analyzer Tool）是一款快速便捷且功能强大丰富的 JVM 堆内存离线分析工具。其通过展现 JVM 异常时所记录的运行时堆转储快照（Heap dump）状态（正常运行时也可以做堆转储分析），帮助定位内存泄漏问题或优化大内存消耗逻辑。</p>

<p>在遇到 OOM 和 GC 问题的时候，我一般会首选使用 MAT 分析 dump 文件在，这也是该工具应用最多的一个场景。</p>

<p>关于 MAT 的详细介绍推荐下面这两篇文章，写的很不错：</p>

<ul>
  <li><a href="https://juejin.cn/post/6908665391136899079">JVM 内存分析工具 MAT 的深度讲解与实践—入门篇</a></li>
  <li><a href="https://juejin.cn/post/6911624328472133646">JVM 内存分析工具 MAT 的深度讲解与实践—进阶篇</a></li>
</ul>

<!-- @include: @article-footer.snippet.md -->
