<!-- @include: @small-advertisement.snippet.md -->

<h2 id="io-流简介">IO 流简介</h2>

<p>IO 即 <code class="language-plaintext highlighter-rouge">Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p>

<p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">InputStream</code>/<code class="language-plaintext highlighter-rouge">Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
  <li><code class="language-plaintext highlighter-rouge">OutputStream</code>/<code class="language-plaintext highlighter-rouge">Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>

<h2 id="字节流">字节流</h2>

<h3 id="inputstream字节输入流">InputStream（字节输入流）</h3>

<p><code class="language-plaintext highlighter-rouge">InputStream</code>用于从源头（通常是文件）读取数据（字节信息）到内存中，<code class="language-plaintext highlighter-rouge">java.io.InputStream</code>抽象类是所有字节输入流的父类。</p>

<p><code class="language-plaintext highlighter-rouge">InputStream</code> 常用方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">read()</code>：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code class="language-plaintext highlighter-rouge">-1</code> ，表示文件结束。</li>
  <li><code class="language-plaintext highlighter-rouge">read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组 <code class="language-plaintext highlighter-rouge">b</code> 中。如果数组 <code class="language-plaintext highlighter-rouge">b</code> 的长度为零，则不读取。如果没有可用字节读取，返回 <code class="language-plaintext highlighter-rouge">-1</code>。如果有可用字节读取，则最多读取的字节数最多等于 <code class="language-plaintext highlighter-rouge">b.length</code> ， 返回读取的字节数。这个方法等价于 <code class="language-plaintext highlighter-rouge">read(b, 0, b.length)</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">read(byte b[], int off, int len)</code>：在<code class="language-plaintext highlighter-rouge">read(byte b[ ])</code> 方法的基础上增加了 <code class="language-plaintext highlighter-rouge">off</code> 参数（偏移量）和 <code class="language-plaintext highlighter-rouge">len</code> 参数（要读取的最大字节数）。</li>
  <li><code class="language-plaintext highlighter-rouge">skip(long n)</code>：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</li>
  <li><code class="language-plaintext highlighter-rouge">available()</code>：返回输入流中可以读取的字节数。</li>
  <li><code class="language-plaintext highlighter-rouge">close()</code>：关闭输入流释放相关的系统资源。</li>
</ul>

<p>从 Java 9 开始，<code class="language-plaintext highlighter-rouge">InputStream</code> 新增加了多个实用的方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">readAllBytes()</code>：读取输入流中的所有字节，返回字节数组。</li>
  <li><code class="language-plaintext highlighter-rouge">readNBytes(byte[] b, int off, int len)</code>：阻塞直到读取 <code class="language-plaintext highlighter-rouge">len</code> 个字节。</li>
  <li><code class="language-plaintext highlighter-rouge">transferTo(OutputStream out)</code>：将所有字节从一个输入流传递到一个输出流。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p>

<p><code class="language-plaintext highlighter-rouge">FileInputStream</code> 代码示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">InputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"input.txt"</span><span class="o">))</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Number of remaining bytes:"</span>
            <span class="o">+</span> <span class="n">fis</span><span class="o">.</span><span class="na">available</span><span class="o">());</span>
    <span class="kt">int</span> <span class="n">content</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">skip</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">skip</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The actual number of bytes skipped:"</span> <span class="o">+</span> <span class="n">skip</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"The content read from file:"</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">((</span><span class="n">content</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="n">content</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">input.txt</code> 文件内容：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/image-20220419155214614.png" alt="" /></p>

<p>输出：</p>

<pre><code class="language-plain">Number of remaining bytes:11
The actual number of bytes skipped:2
The content read from file:JavaGuide
</code></pre>

<p>不过，一般我们是不会直接单独使用 <code class="language-plaintext highlighter-rouge">FileInputStream</code> ，通常会配合 <code class="language-plaintext highlighter-rouge">BufferedInputStream</code>（字节缓冲输入流，后文会讲到）来使用。</p>

<p>像下面这段代码在我们的项目中就比较常见，我们通过 <code class="language-plaintext highlighter-rouge">readAllBytes()</code> 读取输入流所有字节并将其直接赋值给一个 <code class="language-plaintext highlighter-rouge">String</code> 对象。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 新建一个 BufferedInputStream 对象</span>
<span class="nc">BufferedInputStream</span> <span class="n">bufferedInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"input.txt"</span><span class="o">));</span>
<span class="c1">// 读取文件的内容并复制到 String 对象中</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">bufferedInputStream</span><span class="o">.</span><span class="na">readAllBytes</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">DataInputStream</code> 用于读取指定类型数据，不能单独使用，必须结合其它流，比如 <code class="language-plaintext highlighter-rouge">FileInputStream</code> 。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">FileInputStream</span> <span class="n">fileInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"input.txt"</span><span class="o">);</span>
<span class="c1">//必须将fileInputStream作为构造参数才能使用</span>
<span class="nc">DataInputStream</span> <span class="n">dataInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataInputStream</span><span class="o">(</span><span class="n">fileInputStream</span><span class="o">);</span>
<span class="c1">//可以读取任意具体的类型数据</span>
<span class="n">dataInputStream</span><span class="o">.</span><span class="na">readBoolean</span><span class="o">();</span>
<span class="n">dataInputStream</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>
<span class="n">dataInputStream</span><span class="o">.</span><span class="na">readUTF</span><span class="o">();</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ObjectInputStream</code> 用于从输入流中读取 Java 对象（反序列化），<code class="language-plaintext highlighter-rouge">ObjectOutputStream</code> 用于将对象写入到输出流(序列化)。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ObjectInputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"object.data"</span><span class="o">));</span>
<span class="nc">MyClass</span> <span class="n">object</span> <span class="o">=</span> <span class="o">(</span><span class="nc">MyClass</span><span class="o">)</span> <span class="n">input</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
<span class="n">input</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div>

<p>另外，用于序列化和反序列化的类必须实现 <code class="language-plaintext highlighter-rouge">Serializable</code> 接口，对象中如果有属性不想被序列化，使用 <code class="language-plaintext highlighter-rouge">transient</code> 修饰。</p>

<h3 id="outputstream字节输出流">OutputStream（字节输出流）</h3>

<p><code class="language-plaintext highlighter-rouge">OutputStream</code>用于将数据（字节信息）写入到目的地（通常是文件），<code class="language-plaintext highlighter-rouge">java.io.OutputStream</code>抽象类是所有字节输出流的父类。</p>

<p><code class="language-plaintext highlighter-rouge">OutputStream</code> 常用方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">write(int b)</code>：将特定字节写入输出流。</li>
  <li><code class="language-plaintext highlighter-rouge">write(byte b[ ])</code> : 将数组<code class="language-plaintext highlighter-rouge">b</code> 写入到输出流，等价于 <code class="language-plaintext highlighter-rouge">write(b, 0, b.length)</code> 。</li>
  <li><code class="language-plaintext highlighter-rouge">write(byte[] b, int off, int len)</code> : 在<code class="language-plaintext highlighter-rouge">write(byte b[ ])</code> 方法的基础上增加了 <code class="language-plaintext highlighter-rouge">off</code> 参数（偏移量）和 <code class="language-plaintext highlighter-rouge">len</code> 参数（要读取的最大字节数）。</li>
  <li><code class="language-plaintext highlighter-rouge">flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节。</li>
  <li><code class="language-plaintext highlighter-rouge">close()</code>：关闭输出流释放相关的系统资源。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">FileOutputStream</code> 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</p>

<p><code class="language-plaintext highlighter-rouge">FileOutputStream</code> 代码示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">FileOutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"output.txt"</span><span class="o">))</span> <span class="o">{</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="s">"JavaGuide"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span>
    <span class="n">output</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">array</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>运行结果：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/image-20220419155514392.png" alt="" /></p>

<p>类似于 <code class="language-plaintext highlighter-rouge">FileInputStream</code>，<code class="language-plaintext highlighter-rouge">FileOutputStream</code> 通常也会配合 <code class="language-plaintext highlighter-rouge">BufferedOutputStream</code>（字节缓冲输出流，后文会讲到）来使用。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">FileOutputStream</span> <span class="n">fileOutputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"output.txt"</span><span class="o">);</span>
<span class="nc">BufferedOutputStream</span> <span class="n">bos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedOutputStream</span><span class="o">(</span><span class="n">fileOutputStream</span><span class="o">)</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">DataOutputStream</code></strong> 用于写入指定类型数据，不能单独使用，必须结合其它流，比如 <code class="language-plaintext highlighter-rouge">FileOutputStream</code> 。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 输出流</span>
<span class="nc">FileOutputStream</span> <span class="n">fileOutputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"out.txt"</span><span class="o">);</span>
<span class="nc">DataOutputStream</span> <span class="n">dataOutputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataOutputStream</span><span class="o">(</span><span class="n">fileOutputStream</span><span class="o">);</span>
<span class="c1">// 输出任意数据类型</span>
<span class="n">dataOutputStream</span><span class="o">.</span><span class="na">writeBoolean</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="n">dataOutputStream</span><span class="o">.</span><span class="na">writeByte</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ObjectInputStream</code> 用于从输入流中读取 Java 对象（<code class="language-plaintext highlighter-rouge">ObjectInputStream</code>,反序列化），<code class="language-plaintext highlighter-rouge">ObjectOutputStream</code>将对象写入到输出流(<code class="language-plaintext highlighter-rouge">ObjectOutputStream</code>，序列化)。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ObjectOutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"file.txt"</span><span class="o">)</span>
<span class="nc">Person</span> <span class="n">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Guide哥"</span><span class="o">,</span> <span class="s">"JavaGuide作者"</span><span class="o">);</span>
<span class="n">output</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">person</span><span class="o">);</span>
</code></pre></div></div>

<h2 id="字符流">字符流</h2>

<p>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。 <strong>那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>

<p>个人认为主要有两点原因：</p>

<ul>
  <li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。</li>
  <li>如果我们不知道编码类型就很容易出现乱码问题。</li>
</ul>

<p>乱码问题这个很容易就可以复现，我们只需要将上面提到的 <code class="language-plaintext highlighter-rouge">FileInputStream</code> 代码示例中的 <code class="language-plaintext highlighter-rouge">input.txt</code> 文件内容改为中文即可，原代码不需要改动。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/image-20220419154632551.png" alt="" /></p>

<p>输出：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Number</span> <span class="n">of</span> <span class="n">remaining</span> <span class="nl">bytes:</span><span class="mi">9</span>
<span class="nc">The</span> <span class="n">actual</span> <span class="n">number</span> <span class="n">of</span> <span class="n">bytes</span> <span class="nl">skipped:</span><span class="mi">2</span>
<span class="nc">The</span> <span class="n">content</span> <span class="n">read</span> <span class="n">from</span> <span class="nl">file:</span><span class="err">§</span><span class="n">å</span><span class="err">®¶</span><span class="n">å</span><span class="err">¥½</span>
</code></pre></div></div>

<p>可以很明显地看到读取出来的内容已经变成了乱码。</p>

<p>因此，I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>

<p>字符流默认采用的是 <code class="language-plaintext highlighter-rouge">Unicode</code> 编码，我们可以通过构造方法自定义编码。</p>

<p>Unicode 本身只是一种字符集，它为每个字符分配一个唯一的数字编号，并没有规定具体的存储方式。UTF-8、UTF-16、UTF-32 都是 Unicode 的编码方式，它们使用不同的字节数来表示 Unicode 字符。例如，UTF-8 :英文占 1 字节，中文占 3 字节。</p>

<h3 id="reader字符输入流">Reader（字符输入流）</h3>

<p><code class="language-plaintext highlighter-rouge">Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code class="language-plaintext highlighter-rouge">java.io.Reader</code>抽象类是所有字符输入流的父类。</p>

<p><code class="language-plaintext highlighter-rouge">Reader</code> 用于读取文本， <code class="language-plaintext highlighter-rouge">InputStream</code> 用于读取原始字节。</p>

<p><code class="language-plaintext highlighter-rouge">Reader</code> 常用方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">read()</code> : 从输入流读取一个字符。</li>
  <li><code class="language-plaintext highlighter-rouge">read(char[] cbuf)</code> : 从输入流中读取一些字符，并将它们存储到字符数组 <code class="language-plaintext highlighter-rouge">cbuf</code>中，等价于 <code class="language-plaintext highlighter-rouge">read(cbuf, 0, cbuf.length)</code> 。</li>
  <li><code class="language-plaintext highlighter-rouge">read(char[] cbuf, int off, int len)</code>：在<code class="language-plaintext highlighter-rouge">read(char[] cbuf)</code> 方法的基础上增加了 <code class="language-plaintext highlighter-rouge">off</code> 参数（偏移量）和 <code class="language-plaintext highlighter-rouge">len</code> 参数（要读取的最大字符数）。</li>
  <li><code class="language-plaintext highlighter-rouge">skip(long n)</code>：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。</li>
  <li><code class="language-plaintext highlighter-rouge">close()</code> : 关闭输入流并释放相关的系统资源。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">InputStreamReader</code> 是字节流转换为字符流的桥梁，其子类 <code class="language-plaintext highlighter-rouge">FileReader</code> 是基于该基础上的封装，可以直接操作字符文件。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 字节流转换为字符流的桥梁</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">InputStreamReader</span> <span class="kd">extends</span> <span class="nc">Reader</span> <span class="o">{</span>
<span class="o">}</span>
<span class="c1">// 用于读取字符文件</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FileReader</span> <span class="kd">extends</span> <span class="nc">InputStreamReader</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">FileReader</code> 代码示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">FileReader</span> <span class="n">fileReader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"input.txt"</span><span class="o">);)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">content</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">skip</span> <span class="o">=</span> <span class="n">fileReader</span><span class="o">.</span><span class="na">skip</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The actual number of bytes skipped:"</span> <span class="o">+</span> <span class="n">skip</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"The content read from file:"</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">((</span><span class="n">content</span> <span class="o">=</span> <span class="n">fileReader</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="n">content</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">input.txt</code> 文件内容：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/image-20220419154632551.png" alt="" /></p>

<p>输出：</p>

<pre><code class="language-plain">The actual number of bytes skipped:3
The content read from file:我是Guide。
</code></pre>

<h3 id="writer字符输出流">Writer（字符输出流）</h3>

<p><code class="language-plaintext highlighter-rouge">Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code class="language-plaintext highlighter-rouge">java.io.Writer</code>抽象类是所有字符输出流的父类。</p>

<p><code class="language-plaintext highlighter-rouge">Writer</code> 常用方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">write(int c)</code> : 写入单个字符。</li>
  <li><code class="language-plaintext highlighter-rouge">write(char[] cbuf)</code>：写入字符数组 <code class="language-plaintext highlighter-rouge">cbuf</code>，等价于<code class="language-plaintext highlighter-rouge">write(cbuf, 0, cbuf.length)</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">write(char[] cbuf, int off, int len)</code>：在<code class="language-plaintext highlighter-rouge">write(char[] cbuf)</code> 方法的基础上增加了 <code class="language-plaintext highlighter-rouge">off</code> 参数（偏移量）和 <code class="language-plaintext highlighter-rouge">len</code> 参数（要读取的最大字符数）。</li>
  <li><code class="language-plaintext highlighter-rouge">write(String str)</code>：写入字符串，等价于 <code class="language-plaintext highlighter-rouge">write(str, 0, str.length())</code> 。</li>
  <li><code class="language-plaintext highlighter-rouge">write(String str, int off, int len)</code>：在<code class="language-plaintext highlighter-rouge">write(String str)</code> 方法的基础上增加了 <code class="language-plaintext highlighter-rouge">off</code> 参数（偏移量）和 <code class="language-plaintext highlighter-rouge">len</code> 参数（要读取的最大字符数）。</li>
  <li><code class="language-plaintext highlighter-rouge">append(CharSequence csq)</code>：将指定的字符序列附加到指定的 <code class="language-plaintext highlighter-rouge">Writer</code> 对象并返回该 <code class="language-plaintext highlighter-rouge">Writer</code> 对象。</li>
  <li><code class="language-plaintext highlighter-rouge">append(char c)</code>：将指定的字符附加到指定的 <code class="language-plaintext highlighter-rouge">Writer</code> 对象并返回该 <code class="language-plaintext highlighter-rouge">Writer</code> 对象。</li>
  <li><code class="language-plaintext highlighter-rouge">flush()</code>：刷新此输出流并强制写出所有缓冲的输出字符。</li>
  <li><code class="language-plaintext highlighter-rouge">close()</code>:关闭输出流释放相关的系统资源。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">OutputStreamWriter</code> 是字符流转换为字节流的桥梁，其子类 <code class="language-plaintext highlighter-rouge">FileWriter</code> 是基于该基础上的封装，可以直接将字符写入到文件。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 字符流转换为字节流的桥梁</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OutputStreamWriter</span> <span class="kd">extends</span> <span class="nc">Writer</span> <span class="o">{</span>
<span class="o">}</span>
<span class="c1">// 用于写入字符到文件</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FileWriter</span> <span class="kd">extends</span> <span class="nc">OutputStreamWriter</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">FileWriter</code> 代码示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">Writer</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"output.txt"</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">output</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"你好，我是Guide。"</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>输出结果：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/image-20220419155802288.png" alt="" /></p>

<h2 id="字节缓冲流">字节缓冲流</h2>

<p>IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。</p>

<p>字节缓冲流这里采用了装饰器模式来增强 <code class="language-plaintext highlighter-rouge">InputStream</code> 和<code class="language-plaintext highlighter-rouge">OutputStream</code>子类对象的功能。</p>

<p>举个例子，我们可以通过 <code class="language-plaintext highlighter-rouge">BufferedInputStream</code>（字节缓冲输入流）来增强 <code class="language-plaintext highlighter-rouge">FileInputStream</code> 的功能。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 新建一个 BufferedInputStream 对象</span>
<span class="nc">BufferedInputStream</span> <span class="n">bufferedInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"input.txt"</span><span class="o">));</span>
</code></pre></div></div>

<p>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 <code class="language-plaintext highlighter-rouge">write(int b)</code> 和 <code class="language-plaintext highlighter-rouge">read()</code> 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</p>

<p>我使用 <code class="language-plaintext highlighter-rouge">write(int b)</code> 和 <code class="language-plaintext highlighter-rouge">read()</code> 方法，分别通过字节流和字节缓冲流复制一个 <code class="language-plaintext highlighter-rouge">524.9 mb</code> 的 PDF 文件耗时对比如下：</p>

<pre><code class="language-plain">使用缓冲流复制PDF文件总耗时:15428 毫秒
使用普通字节流复制PDF文件总耗时:2555062 毫秒
</code></pre>

<p>两者耗时差别非常大，缓冲流耗费的时间是字节流的 1/165。</p>

<p>测试代码如下:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">copy_pdf_to_another_pdf_buffer_stream</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 记录开始时间</span>
    <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedInputStream</span> <span class="n">bis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"深入理解计算机操作系统.pdf"</span><span class="o">));</span>
         <span class="nc">BufferedOutputStream</span> <span class="n">bos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"深入理解计算机操作系统-副本.pdf"</span><span class="o">)))</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">content</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">content</span> <span class="o">=</span> <span class="n">bis</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">bos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">content</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">// 记录结束时间</span>
    <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"使用缓冲流复制PDF文件总耗时:"</span> <span class="o">+</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)</span> <span class="o">+</span> <span class="s">" 毫秒"</span><span class="o">);</span>
<span class="o">}</span>

<span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">copy_pdf_to_another_pdf_stream</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 记录开始时间</span>
    <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">(</span><span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"深入理解计算机操作系统.pdf"</span><span class="o">);</span>
         <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"深入理解计算机操作系统-副本.pdf"</span><span class="o">))</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">content</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">content</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">content</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">// 记录结束时间</span>
    <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"使用普通流复制PDF文件总耗时:"</span> <span class="o">+</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)</span> <span class="o">+</span> <span class="s">" 毫秒"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>如果是调用 <code class="language-plaintext highlighter-rouge">read(byte b[])</code> 和 <code class="language-plaintext highlighter-rouge">write(byte b[], int off, int len)</code> 这两个写入一个字节数组的方法的话，只要字节数组的大小合适，两者的性能差距其实不大，基本可以忽略。</p>

<p>这次我们使用 <code class="language-plaintext highlighter-rouge">read(byte b[])</code> 和 <code class="language-plaintext highlighter-rouge">write(byte b[], int off, int len)</code> 方法，分别通过字节流和字节缓冲流复制一个 524.9 mb 的 PDF 文件耗时对比如下：</p>

<pre><code class="language-plain">使用缓冲流复制PDF文件总耗时:695 毫秒
使用普通字节流复制PDF文件总耗时:989 毫秒
</code></pre>

<p>两者耗时差别不是很大，缓冲流的性能要略微好一点点。</p>

<p>测试代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">copy_pdf_to_another_pdf_with_byte_array_buffer_stream</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 记录开始时间</span>
    <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedInputStream</span> <span class="n">bis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"深入理解计算机操作系统.pdf"</span><span class="o">));</span>
         <span class="nc">BufferedOutputStream</span> <span class="n">bos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"深入理解计算机操作系统-副本.pdf"</span><span class="o">)))</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">len</span><span class="o">;</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">1024</span><span class="o">];</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">bis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">bytes</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">bos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">bytes</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">// 记录结束时间</span>
    <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"使用缓冲流复制PDF文件总耗时:"</span> <span class="o">+</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)</span> <span class="o">+</span> <span class="s">" 毫秒"</span><span class="o">);</span>
<span class="o">}</span>

<span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">copy_pdf_to_another_pdf_with_byte_array_stream</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 记录开始时间</span>
    <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">(</span><span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"深入理解计算机操作系统.pdf"</span><span class="o">);</span>
         <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"深入理解计算机操作系统-副本.pdf"</span><span class="o">))</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">len</span><span class="o">;</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">1024</span><span class="o">];</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">bytes</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">bytes</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">// 记录结束时间</span>
    <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"使用普通流复制PDF文件总耗时:"</span> <span class="o">+</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)</span> <span class="o">+</span> <span class="s">" 毫秒"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="bufferedinputstream字节缓冲输入流">BufferedInputStream（字节缓冲输入流）</h3>

<p><code class="language-plaintext highlighter-rouge">BufferedInputStream</code> 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。</p>

<p><code class="language-plaintext highlighter-rouge">BufferedInputStream</code> 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组，通过阅读 <code class="language-plaintext highlighter-rouge">BufferedInputStream</code> 源码即可得到这个结论。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span>
<span class="kd">class</span> <span class="nc">BufferedInputStream</span> <span class="kd">extends</span> <span class="nc">FilterInputStream</span> <span class="o">{</span>
    <span class="c1">// 内部缓冲区数组</span>
    <span class="kd">protected</span> <span class="kd">volatile</span> <span class="kt">byte</span> <span class="n">buf</span><span class="o">[];</span>
    <span class="c1">// 缓冲区的默认大小</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="no">DEFAULT_BUFFER_SIZE</span> <span class="o">=</span> <span class="mi">8192</span><span class="o">;</span>
    <span class="c1">// 使用默认的缓冲区大小</span>
    <span class="kd">public</span> <span class="nf">BufferedInputStream</span><span class="o">(</span><span class="nc">InputStream</span> <span class="n">in</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="no">DEFAULT_BUFFER_SIZE</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 自定义缓冲区大小</span>
    <span class="kd">public</span> <span class="nf">BufferedInputStream</span><span class="o">(</span><span class="nc">InputStream</span> <span class="n">in</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Buffer size &lt;= 0"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>缓冲区的大小默认为 <strong>8192</strong> 字节，当然了，你也可以通过 <code class="language-plaintext highlighter-rouge">BufferedInputStream(InputStream in, int size)</code> 这个构造方法来指定缓冲区的大小。</p>

<h3 id="bufferedoutputstream字节缓冲输出流">BufferedOutputStream（字节缓冲输出流）</h3>

<p><code class="language-plaintext highlighter-rouge">BufferedOutputStream</code> 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">BufferedOutputStream</span> <span class="n">bos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"output.txt"</span><span class="o">)))</span> <span class="o">{</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="s">"JavaGuide"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span>
    <span class="n">bos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">array</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>类似于 <code class="language-plaintext highlighter-rouge">BufferedInputStream</code> ，<code class="language-plaintext highlighter-rouge">BufferedOutputStream</code> 内部也维护了一个缓冲区，并且，这个缓存区的大小也是 <strong>8192</strong> 字节。</p>

<h2 id="字符缓冲流">字符缓冲流</h2>

<p><code class="language-plaintext highlighter-rouge">BufferedReader</code> （字符缓冲输入流）和 <code class="language-plaintext highlighter-rouge">BufferedWriter</code>（字符缓冲输出流）类似于 <code class="language-plaintext highlighter-rouge">BufferedInputStream</code>（字节缓冲输入流）和<code class="language-plaintext highlighter-rouge">BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。</p>

<h2 id="打印流">打印流</h2>

<p>下面这段代码大家经常使用吧？</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Hello！"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello！"</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">System.out</code> 实际是用于获取一个 <code class="language-plaintext highlighter-rouge">PrintStream</code> 对象，<code class="language-plaintext highlighter-rouge">print</code>方法实际调用的是 <code class="language-plaintext highlighter-rouge">PrintStream</code> 对象的 <code class="language-plaintext highlighter-rouge">write</code> 方法。</p>

<p><code class="language-plaintext highlighter-rouge">PrintStream</code> 属于字节打印流，与之对应的是 <code class="language-plaintext highlighter-rouge">PrintWriter</code> （字符打印流）。<code class="language-plaintext highlighter-rouge">PrintStream</code> 是 <code class="language-plaintext highlighter-rouge">OutputStream</code> 的子类，<code class="language-plaintext highlighter-rouge">PrintWriter</code> 是 <code class="language-plaintext highlighter-rouge">Writer</code> 的子类。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PrintStream</span> <span class="kd">extends</span> <span class="nc">FilterOutputStream</span>
    <span class="kd">implements</span> <span class="nc">Appendable</span><span class="o">,</span> <span class="nc">Closeable</span> <span class="o">{</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PrintWriter</span> <span class="kd">extends</span> <span class="nc">Writer</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="随机访问流">随机访问流</h2>

<p>这里要介绍的随机访问流指的是支持随意跳转到文件的任意位置进行读写的 <code class="language-plaintext highlighter-rouge">RandomAccessFile</code> 。</p>

<p><code class="language-plaintext highlighter-rouge">RandomAccessFile</code> 的构造方法如下，我们可以指定 <code class="language-plaintext highlighter-rouge">mode</code>（读写模式）。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// openAndDelete 参数默认为 false 表示打开文件并且这个文件不会被删除</span>
<span class="kd">public</span> <span class="nf">RandomAccessFile</span><span class="o">(</span><span class="nc">File</span> <span class="n">file</span><span class="o">,</span> <span class="nc">String</span> <span class="n">mode</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="nc">FileNotFoundException</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="n">mode</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 私有方法</span>
<span class="kd">private</span> <span class="nf">RandomAccessFile</span><span class="o">(</span><span class="nc">File</span> <span class="n">file</span><span class="o">,</span> <span class="nc">String</span> <span class="n">mode</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">openAndDelete</span><span class="o">)</span>  <span class="kd">throws</span> <span class="nc">FileNotFoundException</span><span class="o">{</span>
  <span class="c1">// 省略大部分代码</span>
<span class="o">}</span>
</code></pre></div></div>

<p>读写模式主要有下面四种：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">r</code> : 只读模式。</li>
  <li><code class="language-plaintext highlighter-rouge">rw</code>: 读写模式</li>
  <li><code class="language-plaintext highlighter-rouge">rws</code>: 相对于 <code class="language-plaintext highlighter-rouge">rw</code>，<code class="language-plaintext highlighter-rouge">rws</code> 同步更新对“文件的内容”或“元数据”的修改到外部存储设备。</li>
  <li><code class="language-plaintext highlighter-rouge">rwd</code> : 相对于 <code class="language-plaintext highlighter-rouge">rw</code>，<code class="language-plaintext highlighter-rouge">rwd</code> 同步更新对“文件的内容”的修改到外部存储设备。</li>
</ul>

<p>文件内容指的是文件中实际保存的数据，元数据则是用来描述文件属性比如文件的大小信息、创建和修改时间。</p>

<p><code class="language-plaintext highlighter-rouge">RandomAccessFile</code> 中有一个文件指针用来表示下一个将要被写入或者读取的字节所处的位置。我们可以通过 <code class="language-plaintext highlighter-rouge">RandomAccessFile</code> 的 <code class="language-plaintext highlighter-rouge">seek(long pos)</code> 方法来设置文件指针的偏移量（距文件开头 <code class="language-plaintext highlighter-rouge">pos</code> 个字节处）。如果想要获取文件指针当前的位置的话，可以使用 <code class="language-plaintext highlighter-rouge">getFilePointer()</code> 方法。</p>

<p><code class="language-plaintext highlighter-rouge">RandomAccessFile</code> 代码示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">RandomAccessFile</span> <span class="n">randomAccessFile</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RandomAccessFile</span><span class="o">(</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"input.txt"</span><span class="o">),</span> <span class="s">"rw"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"读取之前的偏移量："</span> <span class="o">+</span> <span class="n">randomAccessFile</span><span class="o">.</span><span class="na">getFilePointer</span><span class="o">()</span> <span class="o">+</span> <span class="s">",当前读取到的字符"</span> <span class="o">+</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span> <span class="n">randomAccessFile</span><span class="o">.</span><span class="na">read</span><span class="o">()</span> <span class="o">+</span> <span class="s">"，读取之后的偏移量："</span> <span class="o">+</span> <span class="n">randomAccessFile</span><span class="o">.</span><span class="na">getFilePointer</span><span class="o">());</span>
<span class="c1">// 指针当前偏移量为 6</span>
<span class="n">randomAccessFile</span><span class="o">.</span><span class="na">seek</span><span class="o">(</span><span class="mi">6</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"读取之前的偏移量："</span> <span class="o">+</span> <span class="n">randomAccessFile</span><span class="o">.</span><span class="na">getFilePointer</span><span class="o">()</span> <span class="o">+</span> <span class="s">",当前读取到的字符"</span> <span class="o">+</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span> <span class="n">randomAccessFile</span><span class="o">.</span><span class="na">read</span><span class="o">()</span> <span class="o">+</span> <span class="s">"，读取之后的偏移量："</span> <span class="o">+</span> <span class="n">randomAccessFile</span><span class="o">.</span><span class="na">getFilePointer</span><span class="o">());</span>
<span class="c1">// 从偏移量 7 的位置开始往后写入字节数据</span>
<span class="n">randomAccessFile</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[]{</span><span class="sc">'H'</span><span class="o">,</span> <span class="sc">'I'</span><span class="o">,</span> <span class="sc">'J'</span><span class="o">,</span> <span class="sc">'K'</span><span class="o">});</span>
<span class="c1">// 指针当前偏移量为 0，回到起始位置</span>
<span class="n">randomAccessFile</span><span class="o">.</span><span class="na">seek</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"读取之前的偏移量："</span> <span class="o">+</span> <span class="n">randomAccessFile</span><span class="o">.</span><span class="na">getFilePointer</span><span class="o">()</span> <span class="o">+</span> <span class="s">",当前读取到的字符"</span> <span class="o">+</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span> <span class="n">randomAccessFile</span><span class="o">.</span><span class="na">read</span><span class="o">()</span> <span class="o">+</span> <span class="s">"，读取之后的偏移量："</span> <span class="o">+</span> <span class="n">randomAccessFile</span><span class="o">.</span><span class="na">getFilePointer</span><span class="o">());</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">input.txt</code> 文件内容：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/image-20220421162050158.png" alt="" /></p>

<p>输出：</p>

<pre><code class="language-plain">读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1
读取之前的偏移量：6,当前读取到的字符G，读取之后的偏移量：7
读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1
</code></pre>

<p><code class="language-plaintext highlighter-rouge">input.txt</code> 文件内容变为 <code class="language-plaintext highlighter-rouge">ABCDEFGHIJK</code> 。</p>

<p><code class="language-plaintext highlighter-rouge">RandomAccessFile</code> 的 <code class="language-plaintext highlighter-rouge">write</code> 方法在写入对象的时候如果对应的位置已经有数据的话，会将其覆盖掉。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">RandomAccessFile</span> <span class="n">randomAccessFile</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RandomAccessFile</span><span class="o">(</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"input.txt"</span><span class="o">),</span> <span class="s">"rw"</span><span class="o">);</span>
<span class="n">randomAccessFile</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[]{</span><span class="sc">'H'</span><span class="o">,</span> <span class="sc">'I'</span><span class="o">,</span> <span class="sc">'J'</span><span class="o">,</span> <span class="sc">'K'</span><span class="o">});</span>
</code></pre></div></div>

<p>假设运行上面这段程序之前 <code class="language-plaintext highlighter-rouge">input.txt</code> 文件内容变为 <code class="language-plaintext highlighter-rouge">ABCD</code> ，运行之后则变为 <code class="language-plaintext highlighter-rouge">HIJK</code> 。</p>

<p><code class="language-plaintext highlighter-rouge">RandomAccessFile</code> 比较常见的一个应用就是实现大文件的 <strong>断点续传</strong> 。何谓断点续传？简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。</p>

<p><code class="language-plaintext highlighter-rouge">RandomAccessFile</code> 可以帮助我们合并文件分片，示例代码如下：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/io/20210609164749122.png" alt="" /></p>

<p>我在<a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》</a>中详细介绍了大文件的上传问题。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/image-20220428104115362.png" alt="" /></p>

<p><code class="language-plaintext highlighter-rouge">RandomAccessFile</code> 的实现依赖于 <code class="language-plaintext highlighter-rouge">FileDescriptor</code> (文件描述符) 和 <code class="language-plaintext highlighter-rouge">FileChannel</code> （内存映射文件）。</p>

<!-- @include: @article-footer.snippet.md -->
