<p>这篇文章我们简单来看看我们从 IO 中能够学习到哪些设计模式的应用。</p>

<h2 id="装饰器模式">装饰器模式</h2>

<p><strong>装饰器（Decorator）模式</strong> 可以在不改变原有对象的情况下拓展其功能。</p>

<p>装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。</p>

<p>对于字节流来说， <code class="language-plaintext highlighter-rouge">FilterInputStream</code> （对应输入流）和<code class="language-plaintext highlighter-rouge">FilterOutputStream</code>（对应输出流）是装饰器模式的核心，分别用于增强 <code class="language-plaintext highlighter-rouge">InputStream</code> 和<code class="language-plaintext highlighter-rouge">OutputStream</code>子类对象的功能。</p>

<p>我们常见的<code class="language-plaintext highlighter-rouge">BufferedInputStream</code>(字节缓冲输入流)、<code class="language-plaintext highlighter-rouge">DataInputStream</code> 等等都是<code class="language-plaintext highlighter-rouge">FilterInputStream</code> 的子类，<code class="language-plaintext highlighter-rouge">BufferedOutputStream</code>（字节缓冲输出流）、<code class="language-plaintext highlighter-rouge">DataOutputStream</code>等等都是<code class="language-plaintext highlighter-rouge">FilterOutputStream</code>的子类。</p>

<p>举个例子，我们可以通过 <code class="language-plaintext highlighter-rouge">BufferedInputStream</code>（字节缓冲输入流）来增强 <code class="language-plaintext highlighter-rouge">FileInputStream</code> 的功能。</p>

<p><code class="language-plaintext highlighter-rouge">BufferedInputStream</code> 构造函数如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">BufferedInputStream</span><span class="o">(</span><span class="nc">InputStream</span> <span class="n">in</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="no">DEFAULT_BUFFER_SIZE</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nf">BufferedInputStream</span><span class="o">(</span><span class="nc">InputStream</span> <span class="n">in</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Buffer size &lt;= 0"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">buf</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
<span class="o">}</span>
</code></pre></div></div>

<p>可以看出，<code class="language-plaintext highlighter-rouge">BufferedInputStream</code> 的构造函数其中的一个参数就是 <code class="language-plaintext highlighter-rouge">InputStream</code> 。</p>

<p><code class="language-plaintext highlighter-rouge">BufferedInputStream</code> 代码示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">BufferedInputStream</span> <span class="n">bis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"input.txt"</span><span class="o">)))</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">content</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">skip</span> <span class="o">=</span> <span class="n">bis</span><span class="o">.</span><span class="na">skip</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">((</span><span class="n">content</span> <span class="o">=</span> <span class="n">bis</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="n">content</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个时候，你可以会想了：<strong>为啥我们直接不弄一个<code class="language-plaintext highlighter-rouge">BufferedFileInputStream</code>（字符缓冲文件输入流）呢？</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BufferedFileInputStream</span> <span class="n">bfis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedFileInputStream</span><span class="o">(</span><span class="s">"input.txt"</span><span class="o">);</span>
</code></pre></div></div>

<p>如果 <code class="language-plaintext highlighter-rouge">InputStream</code>的子类比较少的话，这样做是没问题的。不过， <code class="language-plaintext highlighter-rouge">InputStream</code>的子类实在太多，继承关系也太复杂了。如果我们为每一个子类都定制一个对应的缓冲输入流，那岂不是太麻烦了。</p>

<p>如果你对 IO 流比较熟悉的话，你会发现<code class="language-plaintext highlighter-rouge">ZipInputStream</code> 和<code class="language-plaintext highlighter-rouge">ZipOutputStream</code> 还可以分别增强 <code class="language-plaintext highlighter-rouge">BufferedInputStream</code> 和 <code class="language-plaintext highlighter-rouge">BufferedOutputStream</code> 的能力。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BufferedInputStream</span> <span class="n">bis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">fileName</span><span class="o">));</span>
<span class="nc">ZipInputStream</span> <span class="n">zis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ZipInputStream</span><span class="o">(</span><span class="n">bis</span><span class="o">);</span>

<span class="nc">BufferedOutputStream</span> <span class="n">bos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">fileName</span><span class="o">));</span>
<span class="nc">ZipOutputStream</span> <span class="n">zipOut</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ZipOutputStream</span><span class="o">(</span><span class="n">bos</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ZipInputStream</code> 和<code class="language-plaintext highlighter-rouge">ZipOutputStream</code> 分别继承自<code class="language-plaintext highlighter-rouge">InflaterInputStream</code> 和<code class="language-plaintext highlighter-rouge">DeflaterOutputStream</code>。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span>
<span class="kd">class</span> <span class="nc">InflaterInputStream</span> <span class="kd">extends</span> <span class="nc">FilterInputStream</span> <span class="o">{</span>
<span class="o">}</span>

<span class="kd">public</span>
<span class="kd">class</span> <span class="nc">DeflaterOutputStream</span> <span class="kd">extends</span> <span class="nc">FilterOutputStream</span> <span class="o">{</span>
<span class="o">}</span>

</code></pre></div></div>

<p>这也是装饰器模式很重要的一个特征，那就是可以对原始类嵌套使用多个装饰器。</p>

<p>为了实现这一效果，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。上面介绍到的这些 IO 相关的装饰类和原始类共同的父类是 <code class="language-plaintext highlighter-rouge">InputStream</code> 和<code class="language-plaintext highlighter-rouge">OutputStream</code>。</p>

<p>对于字符流来说，<code class="language-plaintext highlighter-rouge">BufferedReader</code> 可以用来增加 <code class="language-plaintext highlighter-rouge">Reader</code> （字符输入流）子类的功能，<code class="language-plaintext highlighter-rouge">BufferedWriter</code> 可以用来增加 <code class="language-plaintext highlighter-rouge">Writer</code> （字符输出流）子类的功能。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">fileName</span><span class="o">),</span> <span class="s">"UTF-8"</span><span class="o">));</span>
</code></pre></div></div>

<p>IO 流中的装饰器模式应用的例子实在是太多了，不需要特意记忆，完全没必要哈！搞清了装饰器模式的核心之后，你在使用的时候自然就会知道哪些地方运用到了装饰器模式。</p>

<h2 id="适配器模式">适配器模式</h2>

<p><strong>适配器（Adapter Pattern）模式</strong> 主要用于接口互不兼容的类的协调工作，你可以将其联想到我们日常经常使用的电源适配器。</p>

<p>适配器模式中存在被适配的对象或者类称为 <strong>适配者(Adaptee)</strong> ，作用于适配者的对象或者类称为<strong>适配器(Adapter)</strong> 。适配器分为对象适配器和类适配器。类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p>

<p>IO 流中的字符流和字节流的接口不同，它们之间可以协调工作就是基于适配器模式来做的，更准确点来说是对象适配器。通过适配器，我们可以将字节流对象适配成一个字符流对象，这样我们可以直接通过字节流对象来读取或者写入字符数据。</p>

<p><code class="language-plaintext highlighter-rouge">InputStreamReader</code> 和 <code class="language-plaintext highlighter-rouge">OutputStreamWriter</code> 就是两个适配器(Adapter)， 同时，它们两个也是字节流和字符流之间的桥梁。<code class="language-plaintext highlighter-rouge">InputStreamReader</code> 使用 <code class="language-plaintext highlighter-rouge">StreamDecoder</code> （流解码器）对字节进行解码，<strong>实现字节流到字符流的转换，</strong> <code class="language-plaintext highlighter-rouge">OutputStreamWriter</code> 使用<code class="language-plaintext highlighter-rouge">StreamEncoder</code>（流编码器）对字符进行编码，实现字符流到字节流的转换。</p>

<p><code class="language-plaintext highlighter-rouge">InputStream</code> 和 <code class="language-plaintext highlighter-rouge">OutputStream</code> 的子类是被适配者， <code class="language-plaintext highlighter-rouge">InputStreamReader</code> 和 <code class="language-plaintext highlighter-rouge">OutputStreamWriter</code>是适配器。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// InputStreamReader 是适配器，FileInputStream 是被适配的类</span>
<span class="nc">InputStreamReader</span> <span class="n">isr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">fileName</span><span class="o">),</span> <span class="s">"UTF-8"</span><span class="o">);</span>
<span class="c1">// BufferedReader 增强 InputStreamReader 的功能（装饰器模式）</span>
<span class="nc">BufferedReader</span> <span class="n">bufferedReader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="n">isr</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">java.io.InputStreamReader</code> 部分源码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">InputStreamReader</span> <span class="kd">extends</span> <span class="nc">Reader</span> <span class="o">{</span>
 <span class="c1">//用于解码的对象</span>
 <span class="kd">private</span> <span class="kd">final</span> <span class="nc">StreamDecoder</span> <span class="n">sd</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">InputStreamReader</span><span class="o">(</span><span class="nc">InputStream</span> <span class="n">in</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 获取 StreamDecoder 对象</span>
            <span class="n">sd</span> <span class="o">=</span> <span class="nc">StreamDecoder</span><span class="o">.</span><span class="na">forInputStreamReader</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="k">this</span><span class="o">,</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span><span class="kc">null</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">UnsupportedEncodingException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 使用 StreamDecoder 对象做具体的读取工作</span>
 <span class="kd">public</span> <span class="kt">int</span> <span class="nf">read</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">sd</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">java.io.OutputStreamWriter</code> 部分源码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OutputStreamWriter</span> <span class="kd">extends</span> <span class="nc">Writer</span> <span class="o">{</span>
    <span class="c1">// 用于编码的对象</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">StreamEncoder</span> <span class="n">se</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">OutputStreamWriter</span><span class="o">(</span><span class="nc">OutputStream</span> <span class="n">out</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">out</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
           <span class="c1">// 获取 StreamEncoder 对象</span>
            <span class="n">se</span> <span class="o">=</span> <span class="nc">StreamEncoder</span><span class="o">.</span><span class="na">forOutputStreamWriter</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="k">this</span><span class="o">,</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span><span class="kc">null</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">UnsupportedEncodingException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 使用 StreamEncoder 对象做具体的写入工作</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">write</span><span class="o">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="n">se</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>适配器模式和装饰器模式有什么区别呢？</strong></p>

<p><strong>装饰器模式</strong> 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。</p>

<p><strong>适配器模式</strong> 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。就比如说 <code class="language-plaintext highlighter-rouge">StreamDecoder</code> （流解码器）和<code class="language-plaintext highlighter-rouge">StreamEncoder</code>（流编码器）就是分别基于 <code class="language-plaintext highlighter-rouge">InputStream</code> 和 <code class="language-plaintext highlighter-rouge">OutputStream</code> 来获取 <code class="language-plaintext highlighter-rouge">FileChannel</code>对象并调用对应的 <code class="language-plaintext highlighter-rouge">read</code> 方法和 <code class="language-plaintext highlighter-rouge">write</code> 方法进行字节数据的读取和写入。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">StreamDecoder</span><span class="o">(</span><span class="nc">InputStream</span> <span class="n">in</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">lock</span><span class="o">,</span> <span class="nc">CharsetDecoder</span> <span class="n">dec</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 省略大部分代码</span>
    <span class="c1">// 根据 InputStream 对象获取 FileChannel 对象</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="n">getChannel</span><span class="o">((</span><span class="nc">FileInputStream</span><span class="o">)</span><span class="n">in</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>适配器和适配者两者不需要继承相同的抽象类或者实现相同的接口。</p>

<p>另外，<code class="language-plaintext highlighter-rouge">FutureTask</code> 类使用了适配器模式，<code class="language-plaintext highlighter-rouge">Executors</code> 的内部类 <code class="language-plaintext highlighter-rouge">RunnableAdapter</code> 实现属于适配器，用于将 <code class="language-plaintext highlighter-rouge">Runnable</code> 适配成 <code class="language-plaintext highlighter-rouge">Callable</code>。</p>

<p><code class="language-plaintext highlighter-rouge">FutureTask</code>参数包含 <code class="language-plaintext highlighter-rouge">Runnable</code> 的一个构造方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">FutureTask</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">runnable</span><span class="o">,</span> <span class="no">V</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 调用 Executors 类的 callable 方法</span>
    <span class="k">this</span><span class="o">.</span><span class="na">callable</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">callable</span><span class="o">(</span><span class="n">runnable</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="no">NEW</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Executors</code>中对应的方法和适配器：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 实际调用的是 Executors 的内部类 RunnableAdapter 的构造方法</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">callable</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">task</span><span class="o">,</span> <span class="no">T</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">task</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">RunnableAdapter</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;(</span><span class="n">task</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 适配器</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">RunnableAdapter</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="nc">Runnable</span> <span class="n">task</span><span class="o">;</span>
    <span class="kd">final</span> <span class="no">T</span> <span class="n">result</span><span class="o">;</span>
    <span class="nc">RunnableAdapter</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">task</span><span class="o">,</span> <span class="no">T</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">task</span> <span class="o">=</span> <span class="n">task</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">call</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">task</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="工厂模式">工厂模式</h2>

<p>工厂模式用于创建对象，NIO 中大量用到了工厂模式，比如 <code class="language-plaintext highlighter-rouge">Files</code> 类的 <code class="language-plaintext highlighter-rouge">newInputStream</code> 方法用于创建 <code class="language-plaintext highlighter-rouge">InputStream</code> 对象（静态工厂）、 <code class="language-plaintext highlighter-rouge">Paths</code> 类的 <code class="language-plaintext highlighter-rouge">get</code> 方法创建 <code class="language-plaintext highlighter-rouge">Path</code> 对象（静态工厂）、<code class="language-plaintext highlighter-rouge">ZipFileSystem</code> 类（<code class="language-plaintext highlighter-rouge">sun.nio</code>包下的类，属于 <code class="language-plaintext highlighter-rouge">java.nio</code> 相关的一些内部实现）的 <code class="language-plaintext highlighter-rouge">getPath</code> 的方法创建 <code class="language-plaintext highlighter-rouge">Path</code> 对象（简单工厂）。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">is</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">newInputStream</span><span class="o">(</span><span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">generatorLogoPath</span><span class="o">))</span>
</code></pre></div></div>

<h2 id="观察者模式">观察者模式</h2>

<p>NIO 中的文件目录监听服务使用到了观察者模式。</p>

<p>NIO 中的文件目录监听服务基于 <code class="language-plaintext highlighter-rouge">WatchService</code> 接口和 <code class="language-plaintext highlighter-rouge">Watchable</code> 接口。<code class="language-plaintext highlighter-rouge">WatchService</code> 属于观察者，<code class="language-plaintext highlighter-rouge">Watchable</code> 属于被观察者。</p>

<p><code class="language-plaintext highlighter-rouge">Watchable</code> 接口定义了一个用于将对象注册到 <code class="language-plaintext highlighter-rouge">WatchService</code>（监控服务） 并绑定监听事件的方法 <code class="language-plaintext highlighter-rouge">register</code> 。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Path</span>
    <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">Path</span><span class="o">&gt;,</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Path</span><span class="o">&gt;,</span> <span class="nc">Watchable</span><span class="o">{</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Watchable</span> <span class="o">{</span>
    <span class="nc">WatchKey</span> <span class="nf">register</span><span class="o">(</span><span class="nc">WatchService</span> <span class="n">watcher</span><span class="o">,</span>
                      <span class="nc">WatchEvent</span><span class="o">.</span><span class="na">Kind</span><span class="o">&lt;?&gt;[]</span> <span class="n">events</span><span class="o">,</span>
                      <span class="nc">WatchEvent</span><span class="o">.</span><span class="na">Modifier</span><span class="o">...</span> <span class="n">modifiers</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">WatchService</code> 用于监听文件目录的变化，同一个 <code class="language-plaintext highlighter-rouge">WatchService</code> 对象能够监听多个文件目录。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建 WatchService 对象</span>
<span class="nc">WatchService</span> <span class="n">watchService</span> <span class="o">=</span> <span class="nc">FileSystems</span><span class="o">.</span><span class="na">getDefault</span><span class="o">().</span><span class="na">newWatchService</span><span class="o">();</span>

<span class="c1">// 初始化一个被监控文件夹的 Path 类:</span>
<span class="nc">Path</span> <span class="n">path</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"workingDirectory"</span><span class="o">);</span>
<span class="c1">// 将这个 path 对象注册到 WatchService（监控服务） 中去</span>
<span class="nc">WatchKey</span> <span class="n">watchKey</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="na">register</span><span class="o">(</span>
<span class="n">watchService</span><span class="o">,</span> <span class="nc">StandardWatchEventKinds</span><span class="o">...);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Path</code> 类 <code class="language-plaintext highlighter-rouge">register</code> 方法的第二个参数 <code class="language-plaintext highlighter-rouge">events</code> （需要监听的事件）为可变长参数，也就是说我们可以同时监听多种事件。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">WatchKey</span> <span class="nf">register</span><span class="o">(</span><span class="nc">WatchService</span> <span class="n">watcher</span><span class="o">,</span>
                  <span class="nc">WatchEvent</span><span class="o">.</span><span class="na">Kind</span><span class="o">&lt;?&gt;...</span> <span class="n">events</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">;</span>
</code></pre></div></div>

<p>常用的监听事件有 3 种：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">StandardWatchEventKinds.ENTRY_CREATE</code>：文件创建。</li>
  <li><code class="language-plaintext highlighter-rouge">StandardWatchEventKinds.ENTRY_DELETE</code> : 文件删除。</li>
  <li><code class="language-plaintext highlighter-rouge">StandardWatchEventKinds.ENTRY_MODIFY</code> : 文件修改。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">register</code> 方法返回 <code class="language-plaintext highlighter-rouge">WatchKey</code> 对象，通过<code class="language-plaintext highlighter-rouge">WatchKey</code> 对象可以获取事件的具体信息比如文件目录下是创建、删除还是修改了文件、创建、删除或者修改的文件的具体名称是什么。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">WatchKey</span> <span class="n">key</span><span class="o">;</span>
<span class="k">while</span> <span class="o">((</span><span class="n">key</span> <span class="o">=</span> <span class="n">watchService</span><span class="o">.</span><span class="na">take</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">WatchEvent</span><span class="o">&lt;?&gt;</span> <span class="n">event</span> <span class="o">:</span> <span class="n">key</span><span class="o">.</span><span class="na">pollEvents</span><span class="o">())</span> <span class="o">{</span>
      <span class="c1">// 可以调用 WatchEvent 对象的方法做一些事情比如输出事件的具体上下文信息</span>
    <span class="o">}</span>
    <span class="n">key</span><span class="o">.</span><span class="na">reset</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">WatchService</code> 内部是通过一个 daemon thread（守护线程）采用定期轮询的方式来检测文件的变化，简化后的源码如下所示。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">PollingWatchService</span>
    <span class="kd">extends</span> <span class="nc">AbstractWatchService</span>
<span class="o">{</span>
    <span class="c1">// 定义一个 daemon thread（守护线程）轮询检测文件变化</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">ScheduledExecutorService</span> <span class="n">scheduledExecutor</span><span class="o">;</span>

    <span class="nc">PollingWatchService</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">scheduledExecutor</span> <span class="o">=</span> <span class="nc">Executors</span>
            <span class="o">.</span><span class="na">newSingleThreadScheduledExecutor</span><span class="o">(</span><span class="k">new</span> <span class="nc">ThreadFactory</span><span class="o">()</span> <span class="o">{</span>
                 <span class="nd">@Override</span>
                 <span class="kd">public</span> <span class="nc">Thread</span> <span class="nf">newThread</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
                     <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
                     <span class="n">t</span><span class="o">.</span><span class="na">setDaemon</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
                     <span class="k">return</span> <span class="n">t</span><span class="o">;</span>
                 <span class="o">}});</span>
    <span class="o">}</span>

  <span class="kt">void</span> <span class="nf">enable</span><span class="o">(</span><span class="nc">Set</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">WatchEvent</span><span class="o">.</span><span class="na">Kind</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">events</span><span class="o">,</span> <span class="kt">long</span> <span class="n">period</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 更新监听事件</span>
      <span class="k">this</span><span class="o">.</span><span class="na">events</span> <span class="o">=</span> <span class="n">events</span><span class="o">;</span>

        <span class="c1">// 开启定期轮询</span>
      <span class="nc">Runnable</span> <span class="n">thunk</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> <span class="n">poll</span><span class="o">();</span> <span class="o">}};</span>
      <span class="k">this</span><span class="o">.</span><span class="na">poller</span> <span class="o">=</span> <span class="n">scheduledExecutor</span>
        <span class="o">.</span><span class="na">scheduleAtFixedRate</span><span class="o">(</span><span class="n">thunk</span><span class="o">,</span> <span class="n">period</span><span class="o">,</span> <span class="n">period</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="参考">参考</h2>

<ul>
  <li>Patterns in Java APIs：<a href="http://cecs.wright.edu/~tkprasad/courses/ceg860/paper/node26.html">http://cecs.wright.edu/~tkprasad/courses/ceg860/paper/node26.html</a></li>
  <li>装饰器模式：通过剖析 Java IO 类库源码学习装饰器模式：<a href="https://time.geekbang.org/column/article/204845">https://time.geekbang.org/column/article/204845</a></li>
  <li>sun.nio 包是什么，是 java 代码么？ - RednaxelaFX <a href="https://www.zhihu.com/question/29237781/answer/43653953">https://www.zhihu.com/question/29237781/answer/43653953</a></li>
</ul>

<!-- @include: @article-footer.snippet.md -->
