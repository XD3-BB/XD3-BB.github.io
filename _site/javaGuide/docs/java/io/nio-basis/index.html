<p>在学习 NIO 之前，需要先了解一下计算机 I/O 模型的基础理论知识。还不了解的话，可以参考我写的这篇文章：<a href="https://javaguide.cn/java/io/io-model.html">Java IO 模型详解</a>。</p>

<h2 id="nio-简介">NIO 简介</h2>

<p>在传统的 Java I/O 模型（BIO）中，I/O 操作是以阻塞的方式进行的。也就是说，当一个线程执行一个 I/O 操作时，它会被阻塞直到操作完成。这种阻塞模型在处理多个并发连接时可能会导致性能瓶颈，因为需要为每个连接创建一个线程，而线程的创建和切换都是有开销的。</p>

<p>为了解决这个问题，在 Java1.4 版本引入了一种新的 I/O 模型 — <strong>NIO</strong> （New IO，也称为 Non-blocking IO） 。NIO 弥补了同步阻塞 I/O 的不足，它在标准 Java 代码中提供了非阻塞、面向缓冲、基于通道的 I/O，可以使用少量的线程来处理多个连接，大大提高了 I/O 效率和并发。</p>

<p>下图是 BIO、NIO 和 AIO 处理客户端请求的简单对比图（关于 AIO 的介绍，可以看我写的这篇文章：<a href="https://javaguide.cn/java/io/io-model.html">Java IO 模型详解</a>，不是重点，了解即可）。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/nio/bio-aio-nio.png" alt="BIO、NIO 和 AIO 对比" /></p>

<p>⚠️需要注意：使用 NIO 并不一定意味着高性能，它的性能优势主要体现在高并发和高延迟的网络环境下。当连接数较少、并发程度较低或者网络传输速度较快时，NIO 的性能并不一定优于传统的 BIO 。</p>

<h2 id="nio-核心组件">NIO 核心组件</h2>

<p>NIO 主要包括以下三个核心组件：</p>

<ul>
  <li><strong>Buffer（缓冲区）</strong>：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</li>
  <li><strong>Channel（通道）</strong>：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过 Channel 来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。</li>
  <li><strong>Selector（选择器）</strong>：允许一个线程处理多个 Channel，基于事件驱动的 I/O 多路复用模型。所有的 Channel 都可以注册到 Selector 上，由 Selector 来分配线程来处理事件。</li>
</ul>

<p>三者的关系如下图所示（暂时不理解没关系，后文会详细介绍）：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/nio/channel-buffer-selector.png" alt="Buffer、Channel和Selector三者之间的关系" /></p>

<p>下面详细介绍一下这三个组件。</p>

<h3 id="buffer缓冲区">Buffer（缓冲区）</h3>

<p>在传统的 BIO 中，数据的读写是面向流的， 分为字节流和字符流。</p>

<p>在 Java 1.4 的 NIO 库中，所有数据都是用缓冲区处理的，这是新库和之前的 BIO 的一个重要区别，有点类似于 BIO 中的缓冲流。NIO 在读取数据时，它是直接读到缓冲区中的。在写入数据时，写入到缓冲区中。 使用 NIO 在读写数据时，都是通过缓冲区进行操作。</p>

<p><code class="language-plaintext highlighter-rouge">Buffer</code> 的子类如下图所示。其中，最常用的是 <code class="language-plaintext highlighter-rouge">ByteBuffer</code>，它可以用来存储和操作字节数据。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/nio/buffer-subclasses.png" alt="Buffer 的子类" /></p>

<p>你可以将 Buffer 理解为一个数组，<code class="language-plaintext highlighter-rouge">IntBuffer</code>、<code class="language-plaintext highlighter-rouge">FloatBuffer</code>、<code class="language-plaintext highlighter-rouge">CharBuffer</code> 等分别对应 <code class="language-plaintext highlighter-rouge">int[]</code>、<code class="language-plaintext highlighter-rouge">float[]</code>、<code class="language-plaintext highlighter-rouge">char[]</code> 等。</p>

<p>为了更清晰地认识缓冲区，我们来简单看看<code class="language-plaintext highlighter-rouge">Buffer</code> 类中定义的四个成员变量：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Buffer</span> <span class="o">{</span>
    <span class="c1">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">mark</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">position</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">limit</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这四个成员变量的具体含义如下：</p>

<ol>
  <li>容量（<code class="language-plaintext highlighter-rouge">capacity</code>）：<code class="language-plaintext highlighter-rouge">Buffer</code>可以存储的最大数据量，<code class="language-plaintext highlighter-rouge">Buffer</code>创建时设置且不可改变；</li>
  <li>界限（<code class="language-plaintext highlighter-rouge">limit</code>）：<code class="language-plaintext highlighter-rouge">Buffer</code> 中可以读/写数据的边界。写模式下，<code class="language-plaintext highlighter-rouge">limit</code> 代表最多能写入的数据，一般等于 <code class="language-plaintext highlighter-rouge">capacity</code>（可以通过<code class="language-plaintext highlighter-rouge">limit(int newLimit)</code>方法设置）；读模式下，<code class="language-plaintext highlighter-rouge">limit</code> 等于 Buffer 中实际写入的数据大小。</li>
  <li>位置（<code class="language-plaintext highlighter-rouge">position</code>）：下一个可以被读写的数据的位置（索引）。从写操作模式到读操作模式切换的时候（flip），<code class="language-plaintext highlighter-rouge">position</code> 都会归零，这样就可以从头开始读写了。</li>
  <li>标记（<code class="language-plaintext highlighter-rouge">mark</code>）：<code class="language-plaintext highlighter-rouge">Buffer</code>允许将位置直接定位到该标记处，这是一个可选属性；</li>
</ol>

<p>并且，上述变量满足如下的关系：<strong>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</strong> 。</p>

<p>另外，Buffer 有读模式和写模式这两种模式，分别用于从 Buffer 中读取数据或者向 Buffer 中写入数据。Buffer 被创建之后默认是写模式，调用 <code class="language-plaintext highlighter-rouge">flip()</code> 可以切换到读模式。如果要再次切换回写模式，可以调用 <code class="language-plaintext highlighter-rouge">clear()</code> 或者 <code class="language-plaintext highlighter-rouge">compact()</code> 方法。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/nio/JavaNIOBuffer.png" alt="position 、limit 和 capacity 之前的关系" /></p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/nio/NIOBufferClassAttributes.png" alt="position 、limit 和 capacity 之前的关系" /></p>

<p><code class="language-plaintext highlighter-rouge">Buffer</code> 对象不能通过 <code class="language-plaintext highlighter-rouge">new</code> 调用构造方法创建对象 ，只能通过静态方法实例化 <code class="language-plaintext highlighter-rouge">Buffer</code>。</p>

<p>这里以 <code class="language-plaintext highlighter-rouge">ByteBuffer</code>为例进行介绍：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 分配堆内存</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">ByteBuffer</span> <span class="nf">allocate</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">);</span>
<span class="c1">// 分配直接内存</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">ByteBuffer</span> <span class="nf">allocateDirect</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">);</span>
</code></pre></div></div>

<p>Buffer 最核心的两个方法：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">get</code> : 读取缓冲区的数据</li>
  <li><code class="language-plaintext highlighter-rouge">put</code> ：向缓冲区写入数据</li>
</ol>

<p>除上述两个方法之外，其他的重要方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">flip</code> ：将缓冲区从写模式切换到读模式，它会将 <code class="language-plaintext highlighter-rouge">limit</code> 的值设置为当前 <code class="language-plaintext highlighter-rouge">position</code> 的值，将 <code class="language-plaintext highlighter-rouge">position</code> 的值设置为 0。</li>
  <li><code class="language-plaintext highlighter-rouge">clear</code>: 清空缓冲区，将缓冲区从读模式切换到写模式，并将 <code class="language-plaintext highlighter-rouge">position</code> 的值设置为 0，将 <code class="language-plaintext highlighter-rouge">limit</code> 的值设置为 <code class="language-plaintext highlighter-rouge">capacity</code> 的值。</li>
  <li>……</li>
</ul>

<p>Buffer 中数据变化的过程：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.nio.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CharBufferDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 分配一个容量为8的CharBuffer</span>
        <span class="nc">CharBuffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nc">CharBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">8</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"初始状态："</span><span class="o">);</span>
        <span class="n">printState</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>

        <span class="c1">// 向buffer写入3个字符</span>
        <span class="n">buffer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'a'</span><span class="o">).</span><span class="na">put</span><span class="o">(</span><span class="sc">'b'</span><span class="o">).</span><span class="na">put</span><span class="o">(</span><span class="sc">'c'</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"写入3个字符后的状态："</span><span class="o">);</span>
        <span class="n">printState</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>

        <span class="c1">// 调用flip()方法，准备读取buffer中的数据，将 position 置 0,limit 的置 3</span>
        <span class="n">buffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"调用flip()方法后的状态："</span><span class="o">);</span>
        <span class="n">printState</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>

        <span class="c1">// 读取字符</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">hasRemaining</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
        <span class="o">}</span>

        <span class="c1">// 调用clear()方法，清空缓冲区，将 position 的值置为 0，将 limit 的值置为 capacity 的值</span>
        <span class="n">buffer</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"调用clear()方法后的状态："</span><span class="o">);</span>
        <span class="n">printState</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>

    <span class="o">}</span>

    <span class="c1">// 打印buffer的capacity、limit、position、mark的位置</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printState</span><span class="o">(</span><span class="nc">CharBuffer</span> <span class="n">buffer</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"capacity: "</span> <span class="o">+</span> <span class="n">buffer</span><span class="o">.</span><span class="na">capacity</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">", limit: "</span> <span class="o">+</span> <span class="n">buffer</span><span class="o">.</span><span class="na">limit</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">", position: "</span> <span class="o">+</span> <span class="n">buffer</span><span class="o">.</span><span class="na">position</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">", mark 开始读取的字符: "</span> <span class="o">+</span> <span class="n">buffer</span><span class="o">.</span><span class="na">mark</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>输出:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>初始状态：
capacity: 8, limit: 8, position: 0

写入3个字符后的状态：
capacity: 8, limit: 8, position: 3

准备读取buffer中的数据！

调用flip<span class="o">()</span>方法后的状态：
capacity: 8, limit: 3, position: 0

读取到的数据：abc

调用clear<span class="o">()</span>方法后的状态：
capacity: 8, limit: 8, position: 0
</code></pre></div></div>

<p>为了帮助理解，我绘制了一张图片展示 <code class="language-plaintext highlighter-rouge">capacity</code>、<code class="language-plaintext highlighter-rouge">limit</code>和<code class="language-plaintext highlighter-rouge">position</code>每一阶段的变化。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/nio/NIOBufferClassAttributesDataChanges.png" alt="capacity、limit和position每一阶段的变化" /></p>

<h3 id="channel通道">Channel（通道）</h3>

<p>Channel 是一个通道，它建立了与数据源（如文件、网络套接字等）之间的连接。我们可以利用它来读取和写入数据，就像打开了一条自来水管，让数据在 Channel 中自由流动。</p>

<p>BIO 中的流是单向的，分为各种 <code class="language-plaintext highlighter-rouge">InputStream</code>（输入流）和 <code class="language-plaintext highlighter-rouge">OutputStream</code>（输出流），数据只是在一个方向上传输。通道与流的不同之处在于通道是双向的，它可以用于读、写或者同时用于读写。</p>

<p>Channel 与前面介绍的 Buffer 打交道，读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/nio/channel-buffer.png" alt="Channel 和 Buffer之间的关系" /></p>

<p>另外，因为 Channel 是全双工的，所以它可以比流更好地映射底层操作系统的 API。特别是在 UNIX 网络编程模型中，底层操作系统的通道都是全双工的，同时支持读写操作。</p>

<p><code class="language-plaintext highlighter-rouge">Channel</code> 的子类如下图所示。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/nio/channel-subclasses.png" alt="Channel 的子类" /></p>

<p>其中，最常用的是以下几种类型的通道：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">FileChannel</code>：文件访问通道；</li>
  <li><code class="language-plaintext highlighter-rouge">SocketChannel</code>、<code class="language-plaintext highlighter-rouge">ServerSocketChannel</code>：TCP 通信通道；</li>
  <li><code class="language-plaintext highlighter-rouge">DatagramChannel</code>：UDP 通信通道；</li>
</ul>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/nio/channel-inheritance-relationship.png" alt="Channel继承关系图" /></p>

<p>Channel 最核心的两个方法：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">read</code> ：读取数据并写入到 Buffer 中。</li>
  <li><code class="language-plaintext highlighter-rouge">write</code> ：将 Buffer 中的数据写入到 Channel 中。</li>
</ol>

<p>这里我们以 <code class="language-plaintext highlighter-rouge">FileChannel</code> 为例演示一下是读取文件数据的。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">RandomAccessFile</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RandomAccessFile</span><span class="o">(</span><span class="s">"/Users/guide/Documents/test_read.in"</span><span class="o">,</span> <span class="s">"r"</span><span class="o">))</span>
<span class="nc">FileChannel</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">getChannel</span><span class="o">();</span>
<span class="nc">ByteBuffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">1024</span><span class="o">);</span>
<span class="n">channel</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="selector选择器">Selector（选择器）</h3>

<p>Selector（选择器） 是 NIO 中的一个关键组件，它允许一个线程处理多个 Channel。Selector 是基于事件驱动的 I/O 多路复用模型，主要运作原理是：通过 Selector 注册通道的事件，Selector 会不断地轮询注册在其上的 Channel。当事件发生时，比如：某个 Channel 上面有新的 TCP 连接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来。Selector 会将相关的 Channel 加入到就绪集合中。通过 SelectionKey 可以获取就绪 Channel 的集合，然后对这些就绪的 Channel 进行相应的 I/O 操作。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/nio/selector-channel-selectionkey.png" alt="Selector 选择器工作示意图" /></p>

<p>一个多路复用器 Selector 可以同时轮询多个 Channel，由于 JDK 使用了 <code class="language-plaintext highlighter-rouge">epoll()</code> 代替传统的 <code class="language-plaintext highlighter-rouge">select</code> 实现，所以它并没有最大连接句柄 <code class="language-plaintext highlighter-rouge">1024/2048</code> 的限制。这也就意味着只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端。</p>

<p>Selector 可以监听以下四种事件类型：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SelectionKey.OP_ACCEPT</code>：表示通道接受连接的事件，这通常用于 <code class="language-plaintext highlighter-rouge">ServerSocketChannel</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">SelectionKey.OP_CONNECT</code>：表示通道完成连接的事件，这通常用于 <code class="language-plaintext highlighter-rouge">SocketChannel</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">SelectionKey.OP_READ</code>：表示通道准备好进行读取的事件，即有数据可读。</li>
  <li><code class="language-plaintext highlighter-rouge">SelectionKey.OP_WRITE</code>：表示通道准备好进行写入的事件，即可以写入数据。</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">Selector</code>是抽象类，可以通过调用此类的 <code class="language-plaintext highlighter-rouge">open()</code> 静态方法来创建 Selector 实例。Selector 可以同时监控多个 <code class="language-plaintext highlighter-rouge">SelectableChannel</code> 的 <code class="language-plaintext highlighter-rouge">IO</code> 状况，是非阻塞 <code class="language-plaintext highlighter-rouge">IO</code> 的核心。</p>

<p>一个 Selector 实例有三个 <code class="language-plaintext highlighter-rouge">SelectionKey</code> 集合：</p>

<ol>
  <li>所有的 <code class="language-plaintext highlighter-rouge">SelectionKey</code> 集合：代表了注册在该 Selector 上的 <code class="language-plaintext highlighter-rouge">Channel</code>，这个集合可以通过 <code class="language-plaintext highlighter-rouge">keys()</code> 方法返回。</li>
  <li>被选择的 <code class="language-plaintext highlighter-rouge">SelectionKey</code> 集合：代表了所有可通过 <code class="language-plaintext highlighter-rouge">select()</code> 方法获取的、需要进行 <code class="language-plaintext highlighter-rouge">IO</code> 处理的 Channel，这个集合可以通过 <code class="language-plaintext highlighter-rouge">selectedKeys()</code> 返回。</li>
  <li>被取消的 <code class="language-plaintext highlighter-rouge">SelectionKey</code> 集合：代表了所有被取消注册关系的 <code class="language-plaintext highlighter-rouge">Channel</code>，在下一次执行 <code class="language-plaintext highlighter-rouge">select()</code> 方法时，这些 <code class="language-plaintext highlighter-rouge">Channel</code> 对应的 <code class="language-plaintext highlighter-rouge">SelectionKey</code> 会被彻底删除，程序通常无须直接访问该集合，也没有暴露访问的方法。</li>
</ol>

<p>简单演示一下如何遍历被选择的 <code class="language-plaintext highlighter-rouge">SelectionKey</code> 集合并进行处理：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Set</span><span class="o">&lt;</span><span class="nc">SelectionKey</span><span class="o">&gt;</span> <span class="n">selectedKeys</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="na">selectedKeys</span><span class="o">();</span>
<span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">SelectionKey</span><span class="o">&gt;</span> <span class="n">keyIterator</span> <span class="o">=</span> <span class="n">selectedKeys</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
<span class="k">while</span> <span class="o">(</span><span class="n">keyIterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">SelectionKey</span> <span class="n">key</span> <span class="o">=</span> <span class="n">keyIterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">isAcceptable</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// ServerSocketChannel 接收了一个新连接</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">isConnectable</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 表示一个新连接建立</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">isReadable</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Channel 有准备好的数据，可以读取</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">isWritable</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Channel 有空闲的 Buffer，可以写入数据</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">keyIterator</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Selector 还提供了一系列和 <code class="language-plaintext highlighter-rouge">select()</code> 相关的方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">int select()</code>：监控所有注册的 <code class="language-plaintext highlighter-rouge">Channel</code>，当它们中间有需要处理的 <code class="language-plaintext highlighter-rouge">IO</code> 操作时，该方法返回，并将对应的 <code class="language-plaintext highlighter-rouge">SelectionKey</code> 加入被选择的 <code class="language-plaintext highlighter-rouge">SelectionKey</code> 集合中，该方法返回这些 <code class="language-plaintext highlighter-rouge">Channel</code> 的数量。</li>
  <li><code class="language-plaintext highlighter-rouge">int select(long timeout)</code>：可以设置超时时长的 <code class="language-plaintext highlighter-rouge">select()</code> 操作。</li>
  <li><code class="language-plaintext highlighter-rouge">int selectNow()</code>：执行一个立即返回的 <code class="language-plaintext highlighter-rouge">select()</code> 操作，相对于无参数的 <code class="language-plaintext highlighter-rouge">select()</code> 方法而言，该方法不会阻塞线程。</li>
  <li><code class="language-plaintext highlighter-rouge">Selector wakeup()</code>：使一个还未返回的 <code class="language-plaintext highlighter-rouge">select()</code> 方法立刻返回。</li>
  <li>……</li>
</ul>

<p>使用 Selector 实现网络读写的简单示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.InetSocketAddress</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.ByteBuffer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.SelectionKey</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.Selector</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.ServerSocketChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.SocketChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Iterator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NioSelectorExample</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="nc">ServerSocketChannel</span> <span class="n">serverSocketChannel</span> <span class="o">=</span> <span class="nc">ServerSocketChannel</span><span class="o">.</span><span class="na">open</span><span class="o">();</span>
      <span class="n">serverSocketChannel</span><span class="o">.</span><span class="na">configureBlocking</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
      <span class="n">serverSocketChannel</span><span class="o">.</span><span class="na">socket</span><span class="o">().</span><span class="na">bind</span><span class="o">(</span><span class="k">new</span> <span class="nc">InetSocketAddress</span><span class="o">(</span><span class="mi">8080</span><span class="o">));</span>

      <span class="nc">Selector</span> <span class="n">selector</span> <span class="o">=</span> <span class="nc">Selector</span><span class="o">.</span><span class="na">open</span><span class="o">();</span>
      <span class="c1">// 将 ServerSocketChannel 注册到 Selector 并监听 OP_ACCEPT 事件</span>
      <span class="n">serverSocketChannel</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">selector</span><span class="o">,</span> <span class="nc">SelectionKey</span><span class="o">.</span><span class="na">OP_ACCEPT</span><span class="o">);</span>

      <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">readyChannels</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="na">select</span><span class="o">();</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">readyChannels</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">continue</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">SelectionKey</span><span class="o">&gt;</span> <span class="n">selectedKeys</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="na">selectedKeys</span><span class="o">();</span>
        <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">SelectionKey</span><span class="o">&gt;</span> <span class="n">keyIterator</span> <span class="o">=</span> <span class="n">selectedKeys</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">keyIterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
          <span class="nc">SelectionKey</span> <span class="n">key</span> <span class="o">=</span> <span class="n">keyIterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>

          <span class="k">if</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">isAcceptable</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 处理连接事件</span>
            <span class="nc">ServerSocketChannel</span> <span class="n">server</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ServerSocketChannel</span><span class="o">)</span> <span class="n">key</span><span class="o">.</span><span class="na">channel</span><span class="o">();</span>
            <span class="nc">SocketChannel</span> <span class="n">client</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>
            <span class="n">client</span><span class="o">.</span><span class="na">configureBlocking</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>

            <span class="c1">// 将客户端通道注册到 Selector 并监听 OP_READ 事件</span>
            <span class="n">client</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">selector</span><span class="o">,</span> <span class="nc">SelectionKey</span><span class="o">.</span><span class="na">OP_READ</span><span class="o">);</span>
          <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">isReadable</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 处理读事件</span>
            <span class="nc">SocketChannel</span> <span class="n">client</span> <span class="o">=</span> <span class="o">(</span><span class="nc">SocketChannel</span><span class="o">)</span> <span class="n">key</span><span class="o">.</span><span class="na">channel</span><span class="o">();</span>
            <span class="nc">ByteBuffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">1024</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">bytesRead</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">bytesRead</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
              <span class="n">buffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>
              <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"收到数据："</span> <span class="o">+</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">array</span><span class="o">(),</span> <span class="mi">0</span><span class="o">,</span> <span class="n">bytesRead</span><span class="o">));</span>
              <span class="c1">// 将客户端通道注册到 Selector 并监听 OP_WRITE 事件</span>
              <span class="n">client</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">selector</span><span class="o">,</span> <span class="nc">SelectionKey</span><span class="o">.</span><span class="na">OP_WRITE</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">bytesRead</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
              <span class="c1">// 客户端断开连接</span>
              <span class="n">client</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span>
          <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">isWritable</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 处理写事件</span>
            <span class="nc">SocketChannel</span> <span class="n">client</span> <span class="o">=</span> <span class="o">(</span><span class="nc">SocketChannel</span><span class="o">)</span> <span class="n">key</span><span class="o">.</span><span class="na">channel</span><span class="o">();</span>
            <span class="nc">ByteBuffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">wrap</span><span class="o">(</span><span class="s">"Hello, Client!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
            <span class="n">client</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>

            <span class="c1">// 将客户端通道注册到 Selector 并监听 OP_READ 事件</span>
            <span class="n">client</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">selector</span><span class="o">,</span> <span class="nc">SelectionKey</span><span class="o">.</span><span class="na">OP_READ</span><span class="o">);</span>
          <span class="o">}</span>

          <span class="n">keyIterator</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在示例中，我们创建了一个简单的服务器，监听 8080 端口，使用 Selector 处理连接、读取和写入事件。当接收到客户端的数据时，服务器将读取数据并将其打印到控制台，然后向客户端回复 “Hello, Client!”。</p>

<h2 id="nio-零拷贝">NIO 零拷贝</h2>

<p>零拷贝是提升 IO 操作性能的一个常用手段，像 ActiveMQ、Kafka 、RocketMQ、QMQ、Netty 等顶级开源项目都用到了零拷贝。</p>

<p>零拷贝是指计算机执行 IO 操作时，CPU 不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及 CPU 的拷贝时间。也就是说，零拷贝主要解决操作系统在处理 I/O 操作时频繁复制数据的问题。零拷贝的常见实现技术有： <code class="language-plaintext highlighter-rouge">mmap+write</code>、<code class="language-plaintext highlighter-rouge">sendfile</code>和 <code class="language-plaintext highlighter-rouge">sendfile + DMA gather copy</code> 。</p>

<p>下图展示了各种零拷贝技术的对比图：</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>CPU 拷贝</th>
      <th>DMA 拷贝</th>
      <th>系统调用</th>
      <th>上下文切换</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>传统方法</td>
      <td>2</td>
      <td>2</td>
      <td>read+write</td>
      <td>4</td>
    </tr>
    <tr>
      <td>mmap+write</td>
      <td>1</td>
      <td>2</td>
      <td>mmap+write</td>
      <td>4</td>
    </tr>
    <tr>
      <td>sendfile</td>
      <td>1</td>
      <td>2</td>
      <td>sendfile</td>
      <td>2</td>
    </tr>
    <tr>
      <td>sendfile + DMA gather copy</td>
      <td>0</td>
      <td>2</td>
      <td>sendfile</td>
      <td>2</td>
    </tr>
  </tbody>
</table>

<p>可以看出，无论是传统的 I/O 方式，还是引入了零拷贝之后，2 次 DMA(Direct Memory Access) 拷贝是都少不了的。因为两次 DMA 都是依赖硬件完成的。零拷贝主要是减少了 CPU 拷贝及上下文的切换。</p>

<p>Java 对零拷贝的支持：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">MappedByteBuffer</code> 是 NIO 基于内存映射（<code class="language-plaintext highlighter-rouge">mmap</code>）这种零拷⻉⽅式的提供的⼀种实现，底层实际是调用了 Linux 内核的 <code class="language-plaintext highlighter-rouge">mmap</code> 系统调用。它可以将一个文件或者文件的一部分映射到内存中，形成一个虚拟内存文件，这样就可以直接操作内存中的数据，而不需要通过系统调用来读写文件。</li>
  <li><code class="language-plaintext highlighter-rouge">FileChannel</code> 的<code class="language-plaintext highlighter-rouge">transferTo()/transferFrom()</code>是 NIO 基于发送文件（<code class="language-plaintext highlighter-rouge">sendfile</code>）这种零拷贝方式的提供的一种实现，底层实际是调用了 Linux 内核的 <code class="language-plaintext highlighter-rouge">sendfile</code>系统调用。它可以直接将文件数据从磁盘发送到网络，而不需要经过用户空间的缓冲区。关于<code class="language-plaintext highlighter-rouge">FileChannel</code>的用法可以看看这篇文章：<a href="https://www.cnblogs.com/robothy/p/14235598.html">Java NIO 文件通道 FileChannel 用法</a>。</li>
</ul>

<p>代码示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">loadFileIntoMemory</span><span class="o">(</span><span class="nc">File</span> <span class="n">xmlFile</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
  <span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">xmlFile</span><span class="o">);</span>
  <span class="c1">// 创建 FileChannel 对象</span>
  <span class="nc">FileChannel</span> <span class="n">fc</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">getChannel</span><span class="o">();</span>
  <span class="c1">// FileChannel.map() 将文件映射到直接内存并返回 MappedByteBuffer 对象</span>
  <span class="nc">MappedByteBuffer</span> <span class="n">mmb</span> <span class="o">=</span> <span class="n">fc</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nc">FileChannel</span><span class="o">.</span><span class="na">MapMode</span><span class="o">.</span><span class="na">READ_ONLY</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">fc</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
  <span class="n">xmlFileBuffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[(</span><span class="kt">int</span><span class="o">)</span><span class="n">fc</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
  <span class="n">mmb</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">xmlFileBuffer</span><span class="o">);</span>
  <span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="总结">总结</h2>

<p>这篇文章我们主要介绍了 NIO 的核心知识点，包括 NIO 的核心组件和零拷贝。</p>

<p>如果我们需要使用 NIO 构建网络程序的话，不建议直接使用原生 NIO，编程复杂且功能性太弱，推荐使用一些成熟的基于 NIO 的网络编程框架比如 Netty。Netty 在 NIO 的基础上进行了一些优化和扩展比如支持多种协议、支持 SSL/TLS 等等。</p>

<h2 id="参考">参考</h2>

<ul>
  <li>
    <p>Java NIO 浅析：<a href="https://tech.meituan.com/2016/11/04/nio.html">https://tech.meituan.com/2016/11/04/nio.html</a></p>
  </li>
  <li>
    <p>面试官：Java NIO 了解？<a href="https://mp.weixin.qq.com/s/mZobf-U8OSYQfHfYBEB6KA">https://mp.weixin.qq.com/s/mZobf-U8OSYQfHfYBEB6KA</a></p>
  </li>
  <li>
    <p>Java NIO：Buffer、Channel 和 Selector：<a href="https://www.javadoop.com/post/java-nio">https://www.javadoop.com/post/java-nio</a></p>
  </li>
</ul>

<!-- @include: @article-footer.snippet.md -->
