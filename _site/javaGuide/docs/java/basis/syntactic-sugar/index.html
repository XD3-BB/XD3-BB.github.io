<blockquote>
  <p>作者：Hollis</p>

  <p>原文：<a href="https://mp.weixin.qq.com/s/o4XdEMq1DL-nBS-f8Za5Aw">https://mp.weixin.qq.com/s/o4XdEMq1DL-nBS-f8Za5Aw</a></p>
</blockquote>

<p>语法糖是大厂 Java 面试常问的一个知识点。</p>

<p>本文从 Java 编译原理角度，深入字节码及 class 文件，抽丝剥茧，了解 Java 中的语法糖原理及用法，帮助大家在学会如何使用 Java 语法糖的同时，了解这些语法糖背后的原理。</p>

<h2 id="什么是语法糖">什么是语法糖？</h2>

<p><strong>语法糖（Syntactic Sugar）</strong> 也称糖衣语法，是英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/syntactic-sugar/image-20220818175953954.png" alt="" /></p>

<blockquote>
  <p>有意思的是，在编程领域，除了语法糖，还有语法盐和语法糖精的说法，篇幅有限这里不做扩展了。</p>
</blockquote>

<p>我们所熟知的编程语言中几乎都有语法糖。作者认为，语法糖的多少是评判一个语言够不够牛逼的标准之一。很多人说 Java 是一个“低糖语言”，其实从 Java 7 开始 Java 语言层面上一直在添加各种糖，主要是在“Project Coin”项目下研发。尽管现在 Java 有人还是认为现在的 Java 是低糖，未来还会持续向着“高糖”的方向发展。</p>

<h2 id="java-中有哪些常见的语法糖">Java 中有哪些常见的语法糖？</h2>

<p>前面提到过，语法糖的存在主要是方便开发人员使用。但其实， <strong>Java 虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。</strong></p>

<p>说到编译，大家肯定都知道，Java 语言中，<code class="language-plaintext highlighter-rouge">javac</code>命令可以将后缀名为<code class="language-plaintext highlighter-rouge">.java</code>的源文件编译为后缀名为<code class="language-plaintext highlighter-rouge">.class</code>的可以运行于 Java 虚拟机的字节码。如果你去看<code class="language-plaintext highlighter-rouge">com.sun.tools.javac.main.JavaCompiler</code>的源码，你会发现在<code class="language-plaintext highlighter-rouge">compile()</code>中有一个步骤就是调用<code class="language-plaintext highlighter-rouge">desugar()</code>，这个方法就是负责解语法糖的实现的。</p>

<p>Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。本文主要来分析下这些语法糖背后的原理。一步一步剥去糖衣，看看其本质。</p>

<p>我们这里会用到<a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650120609&amp;idx=1&amp;sn=5659f96310963ad57d55b48cee63c788&amp;chksm=f36bbc80c41c3596a1e4bf9501c6280481f1b9e06d07af354474e6f3ed366fef016df673a7ba&amp;scene=21#wechat_redirect">反编译</a>，你可以通过 <a href="http://www.javadecompilers.com/">Decompilers online</a> 对 Class 文件进行在线反编译。</p>

<h3 id="switch-支持-string-与枚举">switch 支持 String 与枚举</h3>

<p>前面提到过，从 Java 7 开始，Java 语言中的语法糖在逐渐丰富，其中一个比较重要的就是 Java 7 中<code class="language-plaintext highlighter-rouge">switch</code>开始支持<code class="language-plaintext highlighter-rouge">String</code>。</p>

<p>在开始之前先科普下，Java 中的<code class="language-plaintext highlighter-rouge">switch</code>自身原本就支持基本类型。比如<code class="language-plaintext highlighter-rouge">int</code>、<code class="language-plaintext highlighter-rouge">char</code>等。对于<code class="language-plaintext highlighter-rouge">int</code>类型，直接进行数值的比较。对于<code class="language-plaintext highlighter-rouge">char</code>类型则是比较其 ascii 码。所以，对于编译器来说，<code class="language-plaintext highlighter-rouge">switch</code>中其实只能使用整型，任何类型的比较都要转换成整型。比如<code class="language-plaintext highlighter-rouge">byte</code>。<code class="language-plaintext highlighter-rouge">short</code>，<code class="language-plaintext highlighter-rouge">char</code>(ascii 码是整型)以及<code class="language-plaintext highlighter-rouge">int</code>。</p>

<p>那么接下来看下<code class="language-plaintext highlighter-rouge">switch</code>对<code class="language-plaintext highlighter-rouge">String</code>的支持，有以下代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">switchDemoString</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"world"</span><span class="o">;</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">str</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="s">"hello"</span><span class="o">:</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="s">"world"</span><span class="o">:</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"world"</span><span class="o">);</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>反编译后内容如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">switchDemoString</span>
<span class="o">{</span>
    <span class="kd">public</span> <span class="nf">switchDemoString</span><span class="o">()</span>
    <span class="o">{</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span>
    <span class="o">{</span>
        <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"world"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">s</span><span class="o">;</span>
        <span class="k">switch</span><span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">str</span><span class="o">).</span><span class="na">hashCode</span><span class="o">())</span>
        <span class="o">{</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="mi">99162322</span><span class="o">:</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"hello"</span><span class="o">))</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="mi">113318802</span><span class="o">:</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"world"</span><span class="o">))</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"world"</span><span class="o">);</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>看到这个代码，你知道原来 <strong>字符串的 switch 是通过<code class="language-plaintext highlighter-rouge">equals()</code>和<code class="language-plaintext highlighter-rouge">hashCode()</code>方法来实现的。</strong> 还好<code class="language-plaintext highlighter-rouge">hashCode()</code>方法返回的是<code class="language-plaintext highlighter-rouge">int</code>，而不是<code class="language-plaintext highlighter-rouge">long</code>。</p>

<p>仔细看下可以发现，进行<code class="language-plaintext highlighter-rouge">switch</code>的实际是哈希值，然后通过使用<code class="language-plaintext highlighter-rouge">equals</code>方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行 <code class="language-plaintext highlighter-rouge">switch</code> 或者使用纯整数常量，但这也不是很差。</p>

<h3 id="泛型">泛型</h3>

<p>我们都知道，很多语言都是支持泛型的，但是很多人不知道的是，不同的编译器对于泛型的处理方式是不同的，通常情况下，一个编译器处理泛型有两种方式：<code class="language-plaintext highlighter-rouge">Code specialization</code>和<code class="language-plaintext highlighter-rouge">Code sharing</code>。C++和 C#是使用<code class="language-plaintext highlighter-rouge">Code specialization</code>的处理机制，而 Java 使用的是<code class="language-plaintext highlighter-rouge">Code sharing</code>的机制。</p>

<blockquote>
  <p>Code sharing 方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（<code class="language-plaintext highlighter-rouge">type erasue</code>）实现的。</p>
</blockquote>

<p>也就是说，<strong>对于 Java 虚拟机来说，他根本不认识<code class="language-plaintext highlighter-rouge">Map&lt;String, String&gt; map</code>这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。</strong></p>

<p>类型擦除的主要过程如下：1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。 2.移除所有的类型参数。</p>

<p>以下代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;();</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="s">"hollis"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"wechat"</span><span class="o">,</span> <span class="s">"Hollis"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"blog"</span><span class="o">,</span> <span class="s">"www.hollischuang.com"</span><span class="o">);</span>
</code></pre></div></div>

<p>解语法糖之后会变成：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">();</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="s">"hollis"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"wechat"</span><span class="o">,</span> <span class="s">"Hollis"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"blog"</span><span class="o">,</span> <span class="s">"www.hollischuang.com"</span><span class="o">);</span>
</code></pre></div></div>

<p>以下代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">A</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">A</span><span class="o">&gt;&gt;</span> <span class="no">A</span> <span class="nf">max</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;</span><span class="no">A</span><span class="o">&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">A</span><span class="o">&gt;</span> <span class="n">xi</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
    <span class="no">A</span> <span class="n">w</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">xi</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
        <span class="no">A</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">w</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>类型擦除后会变成：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Comparable</span> <span class="nf">max</span><span class="o">(</span><span class="nc">Collection</span> <span class="n">xs</span><span class="o">){</span>
    <span class="nc">Iterator</span> <span class="n">xi</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
    <span class="nc">Comparable</span> <span class="n">w</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Comparable</span><span class="o">)</span><span class="n">xi</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="k">while</span><span class="o">(</span><span class="n">xi</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span>
    <span class="o">{</span>
        <span class="nc">Comparable</span> <span class="n">x</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Comparable</span><span class="o">)</span><span class="n">xi</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">w</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的<code class="language-plaintext highlighter-rouge">Class</code>类对象。比如并不存在<code class="language-plaintext highlighter-rouge">List&lt;String&gt;.class</code>或是<code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;.class</code>，而只有<code class="language-plaintext highlighter-rouge">List.class</code>。</strong></p>

<h3 id="自动装箱与拆箱">自动装箱与拆箱</h3>

<p>自动装箱就是 Java 自动将原始类型值转换成对应的对象，比如将 int 的变量转换成 Integer 对象，这个过程叫做装箱，反之将 Integer 对象转换成 int 类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类型 byte, short, char, int, long, float, double 和 boolean 对应的封装类为 Byte, Short, Character, Integer, Long, Float, Double, Boolean。</p>

<p>先来看个自动装箱的代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
    <span class="nc">Integer</span> <span class="n">n</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>反编译后代码如下:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span>
<span class="o">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
    <span class="nc">Integer</span> <span class="n">n</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>再来看个自动拆箱的代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

    <span class="nc">Integer</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>反编译后代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span>
<span class="o">{</span>
    <span class="nc">Integer</span> <span class="n">i</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="na">intValue</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>从反编译得到内容可以看出，在装箱的时候自动调用的是<code class="language-plaintext highlighter-rouge">Integer</code>的<code class="language-plaintext highlighter-rouge">valueOf(int)</code>方法。而在拆箱的时候自动调用的是<code class="language-plaintext highlighter-rouge">Integer</code>的<code class="language-plaintext highlighter-rouge">intValue</code>方法。</p>

<p>所以，<strong>装箱过程是通过调用包装器的 valueOf 方法实现的，而拆箱过程是通过调用包装器的 xxxValue 方法实现的。</strong></p>

<h3 id="可变长参数">可变长参数</h3>

<p>可变参数(<code class="language-plaintext highlighter-rouge">variable arguments</code>)是在 Java 1.5 中引入的一个特性。它允许一个方法把任意数量的值作为参数。</p>

<p>看下以下可变参数代码，其中 <code class="language-plaintext highlighter-rouge">print</code> 方法接收可变参数：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"Holis"</span><span class="o">,</span> <span class="s">"公众号:Hollis"</span><span class="o">,</span> <span class="s">"博客：www.hollischuang.com"</span><span class="o">,</span> <span class="s">"QQ：907607222"</span><span class="o">);</span>
    <span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span><span class="o">...</span> <span class="n">strs</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>反编译后代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span>
<span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">[]</span> <span class="o">{</span>
        <span class="s">"Holis"</span><span class="o">,</span> <span class="s">"\u516C\u4F17\u53F7:Hollis"</span><span class="o">,</span> <span class="s">"\u535A\u5BA2\uFF1Awww.hollischuang.com"</span><span class="o">,</span> <span class="s">"QQ\uFF1A907607222"</span>
    <span class="o">});</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">transient</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">strs</span><span class="o">[])</span>
<span class="o">{</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

<span class="o">}</span>
</code></pre></div></div>

<p>从反编译后代码可以看出，可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。（注：<code class="language-plaintext highlighter-rouge">trasient</code> 仅在修饰成员变量时有意义，此处 “修饰方法” 是由于在 javassist 中使用相同数值分别表示 <code class="language-plaintext highlighter-rouge">trasient</code> 以及 <code class="language-plaintext highlighter-rouge">vararg</code>，见 <a href="https://github.com/jboss-javassist/javassist/blob/7302b8b0a09f04d344a26ebe57f29f3db43f2a3e/src/main/javassist/bytecode/AccessFlag.java#L32">此处</a>。）</p>

<h3 id="枚举">枚举</h3>

<p>Java SE5 提供了一种新的类型-Java 的枚举类型，关键字<code class="language-plaintext highlighter-rouge">enum</code>可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。</p>

<p>要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是<code class="language-plaintext highlighter-rouge">enum</code>吗？答案很明显不是，<code class="language-plaintext highlighter-rouge">enum</code>就和<code class="language-plaintext highlighter-rouge">class</code>一样，只是一个关键字，他并不是一个类，那么枚举是由什么类维护的呢，我们简单的写一个枚举：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="n">t</span> <span class="o">{</span>
    <span class="no">SPRING</span><span class="o">,</span><span class="no">SUMMER</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>然后我们使用反编译，看看这段代码到底是怎么实现的，反编译后代码内容如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">T</span> <span class="kd">extends</span> <span class="nc">Enum</span>
<span class="o">{</span>
    <span class="kd">private</span> <span class="nf">T</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">values</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="no">T</span> <span class="n">at</span><span class="o">[];</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">;</span>
        <span class="no">T</span> <span class="n">at1</span><span class="o">[];</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">at</span> <span class="o">=</span> <span class="no">ENUM</span><span class="n">$VALUES</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">at1</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="n">at</span><span class="o">.</span><span class="na">length</span><span class="o">],</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">at1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="no">T</span> <span class="nf">valueOf</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span><span class="nc">Enum</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">demo</span><span class="o">/</span><span class="no">T</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="no">T</span> <span class="no">SPRING</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="no">T</span> <span class="no">SUMMER</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="no">T</span> <span class="no">ENUM</span><span class="n">$VALUES</span><span class="o">[];</span>
    <span class="kd">static</span>
    <span class="o">{</span>
        <span class="no">SPRING</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">(</span><span class="s">"SPRING"</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="no">SUMMER</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">(</span><span class="s">"SUMMER"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="no">ENUM</span><span class="n">$VALUES</span> <span class="o">=</span> <span class="o">(</span><span class="k">new</span> <span class="no">T</span><span class="o">[]</span> <span class="o">{</span>
            <span class="no">SPRING</span><span class="o">,</span> <span class="no">SUMMER</span>
        <span class="o">});</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>通过反编译后代码我们可以看到，<code class="language-plaintext highlighter-rouge">public final class T extends Enum</code>，说明，该类是继承了<code class="language-plaintext highlighter-rouge">Enum</code>类的，同时<code class="language-plaintext highlighter-rouge">final</code>关键字告诉我们，这个类也是不能被继承的。</p>

<p><strong>当我们使用<code class="language-plaintext highlighter-rouge">enum</code>来定义一个枚举类型的时候，编译器会自动帮我们创建一个<code class="language-plaintext highlighter-rouge">final</code>类型的类继承<code class="language-plaintext highlighter-rouge">Enum</code>类，所以枚举类型不能被继承。</strong></p>

<h3 id="内部类">内部类</h3>

<p>内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。</p>

<p><strong>内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念，<code class="language-plaintext highlighter-rouge">outer.java</code>里面定义了一个内部类<code class="language-plaintext highlighter-rouge">inner</code>，一旦编译成功，就会生成两个完全不同的<code class="language-plaintext highlighter-rouge">.class</code>文件了，分别是<code class="language-plaintext highlighter-rouge">outer.class</code>和<code class="language-plaintext highlighter-rouge">outer$inner.class</code>。所以内部类的名字完全可以和它的外部类名字相同。</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OutterClass</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">userName</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getUserName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">userName</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUserName</span><span class="o">(</span><span class="nc">String</span> <span class="n">userName</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">userName</span> <span class="o">=</span> <span class="n">userName</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

    <span class="o">}</span>

    <span class="kd">class</span> <span class="nc">InnerClass</span><span class="o">{</span>
        <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>以上代码编译后会生成两个 class 文件：<code class="language-plaintext highlighter-rouge">OutterClass$InnerClass.class</code>、<code class="language-plaintext highlighter-rouge">OutterClass.class</code> 。当我们尝试对<code class="language-plaintext highlighter-rouge">OutterClass.class</code>文件进行反编译的时候，命令行会打印以下内容：<code class="language-plaintext highlighter-rouge">Parsing OutterClass.class...Parsing inner class OutterClass$InnerClass.class... Generating OutterClass.jad</code> 。他会把两个文件全部进行反编译，然后一起生成一个<code class="language-plaintext highlighter-rouge">OutterClass.jad</code>文件。文件内容如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OutterClass</span>
<span class="o">{</span>
    <span class="kd">class</span> <span class="nc">InnerClass</span>
    <span class="o">{</span>
        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span>
        <span class="o">{</span>
            <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
        <span class="kd">final</span> <span class="nc">OutterClass</span> <span class="k">this</span><span class="err">$</span><span class="mi">0</span><span class="o">;</span>

        <span class="nc">InnerClass</span><span class="o">()</span>
        <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">this</span><span class="err">$</span><span class="mi">0</span> <span class="o">=</span> <span class="nc">OutterClass</span><span class="o">.</span><span class="na">this</span><span class="o">;</span>
            <span class="kd">super</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">OutterClass</span><span class="o">()</span>
    <span class="o">{</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getUserName</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="k">return</span> <span class="n">userName</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUserName</span><span class="o">(</span><span class="nc">String</span> <span class="n">userName</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">userName</span> <span class="o">=</span> <span class="n">userName</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args1</span><span class="o">[])</span>
    <span class="o">{</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">userName</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>为什么内部类可以使用外部类的 private 属性</strong>：</p>

<p>我们在 InnerClass 中增加一个方法，打印外部类的 userName 属性</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//省略其他属性</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OutterClass</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">userName</span><span class="o">;</span>
    <span class="o">......</span>
    <span class="kd">class</span> <span class="nc">InnerClass</span><span class="o">{</span>
    <span class="o">......</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printOut</span><span class="o">(){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Username from OutterClass:"</span><span class="o">+</span><span class="n">userName</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 此时，使用javap -p命令对OutterClass反编译结果：</span>
<span class="kd">public</span> <span class="n">classOutterClass</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">userName</span><span class="o">;</span>
    <span class="o">......</span>
    <span class="kd">static</span> <span class="nc">String</span> <span class="n">access</span><span class="err">$</span><span class="mo">000</span><span class="o">(</span><span class="nc">OutterClass</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 此时，InnerClass的反编译结果：</span>
<span class="kd">class</span> <span class="nc">OutterClass</span><span class="n">$InnerClass</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="nc">OutterClass</span> <span class="k">this</span><span class="err">$</span><span class="mi">0</span><span class="o">;</span>
    <span class="o">......</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printOut</span><span class="o">();</span>
<span class="o">}</span>

</code></pre></div></div>

<p>实际上，在编译完成之后，inner 实例内部会有指向 outer 实例的引用<code class="language-plaintext highlighter-rouge">this$0</code>，但是简单的<code class="language-plaintext highlighter-rouge">outer.name</code>是无法访问 private 属性的。从反编译的结果可以看到，outer 中会有一个桥方法<code class="language-plaintext highlighter-rouge">static String access$000(OutterClass)</code>，恰好返回 String 类型，即 userName 属性。正是通过这个方法实现内部类访问外部类私有属性。所以反编译后的<code class="language-plaintext highlighter-rouge">printOut()</code>方法大致如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">printOut</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Username from OutterClass:"</span> <span class="o">+</span> <span class="nc">OutterClass</span><span class="o">.</span><span class="na">access</span><span class="err">$</span><span class="mo">000</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">this</span><span class="err">$</span><span class="mi">0</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<p>补充：</p>

<ol>
  <li>匿名内部类、局部内部类、静态内部类也是通过桥方法来获取 private 属性。</li>
  <li>静态内部类没有<code class="language-plaintext highlighter-rouge">this$0</code>的引用</li>
  <li>匿名内部类、局部内部类通过复制使用局部变量，该变量初始化之后就不能被修改。以下是一个案例：</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OutterClass</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">userName</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(){</span>
        <span class="c1">//这里i初始化为1后就不能再被修改</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>
        <span class="kd">class</span> <span class="nc">Inner</span><span class="o">{</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printName</span><span class="o">(){</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">userName</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>反编译后：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//javap命令反编译Inner的结果</span>
<span class="c1">//i被复制进内部类，且为final</span>
<span class="kd">class</span> <span class="nc">OutterClass</span><span class="err">$</span><span class="mi">1</span><span class="nc">Inner</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">val$i</span><span class="o">;</span>
  <span class="kd">final</span> <span class="nc">OutterClass</span> <span class="k">this</span><span class="err">$</span><span class="mi">0</span><span class="o">;</span>
  <span class="nc">OutterClass</span><span class="err">$</span><span class="mi">1</span><span class="nc">Inner</span><span class="o">();</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printName</span><span class="o">();</span>
<span class="o">}</span>

</code></pre></div></div>

<h3 id="条件编译">条件编译</h3>

<p>—般情况下，程序中的每一行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。</p>

<p>如在 C 或 CPP 中，可以通过预处理语句来实现条件编译。其实在 Java 中也可实现条件编译。我们先来看一段代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConditionalCompilation</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="kt">boolean</span> <span class="no">DEBUG</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="no">DEBUG</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, DEBUG!"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">final</span> <span class="kt">boolean</span> <span class="no">ONLINE</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

        <span class="k">if</span><span class="o">(</span><span class="no">ONLINE</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, ONLINE!"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>反编译后代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConditionalCompilation</span>
<span class="o">{</span>

    <span class="kd">public</span> <span class="nf">ConditionalCompilation</span><span class="o">()</span>
    <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span>
    <span class="o">{</span>
        <span class="kt">boolean</span> <span class="no">DEBUG</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, DEBUG!"</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="no">ONLINE</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>首先，我们发现，在反编译后的代码中没有<code class="language-plaintext highlighter-rouge">System.out.println("Hello, ONLINE!");</code>，这其实就是条件编译。当<code class="language-plaintext highlighter-rouge">if(ONLINE)</code>为 false 的时候，编译器就没有对其内的代码进行编译。</p>

<p>所以，<strong>Java 语法的条件编译，是通过判断条件为常量的 if 语句实现的。其原理也是 Java 语言的语法糖。根据 if 判断条件的真假，编译器直接把分支为 false 的代码块消除。通过该方式实现的条件编译，必须在方法体内实现，而无法在整个 Java 类的结构或者类的属性上进行条件编译，这与 C/C++的条件编译相比，确实更有局限性。在 Java 语言设计之初并没有引入条件编译的功能，虽有局限，但是总比没有更强。</strong></p>

<h3 id="断言">断言</h3>

<p>在 Java 中，<code class="language-plaintext highlighter-rouge">assert</code>关键字是从 JAVA SE 1.4 引入的，为了避免和老版本的 Java 代码中使用了<code class="language-plaintext highlighter-rouge">assert</code>关键字导致错误，Java 在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！），如果要开启断言检查，则需要用开关<code class="language-plaintext highlighter-rouge">-enableassertions</code>或<code class="language-plaintext highlighter-rouge">-ea</code>来开启。</p>

<p>看一段包含断言的代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AssertTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">assert</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"公众号：Hollis"</span><span class="o">);</span>
        <span class="k">assert</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span> <span class="o">:</span> <span class="s">"Hollis"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"博客：www.hollischuang.com"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>反编译后代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AssertTest</span> <span class="o">{</span>
   <span class="kd">public</span> <span class="nf">AssertTest</span><span class="o">()</span>
    <span class="o">{</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span>
<span class="o">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">$assertionsDisabled</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">AssertionError</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\u516C\u4F17\u53F7\uFF1AHollis"</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">$assertionsDisabled</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">AssertionError</span><span class="o">(</span><span class="s">"Hollis"</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span>
    <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\u535A\u5BA2\uFF1Awww.hollischuang.com"</span><span class="o">);</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">$assertionsDisabled</span> <span class="o">=</span> <span class="o">!</span><span class="n">com</span><span class="o">/</span><span class="n">hollis</span><span class="o">/</span><span class="n">suguar</span><span class="o">/</span><span class="nc">AssertTest</span><span class="o">.</span><span class="na">desiredAssertionStatus</span><span class="o">();</span>

<span class="o">}</span>
</code></pre></div></div>

<p>很明显，反编译之后的代码要比我们自己的代码复杂的多。所以，使用了 assert 这个语法糖我们节省了很多代码。<strong>其实断言的底层实现就是 if 语言，如果断言结果为 true，则什么都不做，程序继续执行，如果断言结果为 false，则程序抛出 AssertError 来打断程序的执行。</strong><code class="language-plaintext highlighter-rouge">-enableassertions</code>会设置$assertionsDisabled 字段的值。</p>

<h3 id="数值字面量">数值字面量</h3>

<p>在 java 7 中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。</p>

<p>比如：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10_000</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>反编译后：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span>
<span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
  <span class="o">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10000</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>反编译后就是把<code class="language-plaintext highlighter-rouge">_</code>删除了。也就是说 <strong>编译器并不认识在数字字面量中的<code class="language-plaintext highlighter-rouge">_</code>，需要在编译阶段把他去掉。</strong></p>

<h3 id="for-each">for-each</h3>

<p>增强 for 循环（<code class="language-plaintext highlighter-rouge">for-each</code>）相信大家都不陌生，日常开发经常会用到的，他会比 for 循环要少写很多代码，那么这个语法糖背后是如何实现的呢？</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">strs</span> <span class="o">=</span> <span class="o">{</span><span class="s">"Hollis"</span><span class="o">,</span> <span class="s">"公众号：Hollis"</span><span class="o">,</span> <span class="s">"博客：www.hollischuang.com"</span><span class="o">};</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">strs</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">strList</span> <span class="o">=</span> <span class="nc">ImmutableList</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Hollis"</span><span class="o">,</span> <span class="s">"公众号：Hollis"</span><span class="o">,</span> <span class="s">"博客：www.hollischuang.com"</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">strList</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>反编译后代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kd">transient</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span>
<span class="o">{</span>
    <span class="nc">String</span> <span class="n">strs</span><span class="o">[]</span> <span class="o">=</span> <span class="o">{</span>
        <span class="s">"Hollis"</span><span class="o">,</span> <span class="s">"\u516C\u4F17\u53F7\uFF1AHollis"</span><span class="o">,</span> <span class="s">"\u535A\u5BA2\uFF1Awww.hollischuang.com"</span>
    <span class="o">};</span>
    <span class="nc">String</span> <span class="n">args1</span><span class="o">[]</span> <span class="o">=</span> <span class="n">strs</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">args1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
    <span class="o">{</span>
        <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">args1</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nc">List</span> <span class="n">strList</span> <span class="o">=</span> <span class="nc">ImmutableList</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Hollis"</span><span class="o">,</span> <span class="s">"\u516C\u4F17\u53F7\uFF1AHollis"</span><span class="o">,</span> <span class="s">"\u535A\u5BA2\uFF1Awww.hollischuang.com"</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">s</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="nc">Iterator</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">strList</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span> <span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
        <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span><span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>

<span class="o">}</span>
</code></pre></div></div>

<p>代码很简单，<strong>for-each 的实现原理其实就是使用了普通的 for 循环和迭代器。</strong></p>

<h3 id="try-with-resource">try-with-resource</h3>

<p>Java 里，对于文件操作 IO 流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过 close 方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。</p>

<p>关闭资源的常用方式就是在<code class="language-plaintext highlighter-rouge">finally</code>块里是释放，即调用<code class="language-plaintext highlighter-rouge">close</code>方法。比如，我们经常会写这样的代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">line</span><span class="o">;</span>
        <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"d:\\hollischuang.xml"</span><span class="o">));</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">line</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// handle exception</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">br</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// handle exception</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>从 Java 7 开始，jdk 提供了一种更好的方式关闭资源，使用<code class="language-plaintext highlighter-rouge">try-with-resources</code>语句，改写一下上面的代码，效果如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"d:\\ hollischuang.xml"</span><span class="o">)))</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">line</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">line</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// handle exception</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>看，这简直是一大福音啊，虽然我之前一般使用<code class="language-plaintext highlighter-rouge">IOUtils</code>去关闭流，并不会使用在<code class="language-plaintext highlighter-rouge">finally</code>中写很多代码的方式，但是这种新的语法糖看上去好像优雅很多呢。看下他的背后：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kd">transient</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span>
    <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span><span class="o">;</span>
        <span class="nc">Throwable</span> <span class="n">throwable</span><span class="o">;</span>
        <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"d:\\ hollischuang.xml"</span><span class="o">));</span>
        <span class="n">throwable</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">line</span><span class="o">;</span>
        <span class="k">try</span>
        <span class="o">{</span>
            <span class="k">while</span><span class="o">((</span><span class="n">line</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">catch</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">throwable2</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="n">throwable</span> <span class="o">=</span> <span class="n">throwable2</span><span class="o">;</span>
            <span class="k">throw</span> <span class="n">throwable2</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">br</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">if</span><span class="o">(</span><span class="n">throwable</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">try</span>
                <span class="o">{</span>
                    <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="k">catch</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">throwable1</span><span class="o">)</span>
                <span class="o">{</span>
                    <span class="n">throwable</span><span class="o">.</span><span class="na">addSuppressed</span><span class="o">(</span><span class="n">throwable1</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="k">else</span>
                <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="k">break</span> <span class="no">MISSING_BLOCK_LABEL_113</span><span class="o">;</span>
            <span class="nc">Exception</span> <span class="n">exception</span><span class="o">;</span>
            <span class="n">exception</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">br</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">if</span><span class="o">(</span><span class="n">throwable</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="k">try</span>
                    <span class="o">{</span>
                        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                    <span class="o">}</span>
                    <span class="k">catch</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">throwable3</span><span class="o">)</span>
                      <span class="o">{</span>
                        <span class="n">throwable</span><span class="o">.</span><span class="na">addSuppressed</span><span class="o">(</span><span class="n">throwable3</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="k">else</span>
                    <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="k">throw</span> <span class="n">exception</span><span class="o">;</span>
        <span class="nc">IOException</span> <span class="n">ioexception</span><span class="o">;</span>
        <span class="n">ioexception</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。所以，再次印证了，语法糖的作用就是方便程序员的使用，但最终还是要转成编译器认识的语言。</strong></p>

<h3 id="lambda-表达式">Lambda 表达式</h3>

<p>关于 lambda 表达式，有人可能会有质疑，因为网上有人说他并不是语法糖。其实我想纠正下这个说法。<strong>Lambda 表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个 JVM 底层提供的 lambda 相关 api。</strong></p>

<p>先来看一个简单的 lambda 表达式。遍历一个 list：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">strList</span> <span class="o">=</span> <span class="nc">ImmutableList</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Hollis"</span><span class="o">,</span> <span class="s">"公众号：Hollis"</span><span class="o">,</span> <span class="s">"博客：www.hollischuang.com"</span><span class="o">);</span>

    <span class="n">strList</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span> <span class="o">}</span> <span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>为啥说他并不是内部类的语法糖呢，前面讲内部类我们说过，内部类在编译之后会有两个 class 文件，但是，包含 lambda 表达式的类编译后只有一个文件。</p>

<p>反编译后代码如下:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="cm">/* varargs */</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ImmutableList</span> <span class="n">strList</span> <span class="o">=</span> <span class="nc">ImmutableList</span><span class="o">.</span><span class="na">of</span><span class="o">((</span><span class="nc">Object</span><span class="o">)</span><span class="s">"Hollis"</span><span class="o">,</span> <span class="o">(</span><span class="nc">Object</span><span class="o">)</span><span class="s">"\u516c\u4f17\u53f7\uff1aHollis"</span><span class="o">,</span> <span class="o">(</span><span class="nc">Object</span><span class="o">)</span><span class="s">"\u535a\u5ba2\uff1awww.hollischuang.com"</span><span class="o">);</span>
    <span class="n">strList</span><span class="o">.</span><span class="na">forEach</span><span class="o">((</span><span class="nc">Consumer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;)</span><span class="nc">LambdaMetafactory</span><span class="o">.</span><span class="na">metafactory</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="o">(</span><span class="nc">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="nc">Object</span><span class="o">;)</span><span class="no">V</span><span class="o">,</span> <span class="n">lambda$main</span><span class="err">$</span><span class="mi">0</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="o">),</span> <span class="o">(</span><span class="nc">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="nc">String</span><span class="o">;)</span><span class="no">V</span><span class="o">)());</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="cm">/* synthetic */</span> <span class="kt">void</span> <span class="n">lambda$main</span><span class="err">$</span><span class="mi">0</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>可以看到，在<code class="language-plaintext highlighter-rouge">forEach</code>方法中，其实是调用了<code class="language-plaintext highlighter-rouge">java.lang.invoke.LambdaMetafactory#metafactory</code>方法，该方法的第四个参数 <code class="language-plaintext highlighter-rouge">implMethod</code> 指定了方法实现。可以看到这里其实是调用了一个<code class="language-plaintext highlighter-rouge">lambda$main$0</code>方法进行了输出。</p>

<p>再来看一个稍微复杂一点的，先对 List 进行过滤，然后再输出：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">strList</span> <span class="o">=</span> <span class="nc">ImmutableList</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Hollis"</span><span class="o">,</span> <span class="s">"公众号：Hollis"</span><span class="o">,</span> <span class="s">"博客：www.hollischuang.com"</span><span class="o">);</span>

    <span class="nc">List</span> <span class="nc">HollisList</span> <span class="o">=</span> <span class="n">strList</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">string</span> <span class="o">-&gt;</span> <span class="n">string</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"Hollis"</span><span class="o">)).</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>

    <span class="nc">HollisList</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span> <span class="o">}</span> <span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>反编译后代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="cm">/* varargs */</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ImmutableList</span> <span class="n">strList</span> <span class="o">=</span> <span class="nc">ImmutableList</span><span class="o">.</span><span class="na">of</span><span class="o">((</span><span class="nc">Object</span><span class="o">)</span><span class="s">"Hollis"</span><span class="o">,</span> <span class="o">(</span><span class="nc">Object</span><span class="o">)</span><span class="s">"\u516c\u4f17\u53f7\uff1aHollis"</span><span class="o">,</span> <span class="o">(</span><span class="nc">Object</span><span class="o">)</span><span class="s">"\u535a\u5ba2\uff1awww.hollischuang.com"</span><span class="o">);</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="nc">HollisList</span> <span class="o">=</span> <span class="n">strList</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">filter</span><span class="o">((</span><span class="nc">Predicate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;)</span><span class="nc">LambdaMetafactory</span><span class="o">.</span><span class="na">metafactory</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="o">(</span><span class="nc">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="nc">Object</span><span class="o">;)</span><span class="no">Z</span><span class="o">,</span> <span class="n">lambda$main</span><span class="err">$</span><span class="mi">0</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="o">),</span> <span class="o">(</span><span class="nc">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="nc">String</span><span class="o">;)</span><span class="no">Z</span><span class="o">)()).</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
    <span class="nc">HollisList</span><span class="o">.</span><span class="na">forEach</span><span class="o">((</span><span class="nc">Consumer</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;)</span><span class="nc">LambdaMetafactory</span><span class="o">.</span><span class="na">metafactory</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="o">(</span><span class="nc">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="nc">Object</span><span class="o">;)</span><span class="no">V</span><span class="o">,</span> <span class="n">lambda$main</span><span class="err">$</span><span class="mi">1</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Object</span> <span class="o">),</span> <span class="o">(</span><span class="nc">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="nc">Object</span><span class="o">;)</span><span class="no">V</span><span class="o">)());</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="cm">/* synthetic */</span> <span class="kt">void</span> <span class="n">lambda$main</span><span class="err">$</span><span class="mi">1</span><span class="o">(</span><span class="nc">Object</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="cm">/* synthetic */</span> <span class="kt">boolean</span> <span class="n">lambda$main</span><span class="err">$</span><span class="mi">0</span><span class="o">(</span><span class="nc">String</span> <span class="n">string</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">string</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"Hollis"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>两个 lambda 表达式分别调用了<code class="language-plaintext highlighter-rouge">lambda$main$1</code>和<code class="language-plaintext highlighter-rouge">lambda$main$0</code>两个方法。</p>

<p><strong>所以，lambda 表达式的实现其实是依赖了一些底层的 api，在编译阶段，编译器会把 lambda 表达式进行解糖，转换成调用内部 api 的方式。</strong></p>

<h2 id="可能遇到的坑">可能遇到的坑</h2>

<h3 id="泛型-1">泛型</h3>

<p><strong>一、当泛型遇到重载</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericTypes</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"invoke method(List&lt;String&gt; list)"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"invoke method(List&lt;Integer&gt; list)"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>上面这段代码，有两个重载的函数，因为他们的参数类型不同，一个是<code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code>另一个是<code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;</code> ，但是，这段代码是编译通不过的。因为我们前面讲过，参数<code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;</code>和<code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code>编译之后都被擦除了，变成了一样的原生类型 List，擦除动作导致这两个方法的特征签名变得一模一样。</p>

<p><strong>二、当泛型遇到 catch</strong></p>

<p>泛型的类型参数不能用在 Java 异常处理的 catch 语句中。因为异常处理是由 JVM 在运行时刻来进行的。由于类型信息被擦除，JVM 是无法区分两个异常类型<code class="language-plaintext highlighter-rouge">MyException&lt;String&gt;</code>和<code class="language-plaintext highlighter-rouge">MyException&lt;Integer&gt;</code>的</p>

<p><strong>三、当泛型内包含静态变量</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StaticTest</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="no">GT</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">gti</span> <span class="o">=</span> <span class="k">new</span> <span class="no">GT</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="n">gti</span><span class="o">.</span><span class="na">var</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>
        <span class="no">GT</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">gts</span> <span class="o">=</span> <span class="k">new</span> <span class="no">GT</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
        <span class="n">gts</span><span class="o">.</span><span class="na">var</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">gti</span><span class="o">.</span><span class="na">var</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">GT</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="kt">var</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">nothing</span><span class="o">(</span><span class="no">T</span> <span class="n">x</span><span class="o">){}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>以上代码输出结果为：2！</p>

<p>有些同学可能会误认为泛型类是不同的类，对应不同的字节码，其实
由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的静态变量是共享的。上面例子里的<code class="language-plaintext highlighter-rouge">GT&lt;Integer&gt;.var</code>和<code class="language-plaintext highlighter-rouge">GT&lt;String&gt;.var</code>其实是一个变量。</p>

<h3 id="自动装箱与拆箱-1">自动装箱与拆箱</h3>

<p><strong>对象相等比较</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Integer</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">;</span>
    <span class="nc">Integer</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">;</span>
    <span class="nc">Integer</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
    <span class="nc">Integer</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"a == b is "</span> <span class="o">+</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">));</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="s">"c == d is "</span> <span class="o">+</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">d</span><span class="o">)));</span>
<span class="o">}</span>
</code></pre></div></div>

<p>输出结果：</p>

<pre><code class="language-plain">a == b is false
c == d is true
</code></pre>

<p>在 Java 5 中，在 Integer 的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。</p>

<blockquote>
  <p>适用于整数值区间-128 至 +127。</p>

  <p>只适用于自动装箱。使用构造函数创建对象不适用。</p>
</blockquote>

<h3 id="增强-for-循环">增强 for 循环</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="nc">Student</span> <span class="n">stu</span> <span class="o">:</span> <span class="n">students</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">stu</span><span class="o">.</span><span class="na">getId</span><span class="o">()</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>
        <span class="n">students</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">stu</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>会抛出<code class="language-plaintext highlighter-rouge">ConcurrentModificationException</code>异常。</p>

<p>Iterator 是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator 被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出<code class="language-plaintext highlighter-rouge">java.util.ConcurrentModificationException</code>异常。</p>

<p>所以 <code class="language-plaintext highlighter-rouge">Iterator</code> 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 <code class="language-plaintext highlighter-rouge">Iterator</code> 本身的方法<code class="language-plaintext highlighter-rouge">remove()</code>来删除对象，<code class="language-plaintext highlighter-rouge">Iterator.remove()</code> 方法会在删除当前迭代对象的同时维护索引的一致性。</p>

<h2 id="总结">总结</h2>

<p>前面介绍了 12 种 Java 中常用的语法糖。所谓语法糖就是提供给开发人员便于开发的一种语法而已。但是这种语法只有开发人员认识。要想被执行，需要进行解糖，即转成 JVM 认识的语法。当我们把语法糖解糖之后，你就会发现其实我们日常使用的这些方便的语法，其实都是一些其他更简单的语法构成的。</p>

<p>有了这些语法糖，我们在日常开发的时候可以大大提升效率，但是同时也要避过度使用。使用之前最好了解下原理，避免掉坑。</p>

<!-- @include: @article-footer.snippet.md -->
