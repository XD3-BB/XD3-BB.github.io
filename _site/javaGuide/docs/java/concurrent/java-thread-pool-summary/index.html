<!-- markdownlint-disable MD024 -->

<p>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、HTTP 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p>

<p>这篇文章我会详细介绍一下线程池的基本概念以及核心原理。</p>

<h2 id="线程池介绍">线程池介绍</h2>

<p>顾名思义，线程池就是管理一系列线程的资源池，其提供了一种限制和管理线程资源的方式。每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p>

<p>这里借用《Java 并发编程的艺术》书中的部分内容来总结一下使用线程池的好处：</p>

<ul>
  <li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
  <li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
  <li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>

<p><strong>线程池一般用于执行多个不相关联的耗时任务，没有多线程的情况下，任务顺序执行，使用了线程池的话可让多个不相关联的任务同时执行。</strong></p>

<h2 id="executor-框架介绍">Executor 框架介绍</h2>

<p><code class="language-plaintext highlighter-rouge">Executor</code> 框架是 Java5 之后引进的，在 Java 5 之后，通过 <code class="language-plaintext highlighter-rouge">Executor</code> 来启动线程比使用 <code class="language-plaintext highlighter-rouge">Thread</code> 的 <code class="language-plaintext highlighter-rouge">start</code> 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。</p>

<blockquote>
  <p>this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用，调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">Executor</code> 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，<code class="language-plaintext highlighter-rouge">Executor</code> 框架让并发编程变得更加简单。</p>

<p><code class="language-plaintext highlighter-rouge">Executor</code> 框架结构主要由三大部分组成：</p>

<p><strong>1、任务(<code class="language-plaintext highlighter-rouge">Runnable</code> /<code class="language-plaintext highlighter-rouge">Callable</code>)</strong></p>

<p>执行任务需要实现的 <strong><code class="language-plaintext highlighter-rouge">Runnable</code> 接口</strong> 或 <strong><code class="language-plaintext highlighter-rouge">Callable</code>接口</strong>。<strong><code class="language-plaintext highlighter-rouge">Runnable</code> 接口</strong>或 <strong><code class="language-plaintext highlighter-rouge">Callable</code> 接口</strong> 实现类都可以被 <strong><code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code></strong> 或 <strong><code class="language-plaintext highlighter-rouge">ScheduledThreadPoolExecutor</code></strong> 执行。</p>

<p><strong>2、任务的执行(<code class="language-plaintext highlighter-rouge">Executor</code>)</strong></p>

<p>如下图所示，包括任务执行机制的核心接口 <strong><code class="language-plaintext highlighter-rouge">Executor</code></strong> ，以及继承自 <code class="language-plaintext highlighter-rouge">Executor</code> 接口的 <strong><code class="language-plaintext highlighter-rouge">ExecutorService</code> 接口。<code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code></strong> 和 <strong><code class="language-plaintext highlighter-rouge">ScheduledThreadPoolExecutor</code></strong> 这两个关键类实现了 <strong><code class="language-plaintext highlighter-rouge">ExecutorService</code></strong> 接口。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/executor-class-diagram.png" alt="" /></p>

<p>这里提了很多底层的类关系，但是，实际上我们需要更多关注的是 <code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code> 这个类，这个类在我们实际使用线程池的过程中，使用频率还是非常高的。</p>

<p><strong>注意：</strong> 通过查看 <code class="language-plaintext highlighter-rouge">ScheduledThreadPoolExecutor</code> 源代码我们发现 <code class="language-plaintext highlighter-rouge">ScheduledThreadPoolExecutor</code> 实际上是继承了 <code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code> 并实现了 <code class="language-plaintext highlighter-rouge">ScheduledExecutorService</code> ，而 <code class="language-plaintext highlighter-rouge">ScheduledExecutorService</code> 又实现了 <code class="language-plaintext highlighter-rouge">ExecutorService</code>，正如我们上面给出的类关系图显示的一样。</p>

<p><code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code> 类描述:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//AbstractExecutorService实现了ExecutorService接口</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadPoolExecutor</span> <span class="kd">extends</span> <span class="nc">AbstractExecutorService</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ScheduledThreadPoolExecutor</code> 类描述:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//ScheduledExecutorService继承ExecutorService接口</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ScheduledThreadPoolExecutor</span>
        <span class="kd">extends</span> <span class="nc">ThreadPoolExecutor</span>
        <span class="kd">implements</span> <span class="nc">ScheduledExecutorService</span>
</code></pre></div></div>

<p><strong>3、异步计算的结果(<code class="language-plaintext highlighter-rouge">Future</code>)</strong></p>

<p><strong><code class="language-plaintext highlighter-rouge">Future</code></strong> 接口以及 <code class="language-plaintext highlighter-rouge">Future</code> 接口的实现类 <strong><code class="language-plaintext highlighter-rouge">FutureTask</code></strong> 类都可以代表异步计算的结果。</p>

<p>当我们把 <strong><code class="language-plaintext highlighter-rouge">Runnable</code>接口</strong> 或 <strong><code class="language-plaintext highlighter-rouge">Callable</code> 接口</strong> 的实现类提交给 <strong><code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code></strong> 或 <strong><code class="language-plaintext highlighter-rouge">ScheduledThreadPoolExecutor</code></strong> 执行。（调用 <code class="language-plaintext highlighter-rouge">submit()</code> 方法时会返回一个 <strong><code class="language-plaintext highlighter-rouge">FutureTask</code></strong> 对象）</p>

<p><strong><code class="language-plaintext highlighter-rouge">Executor</code> 框架的使用示意图</strong>：</p>

<p><img src="./images/java-thread-pool-summary/Executor框架的使用示意图.png" alt="Executor 框架的使用示意图" /></p>

<ol>
  <li>主线程首先要创建实现 <code class="language-plaintext highlighter-rouge">Runnable</code> 或者 <code class="language-plaintext highlighter-rouge">Callable</code> 接口的任务对象。</li>
  <li>把创建完成的实现 <code class="language-plaintext highlighter-rouge">Runnable</code>/<code class="language-plaintext highlighter-rouge">Callable</code>接口的 对象直接交给 <code class="language-plaintext highlighter-rouge">ExecutorService</code> 执行: <code class="language-plaintext highlighter-rouge">ExecutorService.execute（Runnable command）</code>）或者也可以把 <code class="language-plaintext highlighter-rouge">Runnable</code> 对象或<code class="language-plaintext highlighter-rouge">Callable</code> 对象提交给 <code class="language-plaintext highlighter-rouge">ExecutorService</code> 执行（<code class="language-plaintext highlighter-rouge">ExecutorService.submit（Runnable task）</code>或 <code class="language-plaintext highlighter-rouge">ExecutorService.submit（Callable &lt;T&gt; task）</code>）。</li>
  <li>如果执行 <code class="language-plaintext highlighter-rouge">ExecutorService.submit（…）</code>，<code class="language-plaintext highlighter-rouge">ExecutorService</code> 将返回一个实现<code class="language-plaintext highlighter-rouge">Future</code>接口的对象（我们刚刚也提到过了执行 <code class="language-plaintext highlighter-rouge">execute()</code>方法和 <code class="language-plaintext highlighter-rouge">submit()</code>方法的区别，<code class="language-plaintext highlighter-rouge">submit()</code>会返回一个 <code class="language-plaintext highlighter-rouge">FutureTask 对象）。由于 FutureTask</code> 实现了 <code class="language-plaintext highlighter-rouge">Runnable</code>，我们也可以创建 <code class="language-plaintext highlighter-rouge">FutureTask</code>，然后直接交给 <code class="language-plaintext highlighter-rouge">ExecutorService</code> 执行。</li>
  <li>最后，主线程可以执行 <code class="language-plaintext highlighter-rouge">FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行 <code class="language-plaintext highlighter-rouge">FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</li>
</ol>

<h2 id="threadpoolexecutor-类介绍重要">ThreadPoolExecutor 类介绍（重要）</h2>

<p>线程池实现类 <code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code> 是 <code class="language-plaintext highlighter-rouge">Executor</code> 框架最核心的类。</p>

<h3 id="线程池参数分析">线程池参数分析</h3>

<p><code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code> 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么）。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cm">/**
     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
     */</span>
    <span class="kd">public</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="kt">int</span> <span class="n">corePoolSize</span><span class="o">,</span><span class="c1">//线程池的核心线程数量</span>
                              <span class="kt">int</span> <span class="n">maximumPoolSize</span><span class="o">,</span><span class="c1">//线程池的最大线程数</span>
                              <span class="kt">long</span> <span class="n">keepAliveTime</span><span class="o">,</span><span class="c1">//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span>
                              <span class="nc">TimeUnit</span> <span class="n">unit</span><span class="o">,</span><span class="c1">//时间单位</span>
                              <span class="nc">BlockingQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;</span> <span class="n">workQueue</span><span class="o">,</span><span class="c1">//任务队列，用来储存等待执行任务的队列</span>
                              <span class="nc">ThreadFactory</span> <span class="n">threadFactory</span><span class="o">,</span><span class="c1">//线程工厂，用来创建线程，一般默认即可</span>
                              <span class="nc">RejectedExecutionHandler</span> <span class="n">handler</span><span class="c1">//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span>
                               <span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">corePoolSize</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
            <span class="n">maximumPoolSize</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span>
            <span class="n">maximumPoolSize</span> <span class="o">&lt;</span> <span class="n">corePoolSize</span> <span class="o">||</span>
            <span class="n">keepAliveTime</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">workQueue</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">threadFactory</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">handler</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">corePoolSize</span> <span class="o">=</span> <span class="n">corePoolSize</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">maximumPoolSize</span> <span class="o">=</span> <span class="n">maximumPoolSize</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">workQueue</span> <span class="o">=</span> <span class="n">workQueue</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">keepAliveTime</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="na">toNanos</span><span class="o">(</span><span class="n">keepAliveTime</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">threadFactory</span> <span class="o">=</span> <span class="n">threadFactory</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">handler</span> <span class="o">=</span> <span class="n">handler</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>下面这些参数非常重要，在后面使用线程池的过程中你一定会用到！所以，务必拿着小本本记清楚。</p>

<p><code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code> 3 个最重要的参数：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">corePoolSize</code> : 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li>
  <li><code class="language-plaintext highlighter-rouge">maximumPoolSize</code> : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
  <li><code class="language-plaintext highlighter-rouge">workQueue</code>: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code>其他常见参数 :</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">keepAliveTime</code>:线程池中的线程数量大于 <code class="language-plaintext highlighter-rouge">corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code class="language-plaintext highlighter-rouge">keepAliveTime</code>才会被回收销毁。</li>
  <li><code class="language-plaintext highlighter-rouge">unit</code> : <code class="language-plaintext highlighter-rouge">keepAliveTime</code> 参数的时间单位。</li>
  <li><code class="language-plaintext highlighter-rouge">threadFactory</code> :executor 创建新线程的时候会用到。</li>
  <li><code class="language-plaintext highlighter-rouge">handler</code> :拒绝策略（后面会单独详细介绍一下）。</li>
</ul>

<p>下面这张图可以加深你对线程池中各个参数的相互关系的理解（图片来源：《Java 性能调优实战》）：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/relationship-between-thread-pool-parameters.png" alt="线程池各个参数的关系" /></p>

<p><strong><code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code> 拒绝策略定义:</strong></p>

<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code> 定义一些策略:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ThreadPoolExecutor.AbortPolicy</code>：抛出 <code class="language-plaintext highlighter-rouge">RejectedExecutionException</code>来拒绝新任务的处理。</li>
  <li><code class="language-plaintext highlighter-rouge">ThreadPoolExecutor.CallerRunsPolicy</code>：调用执行自己的线程运行任务，也就是直接在调用<code class="language-plaintext highlighter-rouge">execute</code>方法的线程中运行(<code class="language-plaintext highlighter-rouge">run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
  <li><code class="language-plaintext highlighter-rouge">ThreadPoolExecutor.DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li>
  <li><code class="language-plaintext highlighter-rouge">ThreadPoolExecutor.DiscardOldestPolicy</code>：此策略将丢弃最早的未处理的任务请求。</li>
</ul>

<p>举个例子：</p>

<p>举个例子：Spring 通过 <code class="language-plaintext highlighter-rouge">ThreadPoolTaskExecutor</code> 或者我们直接通过 <code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code> 的构造函数创建线程池的时候，当我们不指定 <code class="language-plaintext highlighter-rouge">RejectedExecutionHandler</code> 拒绝策略来配置线程池的时候，默认使用的是 <code class="language-plaintext highlighter-rouge">AbortPolicy</code>。在这种拒绝策略下，如果队列满了，<code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code> 将抛出 <code class="language-plaintext highlighter-rouge">RejectedExecutionException</code> 异常来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。如果不想丢弃任务的话，可以使用<code class="language-plaintext highlighter-rouge">CallerRunsPolicy</code>。<code class="language-plaintext highlighter-rouge">CallerRunsPolicy</code> 和其他的几个策略不同，它既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，使用调用者的线程来执行任务</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">CallerRunsPolicy</span> <span class="kd">implements</span> <span class="nc">RejectedExecutionHandler</span> <span class="o">{</span>

        <span class="kd">public</span> <span class="nf">CallerRunsPolicy</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">rejectedExecution</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">r</span><span class="o">,</span> <span class="nc">ThreadPoolExecutor</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">e</span><span class="o">.</span><span class="na">isShutdown</span><span class="o">())</span> <span class="o">{</span>
                <span class="c1">// 直接主线程执行，而不是线程池中的线程执行</span>
                <span class="n">r</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<h3 id="线程池创建的两种方式">线程池创建的两种方式</h3>

<p><strong>方式一：通过<code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code>构造函数来创建（推荐）。</strong></p>

<p><img src="./images/java-thread-pool-summary/threadpoolexecutor构造函数.png" alt="通过构造方法实现" /></p>

<p><strong>方式二：通过 <code class="language-plaintext highlighter-rouge">Executor</code> 框架的工具类 <code class="language-plaintext highlighter-rouge">Executors</code> 来创建。</strong></p>

<p><code class="language-plaintext highlighter-rouge">Executors</code>工具类提供的创建线程池的方法如下图所示：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/executors-new-thread-pool-methods.png" alt="" /></p>

<p>可以看出，通过<code class="language-plaintext highlighter-rouge">Executors</code>工具类可以创建多种类型的线程池，包括：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">FixedThreadPool</code>：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
  <li><code class="language-plaintext highlighter-rouge">SingleThreadExecutor</code>： 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
  <li><code class="language-plaintext highlighter-rouge">CachedThreadPool</code>： 可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
  <li><code class="language-plaintext highlighter-rouge">ScheduledThreadPool</code>：给定的延迟后运行任务或者定期执行任务的线程池。</li>
</ul>

<p>《阿里巴巴 Java 开发手册》强制线程池不允许使用 <code class="language-plaintext highlighter-rouge">Executors</code> 去创建，而是通过 <code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>

<p><code class="language-plaintext highlighter-rouge">Executors</code> 返回线程池对象的弊端如下(后文会详细介绍到)：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">FixedThreadPool</code> 和 <code class="language-plaintext highlighter-rouge">SingleThreadExecutor</code>:使用的是无界的 <code class="language-plaintext highlighter-rouge">LinkedBlockingQueue</code>，任务队列最大长度为 <code class="language-plaintext highlighter-rouge">Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
  <li><code class="language-plaintext highlighter-rouge">CachedThreadPool</code>:使用的是同步队列 <code class="language-plaintext highlighter-rouge">SynchronousQueue</code>, 允许创建的线程数量为 <code class="language-plaintext highlighter-rouge">Integer.MAX_VALUE</code> ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。</li>
  <li><code class="language-plaintext highlighter-rouge">ScheduledThreadPool</code> 和 <code class="language-plaintext highlighter-rouge">SingleThreadScheduledExecutor</code>:使用的无界的延迟阻塞队列<code class="language-plaintext highlighter-rouge">DelayedWorkQueue</code>，任务队列最大长度为 <code class="language-plaintext highlighter-rouge">Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 无界队列 LinkedBlockingQueue</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">ExecutorService</span> <span class="nf">newFixedThreadPool</span><span class="o">(</span><span class="kt">int</span> <span class="n">nThreads</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">return</span> <span class="k">new</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="n">nThreads</span><span class="o">,</span> <span class="n">nThreads</span><span class="o">,</span><span class="mi">0L</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span><span class="k">new</span> <span class="nc">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;());</span>

<span class="o">}</span>

<span class="c1">// 无界队列 LinkedBlockingQueue</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">ExecutorService</span> <span class="nf">newSingleThreadExecutor</span><span class="o">()</span> <span class="o">{</span>

    <span class="k">return</span> <span class="k">new</span> <span class="nf">FinalizableDelegatedExecutorService</span> <span class="o">(</span><span class="k">new</span> <span class="nc">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span><span class="mi">0L</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span><span class="k">new</span> <span class="nc">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;()));</span>

<span class="o">}</span>

<span class="c1">// 同步队列 SynchronousQueue，没有容量，最大线程数是 Integer.MAX_VALUE`</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">ExecutorService</span> <span class="nf">newCachedThreadPool</span><span class="o">()</span> <span class="o">{</span>

    <span class="k">return</span> <span class="k">new</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">,</span><span class="mi">60L</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">,</span><span class="k">new</span> <span class="nc">SynchronousQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;());</span>

<span class="o">}</span>

<span class="c1">// DelayedWorkQueue（延迟阻塞队列）</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">ScheduledExecutorService</span> <span class="nf">newScheduledThreadPool</span><span class="o">(</span><span class="kt">int</span> <span class="n">corePoolSize</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">ScheduledThreadPoolExecutor</span><span class="o">(</span><span class="n">corePoolSize</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="nf">ScheduledThreadPoolExecutor</span><span class="o">(</span><span class="kt">int</span> <span class="n">corePoolSize</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">corePoolSize</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="no">NANOSECONDS</span><span class="o">,</span>
          <span class="k">new</span> <span class="nf">DelayedWorkQueue</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="线程池常用的阻塞队列总结">线程池常用的阻塞队列总结</h3>

<p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p>

<p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p>

<ul>
  <li>容量为 <code class="language-plaintext highlighter-rouge">Integer.MAX_VALUE</code> 的 <code class="language-plaintext highlighter-rouge">LinkedBlockingQueue</code>（无界队列）：<code class="language-plaintext highlighter-rouge">FixedThreadPool</code> 和 <code class="language-plaintext highlighter-rouge">SingleThreadExector</code> 。<code class="language-plaintext highlighter-rouge">FixedThreadPool</code>最多只能创建核心线程数的线程（核心线程数和最大线程数相等），<code class="language-plaintext highlighter-rouge">SingleThreadExector</code>只能创建一个线程（核心线程数和最大线程数都是 1），二者的任务队列永远不会被放满。</li>
  <li><code class="language-plaintext highlighter-rouge">SynchronousQueue</code>（同步队列）：<code class="language-plaintext highlighter-rouge">CachedThreadPool</code> 。<code class="language-plaintext highlighter-rouge">SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code class="language-plaintext highlighter-rouge">CachedThreadPool</code> 的最大线程数是 <code class="language-plaintext highlighter-rouge">Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li>
  <li><code class="language-plaintext highlighter-rouge">DelayedWorkQueue</code>（延迟阻塞队列）：<code class="language-plaintext highlighter-rouge">ScheduledThreadPool</code> 和 <code class="language-plaintext highlighter-rouge">SingleThreadScheduledExecutor</code> 。<code class="language-plaintext highlighter-rouge">DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code class="language-plaintext highlighter-rouge">DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 <code class="language-plaintext highlighter-rouge">Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li>
</ul>

<h2 id="线程池原理分析重要">线程池原理分析（重要）</h2>

<p>我们上面讲解了 <code class="language-plaintext highlighter-rouge">Executor</code>框架以及 <code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code> 类，下面让我们实战一下，来通过写一个 <code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code> 的小 Demo 来回顾上面的内容。</p>

<h3 id="线程池示例代码">线程池示例代码</h3>

<p>首先创建一个 <code class="language-plaintext highlighter-rouge">Runnable</code> 接口的实现类（当然也可以是 <code class="language-plaintext highlighter-rouge">Callable</code> 接口，我们后面会介绍两者的区别。）</p>

<p><code class="language-plaintext highlighter-rouge">MyRunnable.java</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Date</span><span class="o">;</span>

<span class="cm">/**
 * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。
 * @author shuang.kou
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyRunnable</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">command</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyRunnable</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">command</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" Start. Time = "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">Date</span><span class="o">());</span>
        <span class="n">processCommand</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" End. Time = "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">Date</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">processCommand</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">5000</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">command</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>编写测试程序，我们这里以阿里巴巴推荐的使用 <code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</p>

<p><code class="language-plaintext highlighter-rouge">ThreadPoolExecutorDemo.java</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.ArrayBlockingQueue</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.ThreadPoolExecutor</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.TimeUnit</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadPoolExecutorDemo</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">CORE_POOL_SIZE</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MAX_POOL_SIZE</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">QUEUE_CAPACITY</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Long</span> <span class="no">KEEP_ALIVE_TIME</span> <span class="o">=</span> <span class="mi">1L</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">//使用阿里巴巴推荐的创建线程池的方式</span>
        <span class="c1">//通过ThreadPoolExecutor构造函数自定义参数创建</span>
        <span class="nc">ThreadPoolExecutor</span> <span class="n">executor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolExecutor</span><span class="o">(</span>
                <span class="no">CORE_POOL_SIZE</span><span class="o">,</span>
                <span class="no">MAX_POOL_SIZE</span><span class="o">,</span>
                <span class="no">KEEP_ALIVE_TIME</span><span class="o">,</span>
                <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">,</span>
                <span class="k">new</span> <span class="nc">ArrayBlockingQueue</span><span class="o">&lt;&gt;(</span><span class="no">QUEUE_CAPACITY</span><span class="o">),</span>
                <span class="k">new</span> <span class="nc">ThreadPoolExecutor</span><span class="o">.</span><span class="na">CallerRunsPolicy</span><span class="o">());</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span>
            <span class="nc">Runnable</span> <span class="n">worker</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyRunnable</span><span class="o">(</span><span class="s">""</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
            <span class="c1">//执行Runnable</span>
            <span class="n">executor</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">worker</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//终止线程池</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">executor</span><span class="o">.</span><span class="na">isTerminated</span><span class="o">())</span> <span class="o">{</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Finished all threads"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>可以看到我们上面的代码指定了：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">corePoolSize</code>: 核心线程数为 5。</li>
  <li><code class="language-plaintext highlighter-rouge">maximumPoolSize</code>：最大线程数 10</li>
  <li><code class="language-plaintext highlighter-rouge">keepAliveTime</code> : 等待时间为 1L。</li>
  <li><code class="language-plaintext highlighter-rouge">unit</code>: 等待时间的单位为 TimeUnit.SECONDS。</li>
  <li><code class="language-plaintext highlighter-rouge">workQueue</code>：任务队列为 <code class="language-plaintext highlighter-rouge">ArrayBlockingQueue</code>，并且容量为 100;</li>
  <li><code class="language-plaintext highlighter-rouge">handler</code>:拒绝策略为 <code class="language-plaintext highlighter-rouge">CallerRunsPolicy</code>。</li>
</ul>

<p><strong>输出结构</strong>：</p>

<pre><code class="language-plain">pool-1-thread-3 Start. Time = Sun Apr 12 11:14:37 CST 2020
pool-1-thread-5 Start. Time = Sun Apr 12 11:14:37 CST 2020
pool-1-thread-2 Start. Time = Sun Apr 12 11:14:37 CST 2020
pool-1-thread-1 Start. Time = Sun Apr 12 11:14:37 CST 2020
pool-1-thread-4 Start. Time = Sun Apr 12 11:14:37 CST 2020
pool-1-thread-3 End. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-4 End. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-1 End. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-5 End. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-1 Start. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-2 End. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-5 Start. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-4 Start. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-3 Start. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-2 Start. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-1 End. Time = Sun Apr 12 11:14:47 CST 2020
pool-1-thread-4 End. Time = Sun Apr 12 11:14:47 CST 2020
pool-1-thread-5 End. Time = Sun Apr 12 11:14:47 CST 2020
pool-1-thread-3 End. Time = Sun Apr 12 11:14:47 CST 2020
pool-1-thread-2 End. Time = Sun Apr 12 11:14:47 CST 2020
Finished all threads  // 任务全部执行完了才会跳出来，因为executor.isTerminated()判断为true了才会跳出while循环，当且仅当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true

</code></pre>

<h3 id="线程池原理分析">线程池原理分析</h3>

<p>我们通过前面的代码输出结果可以看出：<strong>线程池首先会先执行 5 个任务，然后这些任务有任务被执行完的话，就会去拿新的任务执行。</strong> 大家可以先通过上面讲解的内容，分析一下到底是咋回事？（自己独立思考一会）</p>

<p>现在，我们就分析上面的输出内容来简单分析一下线程池原理。</p>

<p>为了搞懂线程池的原理，我们需要首先分析一下 <code class="language-plaintext highlighter-rouge">execute</code>方法。 在示例代码中，我们使用 <code class="language-plaintext highlighter-rouge">executor.execute(worker)</code>来提交一个任务到线程池中去。</p>

<p>这个方法非常重要，下面我们来看看它的源码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="c1">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span>
   <span class="kd">private</span> <span class="kd">final</span> <span class="nc">AtomicInteger</span> <span class="n">ctl</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AtomicInteger</span><span class="o">(</span><span class="n">ctlOf</span><span class="o">(</span><span class="no">RUNNING</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">workerCountOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="no">CAPACITY</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//任务队列</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">BlockingQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;</span> <span class="n">workQueue</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 如果任务为null，则抛出异常。</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">command</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
        <span class="c1">// ctl 中保存的线程池当前的一些状态信息</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>

        <span class="c1">//  下面会涉及到 3 步 操作</span>
        <span class="c1">// 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize</span>
        <span class="c1">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">corePoolSize</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">addWorker</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">// 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里，表明创建新的线程失败。</span>
        <span class="c1">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态并且队列可以加入任务，该任务才会被加入进去</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isRunning</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">command</span><span class="o">))</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">recheck</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="c1">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">isRunning</span><span class="o">(</span><span class="n">recheck</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">remove</span><span class="o">(</span><span class="n">command</span><span class="o">))</span>
                <span class="n">reject</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>
                <span class="c1">// 如果当前工作线程数量为0，新创建一个线程并执行。</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">recheck</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
                <span class="n">addWorker</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span>
        <span class="c1">// 传入 false 代表增加线程时判断当前线程数是否少于 maxPoolSize</span>
        <span class="c1">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(!</span><span class="n">addWorker</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="kc">false</span><span class="o">))</span>
            <span class="n">reject</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>这里简单分析一下整个流程（对整个逻辑进行了简化，方便理解）：</p>

<ol>
  <li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li>
  <li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li>
  <li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li>
  <li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，拒绝策略会调用<code class="language-plaintext highlighter-rouge">RejectedExecutionHandler.rejectedExecution()</code>方法。</li>
</ol>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/thread-pool-principle.png" alt="图解线程池实现原理" /></p>

<p>在 <code class="language-plaintext highlighter-rouge">execute</code> 方法中，多次调用 <code class="language-plaintext highlighter-rouge">addWorker</code> 方法。<code class="language-plaintext highlighter-rouge">addWorker</code> 这个方法主要用来创建新的工作线程，如果返回 true 说明创建和启动工作线程成功，否则的话返回的就是 false。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// 全局锁，并发操作必备</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">();</span>
    <span class="c1">// 跟踪线程池的最大大小，只有在持有全局锁mainLock的前提下才能访问此集合</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">largestPoolSize</span><span class="o">;</span>
    <span class="c1">// 工作线程集合，存放线程池中所有的（活跃的）工作线程，只有在持有全局锁mainLock的前提下才能访问此集合</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Worker</span><span class="o">&gt;</span> <span class="n">workers</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="c1">//获取线程池状态</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">runStateOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">)</span>     <span class="o">{</span> <span class="k">return</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="o">~</span><span class="no">CAPACITY</span><span class="o">;</span> <span class="o">}</span>
    <span class="c1">//判断线程池的状态是否为 Running</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isRunning</span><span class="o">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="no">SHUTDOWN</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="cm">/**
     * 添加新的工作线程到线程池
     * @param firstTask 要执行
     * @param core参数为true的话表示使用线程池的基本大小，为false使用线程池最大大小
     * @return 添加成功就返回true否则返回false
     */</span>
   <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">addWorker</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">firstTask</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">core</span><span class="o">)</span> <span class="o">{</span>
        <span class="nl">retry:</span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
            <span class="c1">//这两句用来获取线程池的状态</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">runStateOf</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>

            <span class="c1">// Check if queue empty only if necessary.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">rs</span> <span class="o">&gt;=</span> <span class="no">SHUTDOWN</span> <span class="o">&amp;&amp;</span>
                <span class="o">!</span> <span class="o">(</span><span class="n">rs</span> <span class="o">==</span> <span class="no">SHUTDOWN</span> <span class="o">&amp;&amp;</span>
                   <span class="n">firstTask</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                   <span class="o">!</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()))</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

            <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
               <span class="c1">//获取线程池中工作的线程的数量</span>
                <span class="kt">int</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
                <span class="c1">// core参数为false的话表明队列也满了，线程池大小变为 maximumPoolSize</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">wc</span> <span class="o">&gt;=</span> <span class="no">CAPACITY</span> <span class="o">||</span>
                    <span class="n">wc</span> <span class="o">&gt;=</span> <span class="o">(</span><span class="n">core</span> <span class="o">?</span> <span class="n">corePoolSize</span> <span class="o">:</span> <span class="n">maximumPoolSize</span><span class="o">))</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
               <span class="c1">//原子操作将workcount的数量加1</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">compareAndIncrementWorkerCount</span><span class="o">(</span><span class="n">c</span><span class="o">))</span>
                    <span class="k">break</span> <span class="n">retry</span><span class="o">;</span>
                <span class="c1">// 如果线程的状态改变了就再次执行上述操作</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">runStateOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">!=</span> <span class="n">rs</span><span class="o">)</span>
                    <span class="k">continue</span> <span class="n">retry</span><span class="o">;</span>
                <span class="c1">// else CAS failed due to workerCount change; retry inner loop</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 标记工作线程是否启动成功</span>
        <span class="kt">boolean</span> <span class="n">workerStarted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="c1">// 标记工作线程是否创建成功</span>
        <span class="kt">boolean</span> <span class="n">workerAdded</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="nc">Worker</span> <span class="n">w</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>

            <span class="n">w</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Worker</span><span class="o">(</span><span class="n">firstTask</span><span class="o">);</span>
            <span class="kd">final</span> <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">thread</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
              <span class="c1">// 加锁</span>
                <span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
                <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
                <span class="k">try</span> <span class="o">{</span>
                   <span class="c1">//获取线程池状态</span>
                    <span class="kt">int</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">runStateOf</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
                   <span class="c1">//rs &lt; SHUTDOWN 如果线程池状态依然为RUNNING,并且线程的状态是存活的话，就会将工作线程添加到工作线程集合中</span>
                  <span class="c1">//(rs=SHUTDOWN &amp;&amp; firstTask == null)如果线程池状态小于STOP，也就是RUNNING或者SHUTDOWN状态下，同时传入的任务实例firstTask为null，则需要添加到工作线程集合和启动新的Worker</span>
                   <span class="c1">// firstTask == null证明只新建线程而不执行任务</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">rs</span> <span class="o">&lt;</span> <span class="no">SHUTDOWN</span> <span class="o">||</span>
                        <span class="o">(</span><span class="n">rs</span> <span class="o">==</span> <span class="no">SHUTDOWN</span> <span class="o">&amp;&amp;</span> <span class="n">firstTask</span> <span class="o">==</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">isAlive</span><span class="o">())</span> <span class="c1">// precheck that t is startable</span>
                            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalThreadStateException</span><span class="o">();</span>
                        <span class="n">workers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
                       <span class="c1">//更新当前工作线程的最大容量</span>
                        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">workers</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">largestPoolSize</span><span class="o">)</span>
                            <span class="n">largestPoolSize</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
                      <span class="c1">// 工作线程是否启动成功</span>
                        <span class="n">workerAdded</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                    <span class="c1">// 释放锁</span>
                    <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="c1">//// 如果成功添加工作线程，则调用Worker内部的线程实例t的Thread#start()方法启动真实的线程实例</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">workerAdded</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
                  <span class="c1">/// 标记线程启动成功</span>
                    <span class="n">workerStarted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
           <span class="c1">// 线程启动失败，需要从工作线程中移除对应的Worker</span>
            <span class="k">if</span> <span class="o">(!</span> <span class="n">workerStarted</span><span class="o">)</span>
                <span class="n">addWorkerFailed</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">workerStarted</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>更多关于线程池源码分析的内容推荐这篇文章：硬核干货：<a href="https://www.throwx.cn/2020/08/23/java-concurrency-thread-pool-executor/">4W 字从源码上分析 JUC 线程池 ThreadPoolExecutor 的实现原理</a></p>

<p>现在，让我们在回到示例代码， 现在应该是不是很容易就可以搞懂它的原理了呢？</p>

<p>没搞懂的话，也没关系，可以看看我的分析：</p>

<blockquote>
  <p>我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的 5 个任务中如果有任务被执行完了，线程池就会去拿新的任务执行。</p>
</blockquote>

<h3 id="几个常见的对比">几个常见的对比</h3>

<h4 id="runnable-vs-callable"><code class="language-plaintext highlighter-rouge">Runnable</code> vs <code class="language-plaintext highlighter-rouge">Callable</code></h4>

<p><code class="language-plaintext highlighter-rouge">Runnable</code>自 Java 1.0 以来一直存在，但<code class="language-plaintext highlighter-rouge">Callable</code>仅在 Java 1.5 中引入,目的就是为了来处理<code class="language-plaintext highlighter-rouge">Runnable</code>不支持的用例。<code class="language-plaintext highlighter-rouge">Runnable</code> 接口不会返回结果或抛出检查异常，但是 <code class="language-plaintext highlighter-rouge">Callable</code> 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <code class="language-plaintext highlighter-rouge">Runnable</code> 接口，这样代码看起来会更加简洁。</p>

<p>工具类 <code class="language-plaintext highlighter-rouge">Executors</code> 可以实现将 <code class="language-plaintext highlighter-rouge">Runnable</code> 对象转换成 <code class="language-plaintext highlighter-rouge">Callable</code> 对象。（<code class="language-plaintext highlighter-rouge">Executors.callable(Runnable task)</code> 或 <code class="language-plaintext highlighter-rouge">Executors.callable(Runnable task, Object result)</code>）。</p>

<p><code class="language-plaintext highlighter-rouge">Runnable.java</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Runnable</span> <span class="o">{</span>
   <span class="cm">/**
    * 被线程执行，没有返回值也无法抛出异常
    */</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Callable.java</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="cm">/**
     * 计算结果，或在无法这样做时抛出异常。
     * @return 计算得出的结果
     * @throws 如果无法计算结果，则抛出异常
     */</span>
    <span class="no">V</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>
<span class="o">}</span>

</code></pre></div></div>

<h4 id="execute-vs-submit"><code class="language-plaintext highlighter-rouge">execute()</code> vs <code class="language-plaintext highlighter-rouge">submit()</code></h4>

<p><code class="language-plaintext highlighter-rouge">execute()</code> 和 <code class="language-plaintext highlighter-rouge">submit()</code>是两种提交任务到线程池的方法，有一些区别：</p>

<ul>
  <li><strong>返回值</strong>：<code class="language-plaintext highlighter-rouge">execute()</code> 方法用于提交不需要返回值的任务。通常用于执行 <code class="language-plaintext highlighter-rouge">Runnable</code> 任务，无法判断任务是否被线程池成功执行。<code class="language-plaintext highlighter-rouge">submit()</code> 方法用于提交需要返回值的任务。可以提交 <code class="language-plaintext highlighter-rouge">Runnable</code> 或 <code class="language-plaintext highlighter-rouge">Callable</code> 任务。<code class="language-plaintext highlighter-rouge">submit()</code> 方法返回一个 <code class="language-plaintext highlighter-rouge">Future</code> 对象，通过这个 <code class="language-plaintext highlighter-rouge">Future</code> 对象可以判断任务是否执行成功，并获取任务的返回值（<code class="language-plaintext highlighter-rouge">get()</code>方法会阻塞当前线程直到任务完成， <code class="language-plaintext highlighter-rouge">get（long timeout，TimeUnit unit）</code>多了一个超时时间，如果在 <code class="language-plaintext highlighter-rouge">timeout</code> 时间内任务还没有执行完，就会抛出 <code class="language-plaintext highlighter-rouge">java.util.concurrent.TimeoutException</code>）。</li>
  <li><strong>异常处理</strong>：在使用 <code class="language-plaintext highlighter-rouge">submit()</code> 方法时，可以通过 <code class="language-plaintext highlighter-rouge">Future</code> 对象处理任务执行过程中抛出的异常；而在使用 <code class="language-plaintext highlighter-rouge">execute()</code> 方法时，异常处理需要通过自定义的 <code class="language-plaintext highlighter-rouge">ThreadFactory</code> （在线程工厂创建线程的时候设置<code class="language-plaintext highlighter-rouge">UncaughtExceptionHandler</code>对象来 处理异常）或 <code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code> 的 <code class="language-plaintext highlighter-rouge">afterExecute()</code> 方法来处理</li>
</ul>

<p>示例 1：使用 <code class="language-plaintext highlighter-rouge">get()</code>方法获取返回值。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 这里只是为了演示使用，推荐使用 `ThreadPoolExecutor` 构造方法来创建线程池。</span>
<span class="nc">ExecutorService</span> <span class="n">executorService</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>

<span class="nc">Future</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">submit</span> <span class="o">=</span> <span class="n">executorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">5000L</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="s">"abc"</span><span class="o">;</span>
<span class="o">});</span>

<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">submit</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="n">executorService</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
</code></pre></div></div>

<p>输出：</p>

<pre><code class="language-plain">abc
</code></pre>

<p>示例 2：使用 <code class="language-plaintext highlighter-rouge">get（long timeout，TimeUnit unit）</code>方法获取返回值。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ExecutorService</span> <span class="n">executorService</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>

<span class="nc">Future</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">submit</span> <span class="o">=</span> <span class="n">executorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">5000L</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="s">"abc"</span><span class="o">;</span>
<span class="o">});</span>

<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">submit</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="n">executorService</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
</code></pre></div></div>

<p>输出：</p>

<pre><code class="language-plain">Exception in thread "main" java.util.concurrent.TimeoutException
  at java.util.concurrent.FutureTask.get(FutureTask.java:205)
</code></pre>

<h4 id="shutdownvsshutdownnow"><code class="language-plaintext highlighter-rouge">shutdown()</code>VS<code class="language-plaintext highlighter-rouge">shutdownNow()</code></h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code class="language-plaintext highlighter-rouge">SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">shutdownNow（）</code></strong> :关闭线程池，线程池的状态变为 <code class="language-plaintext highlighter-rouge">STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li>
</ul>

<h4 id="isterminated-vs-isshutdown"><code class="language-plaintext highlighter-rouge">isTerminated()</code> VS <code class="language-plaintext highlighter-rouge">isShutdown()</code></h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">isShutDown</code></strong> 当调用 <code class="language-plaintext highlighter-rouge">shutdown()</code> 方法后返回为 true。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">isTerminated</code></strong> 当调用 <code class="language-plaintext highlighter-rouge">shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li>
</ul>

<h2 id="几种常见的内置线程池">几种常见的内置线程池</h2>

<h3 id="fixedthreadpool">FixedThreadPool</h3>

<h4 id="介绍">介绍</h4>

<p><code class="language-plaintext highlighter-rouge">FixedThreadPool</code> 被称为可重用固定线程数的线程池。通过 <code class="language-plaintext highlighter-rouge">Executors</code> 类中的相关源代码来看一下相关实现：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="cm">/**
     * 创建一个可重用固定数量线程的线程池
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ExecutorService</span> <span class="nf">newFixedThreadPool</span><span class="o">(</span><span class="kt">int</span> <span class="n">nThreads</span><span class="o">,</span> <span class="nc">ThreadFactory</span> <span class="n">threadFactory</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="n">nThreads</span><span class="o">,</span> <span class="n">nThreads</span><span class="o">,</span>
                                      <span class="mi">0L</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span>
                                      <span class="k">new</span> <span class="nc">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;(),</span>
                                      <span class="n">threadFactory</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>另外还有一个 <code class="language-plaintext highlighter-rouge">FixedThreadPool</code> 的实现方法，和上面的类似，所以这里不多做阐述：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ExecutorService</span> <span class="nf">newFixedThreadPool</span><span class="o">(</span><span class="kt">int</span> <span class="n">nThreads</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="n">nThreads</span><span class="o">,</span> <span class="n">nThreads</span><span class="o">,</span>
                                      <span class="mi">0L</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span>
                                      <span class="k">new</span> <span class="nc">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;());</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>从上面源代码可以看出新创建的 <code class="language-plaintext highlighter-rouge">FixedThreadPool</code> 的 <code class="language-plaintext highlighter-rouge">corePoolSize</code> 和 <code class="language-plaintext highlighter-rouge">maximumPoolSize</code> 都被设置为 <code class="language-plaintext highlighter-rouge">nThreads</code>，这个 <code class="language-plaintext highlighter-rouge">nThreads</code> 参数是我们使用的时候自己传递的。</p>

<p>即使 <code class="language-plaintext highlighter-rouge">maximumPoolSize</code> 的值比 <code class="language-plaintext highlighter-rouge">corePoolSize</code> 大，也至多只会创建 <code class="language-plaintext highlighter-rouge">corePoolSize</code> 个线程。这是因为<code class="language-plaintext highlighter-rouge">FixedThreadPool</code> 使用的是容量为 <code class="language-plaintext highlighter-rouge">Integer.MAX_VALUE</code> 的 <code class="language-plaintext highlighter-rouge">LinkedBlockingQueue</code>（无界队列），队列永远不会被放满。</p>

<h4 id="执行任务过程介绍">执行任务过程介绍</h4>

<p><code class="language-plaintext highlighter-rouge">FixedThreadPool</code> 的 <code class="language-plaintext highlighter-rouge">execute()</code> 方法运行示意图（该图片来源：《Java 并发编程的艺术》）：</p>

<p><img src="./images/java-thread-pool-summary/FixedThreadPool.png" alt="FixedThreadPool的execute()方法运行示意图" /></p>

<p><strong>上图说明：</strong></p>

<ol>
  <li>如果当前运行的线程数小于 <code class="language-plaintext highlighter-rouge">corePoolSize</code>， 如果再来新任务的话，就创建新的线程来执行任务；</li>
  <li>当前运行的线程数等于 <code class="language-plaintext highlighter-rouge">corePoolSize</code> 后， 如果再来新任务的话，会将任务加入 <code class="language-plaintext highlighter-rouge">LinkedBlockingQueue</code>；</li>
  <li>线程池中的线程执行完 手头的任务后，会在循环中反复从 <code class="language-plaintext highlighter-rouge">LinkedBlockingQueue</code> 中获取任务来执行；</li>
</ol>

<h4 id="为什么不推荐使用fixedthreadpool">为什么不推荐使用<code class="language-plaintext highlighter-rouge">FixedThreadPool</code>？</h4>

<p><code class="language-plaintext highlighter-rouge">FixedThreadPool</code> 使用无界队列 <code class="language-plaintext highlighter-rouge">LinkedBlockingQueue</code>（队列的容量为 Integer.MAX_VALUE）作为线程池的工作队列会对线程池带来如下影响：</p>

<ol>
  <li>当线程池中的线程数达到 <code class="language-plaintext highlighter-rouge">corePoolSize</code> 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 <code class="language-plaintext highlighter-rouge">corePoolSize</code>；</li>
  <li>由于使用无界队列时 <code class="language-plaintext highlighter-rouge">maximumPoolSize</code> 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 <code class="language-plaintext highlighter-rouge">FixedThreadPool</code>的源码可以看出创建的 <code class="language-plaintext highlighter-rouge">FixedThreadPool</code> 的 <code class="language-plaintext highlighter-rouge">corePoolSize</code> 和 <code class="language-plaintext highlighter-rouge">maximumPoolSize</code> 被设置为同一个值。</li>
  <li>由于 1 和 2，使用无界队列时 <code class="language-plaintext highlighter-rouge">keepAliveTime</code> 将是一个无效参数；</li>
  <li>运行中的 <code class="language-plaintext highlighter-rouge">FixedThreadPool</code>（未执行 <code class="language-plaintext highlighter-rouge">shutdown()</code>或 <code class="language-plaintext highlighter-rouge">shutdownNow()</code>）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）。</li>
</ol>

<h3 id="singlethreadexecutor">SingleThreadExecutor</h3>

<h4 id="介绍-1">介绍</h4>

<p><code class="language-plaintext highlighter-rouge">SingleThreadExecutor</code> 是只有一个线程的线程池。下面看看<strong>SingleThreadExecutor 的实现：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="cm">/**
     *返回只有一个线程的线程池
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ExecutorService</span> <span class="nf">newSingleThreadExecutor</span><span class="o">(</span><span class="nc">ThreadFactory</span> <span class="n">threadFactory</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">FinalizableDelegatedExecutorService</span>
            <span class="o">(</span><span class="k">new</span> <span class="nc">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span>
                                    <span class="mi">0L</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span>
                                    <span class="k">new</span> <span class="nc">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;(),</span>
                                    <span class="n">threadFactory</span><span class="o">));</span>
    <span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ExecutorService</span> <span class="nf">newSingleThreadExecutor</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">FinalizableDelegatedExecutorService</span>
            <span class="o">(</span><span class="k">new</span> <span class="nc">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span>
                                    <span class="mi">0L</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span>
                                    <span class="k">new</span> <span class="nc">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;()));</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>从上面源代码可以看出新创建的 <code class="language-plaintext highlighter-rouge">SingleThreadExecutor</code> 的 <code class="language-plaintext highlighter-rouge">corePoolSize</code> 和 <code class="language-plaintext highlighter-rouge">maximumPoolSize</code> 都被设置为 1，其他参数和 <code class="language-plaintext highlighter-rouge">FixedThreadPool</code> 相同。</p>

<h4 id="执行任务过程介绍-1">执行任务过程介绍</h4>

<p><code class="language-plaintext highlighter-rouge">SingleThreadExecutor</code> 的运行示意图（该图片来源：《Java 并发编程的艺术》）：</p>

<p><img src="./images/java-thread-pool-summary/SingleThreadExecutor.png" alt="SingleThreadExecutor的运行示意图" /></p>

<p><strong>上图说明</strong> :</p>

<ol>
  <li>如果当前运行的线程数少于 <code class="language-plaintext highlighter-rouge">corePoolSize</code>，则创建一个新的线程执行任务；</li>
  <li>当前线程池中有一个运行的线程后，将任务加入 <code class="language-plaintext highlighter-rouge">LinkedBlockingQueue</code></li>
  <li>线程执行完当前的任务后，会在循环中反复从<code class="language-plaintext highlighter-rouge">LinkedBlockingQueue</code> 中获取任务来执行；</li>
</ol>

<h4 id="为什么不推荐使用singlethreadexecutor">为什么不推荐使用<code class="language-plaintext highlighter-rouge">SingleThreadExecutor</code>？</h4>

<p><code class="language-plaintext highlighter-rouge">SingleThreadExecutor</code> 和 <code class="language-plaintext highlighter-rouge">FixedThreadPool</code> 一样，使用的都是容量为 <code class="language-plaintext highlighter-rouge">Integer.MAX_VALUE</code> 的 <code class="language-plaintext highlighter-rouge">LinkedBlockingQueue</code>（无界队列）作为线程池的工作队列。<code class="language-plaintext highlighter-rouge">SingleThreadExecutor</code> 使用无界队列作为线程池的工作队列会对线程池带来的影响与 <code class="language-plaintext highlighter-rouge">FixedThreadPool</code> 相同。说简单点，就是可能会导致 OOM。</p>

<h3 id="cachedthreadpool">CachedThreadPool</h3>

<h4 id="介绍-2">介绍</h4>

<p><code class="language-plaintext highlighter-rouge">CachedThreadPool</code> 是一个会根据需要创建新线程的线程池。下面通过源码来看看 <code class="language-plaintext highlighter-rouge">CachedThreadPool</code> 的实现：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cm">/**
     * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ExecutorService</span> <span class="nf">newCachedThreadPool</span><span class="o">(</span><span class="nc">ThreadFactory</span> <span class="n">threadFactory</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">,</span>
                                      <span class="mi">60L</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">,</span>
                                      <span class="k">new</span> <span class="nc">SynchronousQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;(),</span>
                                      <span class="n">threadFactory</span><span class="o">);</span>
    <span class="o">}</span>

</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ExecutorService</span> <span class="nf">newCachedThreadPool</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">,</span>
                                      <span class="mi">60L</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">,</span>
                                      <span class="k">new</span> <span class="nc">SynchronousQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;());</span>
    <span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">CachedThreadPool</code> 的<code class="language-plaintext highlighter-rouge">corePoolSize</code> 被设置为空（0），<code class="language-plaintext highlighter-rouge">maximumPoolSize</code>被设置为 <code class="language-plaintext highlighter-rouge">Integer.MAX.VALUE</code>，即它是无界的，这也就意味着如果主线程提交任务的速度高于 <code class="language-plaintext highlighter-rouge">maximumPool</code> 中线程处理任务的速度时，<code class="language-plaintext highlighter-rouge">CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</p>

<h4 id="执行任务过程介绍-2">执行任务过程介绍</h4>

<p><code class="language-plaintext highlighter-rouge">CachedThreadPool</code> 的 <code class="language-plaintext highlighter-rouge">execute()</code> 方法的执行示意图（该图片来源：《Java 并发编程的艺术》）：</p>

<p><img src="./images/java-thread-pool-summary/CachedThreadPool-execute.png" alt="CachedThreadPool的execute()方法的执行示意图" /></p>

<p><strong>上图说明：</strong></p>

<ol>
  <li>首先执行 <code class="language-plaintext highlighter-rouge">SynchronousQueue.offer(Runnable task)</code> 提交任务到任务队列。如果当前 <code class="language-plaintext highlighter-rouge">maximumPool</code> 中有闲线程正在执行 <code class="language-plaintext highlighter-rouge">SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>，那么主线程执行 offer 操作与空闲线程执行的 <code class="language-plaintext highlighter-rouge">poll</code> 操作配对成功，主线程把任务交给空闲线程执行，<code class="language-plaintext highlighter-rouge">execute()</code>方法执行完成，否则执行下面的步骤 2；</li>
  <li>当初始 <code class="language-plaintext highlighter-rouge">maximumPool</code> 为空，或者 <code class="language-plaintext highlighter-rouge">maximumPool</code> 中没有空闲线程时，将没有线程执行 <code class="language-plaintext highlighter-rouge">SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>。这种情况下，步骤 1 将失败，此时 <code class="language-plaintext highlighter-rouge">CachedThreadPool</code> 会创建新线程执行任务，execute 方法执行完成；</li>
</ol>

<h4 id="为什么不推荐使用cachedthreadpool">为什么不推荐使用<code class="language-plaintext highlighter-rouge">CachedThreadPool</code>？</h4>

<p><code class="language-plaintext highlighter-rouge">CachedThreadPool</code> 使用的是同步队列 <code class="language-plaintext highlighter-rouge">SynchronousQueue</code>, 允许创建的线程数量为 <code class="language-plaintext highlighter-rouge">Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</p>

<h3 id="scheduledthreadpool">ScheduledThreadPool</h3>

<h4 id="介绍-3">介绍</h4>

<p><code class="language-plaintext highlighter-rouge">ScheduledThreadPool</code> 用来在给定的延迟后运行任务或者定期执行任务。这个在实际项目中基本不会被用到，也不推荐使用，大家只需要简单了解一下即可。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="nc">ScheduledExecutorService</span> <span class="nf">newScheduledThreadPool</span><span class="o">(</span><span class="kt">int</span> <span class="n">corePoolSize</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">ScheduledThreadPoolExecutor</span><span class="o">(</span><span class="n">corePoolSize</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="nf">ScheduledThreadPoolExecutor</span><span class="o">(</span><span class="kt">int</span> <span class="n">corePoolSize</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">corePoolSize</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="no">NANOSECONDS</span><span class="o">,</span>
          <span class="k">new</span> <span class="nf">DelayedWorkQueue</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ScheduledThreadPool</code> 是通过 <code class="language-plaintext highlighter-rouge">ScheduledThreadPoolExecutor</code> 创建的，使用的<code class="language-plaintext highlighter-rouge">DelayedWorkQueue</code>（延迟阻塞队列）作为线程池的任务队列。</p>

<p><code class="language-plaintext highlighter-rouge">DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code class="language-plaintext highlighter-rouge">DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 <code class="language-plaintext highlighter-rouge">Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</p>

<p><code class="language-plaintext highlighter-rouge">ScheduledThreadPoolExecutor</code> 继承了 <code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code>，所以创建 <code class="language-plaintext highlighter-rouge">ScheduledThreadExecutor</code> 本质也是创建一个 <code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code> 线程池，只是传入的参数不相同。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ScheduledThreadPoolExecutor</span>
        <span class="kd">extends</span> <span class="nc">ThreadPoolExecutor</span>
        <span class="kd">implements</span> <span class="nc">ScheduledExecutorService</span>
</code></pre></div></div>

<h4 id="scheduledthreadpoolexecutor-和-timer-对比">ScheduledThreadPoolExecutor 和 Timer 对比</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Timer</code> 对系统时钟的变化敏感，<code class="language-plaintext highlighter-rouge">ScheduledThreadPoolExecutor</code>不是；</li>
  <li><code class="language-plaintext highlighter-rouge">Timer</code> 只有一个执行线程，因此长时间运行的任务可以延迟其他任务。 <code class="language-plaintext highlighter-rouge">ScheduledThreadPoolExecutor</code> 可以配置任意数量的线程。 此外，如果你想（通过提供 <code class="language-plaintext highlighter-rouge">ThreadFactory</code>），你可以完全控制创建的线程;</li>
  <li>在<code class="language-plaintext highlighter-rouge">TimerTask</code> 中抛出的运行时异常会杀死一个线程，从而导致 <code class="language-plaintext highlighter-rouge">Timer</code> 死机即计划任务将不再运行。<code class="language-plaintext highlighter-rouge">ScheduledThreadExecutor</code> 不仅捕获运行时异常，还允许您在需要时处理它们（通过重写 <code class="language-plaintext highlighter-rouge">afterExecute</code> 方法<code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code>）。抛出异常的任务将被取消，但其他任务将继续运行。</li>
</ul>

<p>关于定时任务的详细介绍，可以看这篇文章：<a href="https://javaguide.cn/system-design/schedule-task.html">Java 定时任务详解</a> 。</p>

<h2 id="线程池最佳实践">线程池最佳实践</h2>

<p><a href="https://javaguide.cn/java/concurrent/java-thread-pool-best-practices.html">Java 线程池最佳实践</a>这篇文章总结了一些使用线程池的时候应该注意的东西，实际项目使用线程池之前可以看看。</p>

<h2 id="参考">参考</h2>

<ul>
  <li>《Java 并发编程的艺术》</li>
  <li><a href="https://www.journaldev.com/2340/java-scheduler-scheduledexecutorservice-scheduledthreadpoolexecutor-example" title="Java Scheduler ScheduledExecutorService ScheduledThreadPoolExecutor Example">Java Scheduler ScheduledExecutorService ScheduledThreadPoolExecutor Example</a></li>
  <li><a href="https://examples.javacodegeeks.com/core-java/util/concurrent/scheduledthreadpoolexecutor/java-util-concurrent-scheduledthreadpoolexecutor-example/" title="java.util.concurrent.ScheduledThreadPoolExecutor Example">java.util.concurrent.ScheduledThreadPoolExecutor Example</a></li>
  <li><a href="https://www.journaldev.com/1069/threadpoolexecutor-java-thread-pool-example-executorservice" title="ThreadPoolExecutor – Java Thread Pool Example">ThreadPoolExecutor – Java Thread Pool Example</a></li>
</ul>

<!-- @include: @article-footer.snippet.md -->
