<p>实际项目中，一个接口可能需要同时获取多种不同的数据，然后再汇总返回，这种场景还是挺常见的。举个例子：用户请求获取订单信息，可能需要同时获取用户信息、商品详情、物流信息、商品推荐等数据。</p>

<p>如果是串行（按顺序依次执行每个任务）执行的话，接口的响应速度会非常慢。考虑到这些任务之间有大部分都是 <strong>无前后顺序关联</strong> 的，可以 <strong>并行执行</strong> ，就比如说调用获取商品详情的时候，可以同时调用获取物流信息。通过并行执行多个任务的方式，接口的响应速度会得到大幅优化。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/serial-to-parallel.png" alt="" /></p>

<p>对于存在前后调用顺序关系的任务，可以进行任务编排。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/serial-to-parallel2.png" alt="" /></p>

<ol>
  <li>获取用户信息之后，才能调用商品详情和物流信息接口。</li>
  <li>成功获取商品详情和物流信息之后，才能调用商品推荐接口。</li>
</ol>

<p>可能会用到多线程异步任务编排的场景（这里只是举例，数据不一定是一次返回，可能会对接口进行拆分）：</p>

<ol>
  <li>首页：例如技术社区的首页可能需要同时获取文章推荐列表、广告栏、文章排行榜、热门话题等信息。</li>
  <li>详情页：例如技术社区的文章详情页可能需要同时获取作者信息、文章详情、文章评论等信息。</li>
  <li>统计模块：例如技术社区的后台统计模块可能需要同时获取粉丝数汇总、文章数据（阅读量、评论量、收藏量）汇总等信息。</li>
</ol>

<p>对于 Java 程序来说，Java 8 才被引入的 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 可以帮助我们来做多个任务的编排，功能非常强大。</p>

<p>这篇文章是 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 的简单入门，带大家看看 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 常用的 API。</p>

<h2 id="future-介绍">Future 介绍</h2>

<p><code class="language-plaintext highlighter-rouge">Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 <code class="language-plaintext highlighter-rouge">Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p>

<p>这其实就是多线程中经典的 <strong>Future 模式</strong>，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p>

<p>在 Java 中，<code class="language-plaintext highlighter-rouge">Future</code> 类只是一个泛型接口，位于 <code class="language-plaintext highlighter-rouge">java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p>

<ul>
  <li>取消任务；</li>
  <li>判断任务是否被取消;</li>
  <li>判断任务是否已经执行完成;</li>
  <li>获取任务执行结果。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// V 代表了Future执行的任务返回值的类型</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Future</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="c1">// 取消任务执行</span>
    <span class="c1">// 成功取消返回 true，否则返回 false</span>
    <span class="kt">boolean</span> <span class="nf">cancel</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">mayInterruptIfRunning</span><span class="o">);</span>
    <span class="c1">// 判断任务是否被取消</span>
    <span class="kt">boolean</span> <span class="nf">isCancelled</span><span class="o">();</span>
    <span class="c1">// 判断任务是否已经执行完成</span>
    <span class="kt">boolean</span> <span class="nf">isDone</span><span class="o">();</span>
    <span class="c1">// 获取任务执行结果</span>
    <span class="no">V</span> <span class="nf">get</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span><span class="o">,</span> <span class="nc">ExecutionException</span><span class="o">;</span>
    <span class="c1">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span>
    <span class="no">V</span> <span class="nf">get</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="nc">TimeUnit</span> <span class="n">unit</span><span class="o">)</span>

        <span class="kd">throws</span> <span class="nc">InterruptedException</span><span class="o">,</span> <span class="nc">ExecutionException</span><span class="o">,</span> <span class="nc">TimeoutExceptio</span>

<span class="o">}</span>
</code></pre></div></div>

<p>简单理解就是：我有一个任务，提交给了 <code class="language-plaintext highlighter-rouge">Future</code> 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 <code class="language-plaintext highlighter-rouge">Future</code> 那里直接取出任务执行结果。</p>

<h2 id="completablefuture-介绍">CompletableFuture 介绍</h2>

<p><code class="language-plaintext highlighter-rouge">Future</code> 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 <code class="language-plaintext highlighter-rouge">get()</code> 方法为阻塞调用。</p>

<p>Java 8 才被引入<code class="language-plaintext highlighter-rouge">CompletableFuture</code> 类可以解决<code class="language-plaintext highlighter-rouge">Future</code> 的这些缺陷。<code class="language-plaintext highlighter-rouge">CompletableFuture</code> 除了提供了更为好用和强大的 <code class="language-plaintext highlighter-rouge">Future</code> 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</p>

<p>下面我们来简单看看 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 类的定义。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Future</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;,</span> <span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<p>可以看到，<code class="language-plaintext highlighter-rouge">CompletableFuture</code> 同时实现了 <code class="language-plaintext highlighter-rouge">Future</code> 和 <code class="language-plaintext highlighter-rouge">CompletionStage</code> 接口。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/completablefuture-class-diagram.jpg" alt="" /></p>

<p><code class="language-plaintext highlighter-rouge">CompletionStage</code> 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。</p>

<p><code class="language-plaintext highlighter-rouge">CompletableFuture</code> 除了提供了更为好用和强大的 <code class="language-plaintext highlighter-rouge">Future</code> 特性之外，还提供了函数式编程的能力。</p>

<p><img src="https://oss.javaguide.cn/javaguide/image-20210902092441434.png" alt="" /></p>

<p><code class="language-plaintext highlighter-rouge">Future</code> 接口有 5 个方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">boolean cancel(boolean mayInterruptIfRunning)</code>：尝试取消执行任务。</li>
  <li><code class="language-plaintext highlighter-rouge">boolean isCancelled()</code>：判断任务是否被取消。</li>
  <li><code class="language-plaintext highlighter-rouge">boolean isDone()</code>：判断任务是否已经被执行完成。</li>
  <li><code class="language-plaintext highlighter-rouge">get()</code>：等待任务执行完成并获取运算结果。</li>
  <li><code class="language-plaintext highlighter-rouge">get(long timeout, TimeUnit unit)</code>：多了一个超时时间。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">CompletionStage</code> 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。</p>

<p><code class="language-plaintext highlighter-rouge">CompletionStage</code> 接口中的方法比较多，<code class="language-plaintext highlighter-rouge">CompletableFuture</code> 的函数式能力就是这个接口赋予的。从这个接口的方法参数你就可以发现其大量使用了 Java8 引入的函数式编程。</p>

<p><img src="https://oss.javaguide.cn/javaguide/image-20210902093026059.png" alt="" /></p>

<p>由于方法众多，所以这里不能一一讲解，下文中我会介绍大部分常见方法的使用。</p>

<h2 id="completablefuture-常见操作">CompletableFuture 常见操作</h2>

<h3 id="创建-completablefuture">创建 CompletableFuture</h3>

<p>常见的创建 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 对象的方法如下：</p>

<ol>
  <li>通过 new 关键字。</li>
  <li>基于 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 自带的静态工厂方法：<code class="language-plaintext highlighter-rouge">runAsync()</code>、<code class="language-plaintext highlighter-rouge">supplyAsync()</code> 。</li>
</ol>

<h4 id="new-关键字">new 关键字</h4>

<p>通过 new 关键字创建 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 对象这种使用方式可以看作是将 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 当做 <code class="language-plaintext highlighter-rouge">Future</code> 来使用。</p>

<p>我在我的开源项目 <a href="https://github.com/Snailclimb/guide-rpc-framework">guide-rpc-framework</a> 中就是这种方式创建的 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 对象。</p>

<p>下面咱们来看一个简单的案例。</p>

<p>我们通过创建了一个结果值类型为 <code class="language-plaintext highlighter-rouge">RpcResponse&lt;Object&gt;</code> 的 <code class="language-plaintext highlighter-rouge">CompletableFuture</code>，你可以把 <code class="language-plaintext highlighter-rouge">resultFuture</code> 看作是异步运算结果的载体。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">RpcResponse</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="n">resultFuture</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CompletableFuture</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>

<p>假设在未来的某个时刻，我们得到了最终的结果。这时，我们可以调用 <code class="language-plaintext highlighter-rouge">complete()</code> 方法为其传入结果，这表示 <code class="language-plaintext highlighter-rouge">resultFuture</code> 已经被完成了。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// complete() 方法只能调用一次，后续调用将被忽略。</span>
<span class="n">resultFuture</span><span class="o">.</span><span class="na">complete</span><span class="o">(</span><span class="n">rpcResponse</span><span class="o">);</span>
</code></pre></div></div>

<p>你可以通过 <code class="language-plaintext highlighter-rouge">isDone()</code> 方法来检查是否已经完成。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isDone</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">result</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>获取异步计算的结果也非常简单，直接调用 <code class="language-plaintext highlighter-rouge">get()</code> 方法即可。调用 <code class="language-plaintext highlighter-rouge">get()</code> 方法的线程会阻塞直到 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成运算。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rpcResponse</span> <span class="o">=</span> <span class="n">completableFuture</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</code></pre></div></div>

<p>如果你已经知道计算的结果的话，可以使用静态方法 <code class="language-plaintext highlighter-rouge">completedFuture()</code> 来创建 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">completedFuture</span><span class="o">(</span><span class="s">"hello!"</span><span class="o">);</span>
<span class="n">assertEquals</span><span class="o">(</span><span class="s">"hello!"</span><span class="o">,</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">completedFuture()</code> 方法底层调用的是带参数的 new 方法，只不过，这个方法不对外暴露。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">completedFuture</span><span class="o">(</span><span class="no">U</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;((</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="no">NIL</span> <span class="o">:</span> <span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="静态工厂方法">静态工厂方法</h4>

<p>这两个方法可以帮助我们封装计算逻辑。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">supplyAsync</span><span class="o">(</span><span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">);</span>
<span class="c1">// 使用自定义线程池(推荐)</span>
<span class="kd">static</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">supplyAsync</span><span class="o">(</span><span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">,</span> <span class="nc">Executor</span> <span class="n">executor</span><span class="o">);</span>
<span class="kd">static</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">runAsync</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">runnable</span><span class="o">);</span>
<span class="c1">// 使用自定义线程池(推荐)</span>
<span class="kd">static</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">runAsync</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">runnable</span><span class="o">,</span> <span class="nc">Executor</span> <span class="n">executor</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">runAsync()</code> 方法接受的参数是 <code class="language-plaintext highlighter-rouge">Runnable</code> ，这是一个函数式接口，不允许返回值。当你需要异步操作且不关心返回结果的时候可以使用 <code class="language-plaintext highlighter-rouge">runAsync()</code> 方法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">supplyAsync()</code> 方法接受的参数是 <code class="language-plaintext highlighter-rouge">Supplier&lt;U&gt;</code> ，这也是一个函数式接口，<code class="language-plaintext highlighter-rouge">U</code> 是返回结果值的类型。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="cm">/**
     * Gets a result.
     *
     * @return a result
     */</span>
    <span class="no">T</span> <span class="nf">get</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>当你需要异步操作且关心返回结果的时候,可以使用 <code class="language-plaintext highlighter-rouge">supplyAsync()</code> 方法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">runAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello!"</span><span class="o">));</span>
<span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">();</span><span class="c1">// 输出 "hello!"</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future2</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="s">"hello!"</span><span class="o">);</span>
<span class="n">assertEquals</span><span class="o">(</span><span class="s">"hello!"</span><span class="o">,</span> <span class="n">future2</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
</code></pre></div></div>

<h3 id="处理异步结算的结果">处理异步结算的结果</h3>

<p>当我们获取到异步计算的结果之后，还可以对其进行进一步的处理，比较常用的方法有下面几个：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">thenApply()</code></li>
  <li><code class="language-plaintext highlighter-rouge">thenAccept()</code></li>
  <li><code class="language-plaintext highlighter-rouge">thenRun()</code></li>
  <li><code class="language-plaintext highlighter-rouge">whenComplete()</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">thenApply()</code> 方法接受一个 <code class="language-plaintext highlighter-rouge">Function</code> 实例，用它来处理结果。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 沿用上一个任务的线程池</span>
<span class="kd">public</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">thenApply</span><span class="o">(</span>
    <span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,?</span> <span class="kd">extends</span> <span class="no">U</span><span class="o">&gt;</span> <span class="n">fn</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">uniApplyStage</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">fn</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">//使用默认的 ForkJoinPool 线程池（不推荐）</span>
<span class="kd">public</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">thenApplyAsync</span><span class="o">(</span>
    <span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,?</span> <span class="kd">extends</span> <span class="no">U</span><span class="o">&gt;</span> <span class="n">fn</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">uniApplyStage</span><span class="o">(</span><span class="n">defaultExecutor</span><span class="o">(),</span> <span class="n">fn</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 使用自定义线程池(推荐)</span>
<span class="kd">public</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">thenApplyAsync</span><span class="o">(</span>
    <span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,?</span> <span class="kd">extends</span> <span class="no">U</span><span class="o">&gt;</span> <span class="n">fn</span><span class="o">,</span> <span class="nc">Executor</span> <span class="n">executor</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">uniApplyStage</span><span class="o">(</span><span class="n">screenExecutor</span><span class="o">(</span><span class="n">executor</span><span class="o">),</span> <span class="n">fn</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">thenApply()</code> 方法使用示例如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">completedFuture</span><span class="o">(</span><span class="s">"hello!"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"world!"</span><span class="o">);</span>
<span class="n">assertEquals</span><span class="o">(</span><span class="s">"hello!world!"</span><span class="o">,</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
<span class="c1">// 这次调用将被忽略。</span>
<span class="n">future</span><span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"nice!"</span><span class="o">);</span>
<span class="n">assertEquals</span><span class="o">(</span><span class="s">"hello!world!"</span><span class="o">,</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
</code></pre></div></div>

<p>你还可以进行 <strong>流式调用</strong>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">completedFuture</span><span class="o">(</span><span class="s">"hello!"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"world!"</span><span class="o">).</span><span class="na">thenApply</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"nice!"</span><span class="o">);</span>
<span class="n">assertEquals</span><span class="o">(</span><span class="s">"hello!world!nice!"</span><span class="o">,</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
</code></pre></div></div>

<p><strong>如果你不需要从回调函数中获取返回结果，可以使用 <code class="language-plaintext highlighter-rouge">thenAccept()</code> 或者 <code class="language-plaintext highlighter-rouge">thenRun()</code>。这两个方法的区别在于 <code class="language-plaintext highlighter-rouge">thenRun()</code> 不能访问异步计算的结果。</strong></p>

<p><code class="language-plaintext highlighter-rouge">thenAccept()</code> 方法的参数是 <code class="language-plaintext highlighter-rouge">Consumer&lt;? super T&gt;</code> 。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">thenAccept</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">uniAcceptStage</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">action</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">thenAcceptAsync</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">uniAcceptStage</span><span class="o">(</span><span class="n">defaultExecutor</span><span class="o">(),</span> <span class="n">action</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">thenAcceptAsync</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">,</span>
                                               <span class="nc">Executor</span> <span class="n">executor</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">uniAcceptStage</span><span class="o">(</span><span class="n">screenExecutor</span><span class="o">(</span><span class="n">executor</span><span class="o">),</span> <span class="n">action</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>顾名思义，<code class="language-plaintext highlighter-rouge">Consumer</code> 属于消费型接口，它可以接收 1 个输入对象然后进行“消费”。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Consumer</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>

    <span class="k">default</span> <span class="nc">Consumer</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">andThen</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">after</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">after</span><span class="o">);</span>
        <span class="k">return</span> <span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">accept</span><span class="o">(</span><span class="n">t</span><span class="o">);</span> <span class="n">after</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">t</span><span class="o">);</span> <span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">thenRun()</code> 的方法是的参数是 <code class="language-plaintext highlighter-rouge">Runnable</code> 。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">thenRun</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">uniRunStage</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">action</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">thenRunAsync</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">uniRunStage</span><span class="o">(</span><span class="n">defaultExecutor</span><span class="o">(),</span> <span class="n">action</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">thenRunAsync</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">action</span><span class="o">,</span>
                                            <span class="nc">Executor</span> <span class="n">executor</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">uniRunStage</span><span class="o">(</span><span class="n">screenExecutor</span><span class="o">(</span><span class="n">executor</span><span class="o">),</span> <span class="n">action</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">thenAccept()</code> 和 <code class="language-plaintext highlighter-rouge">thenRun()</code> 使用示例如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">completedFuture</span><span class="o">(</span><span class="s">"hello!"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"world!"</span><span class="o">).</span><span class="na">thenApply</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"nice!"</span><span class="o">).</span><span class="na">thenAccept</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span><span class="c1">//hello!world!nice!</span>

<span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">completedFuture</span><span class="o">(</span><span class="s">"hello!"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"world!"</span><span class="o">).</span><span class="na">thenApply</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"nice!"</span><span class="o">).</span><span class="na">thenRun</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello!"</span><span class="o">));</span><span class="c1">//hello!</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">whenComplete()</code> 的方法的参数是 <code class="language-plaintext highlighter-rouge">BiConsumer&lt;? super T, ? super Throwable&gt;</code> 。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">whenComplete</span><span class="o">(</span>
    <span class="nc">BiConsumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">super</span> <span class="nc">Throwable</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">uniWhenCompleteStage</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">action</span><span class="o">);</span>
<span class="o">}</span>


<span class="kd">public</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">whenCompleteAsync</span><span class="o">(</span>
    <span class="nc">BiConsumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">super</span> <span class="nc">Throwable</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">uniWhenCompleteStage</span><span class="o">(</span><span class="n">defaultExecutor</span><span class="o">(),</span> <span class="n">action</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 使用自定义线程池(推荐)</span>
<span class="kd">public</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">whenCompleteAsync</span><span class="o">(</span>
    <span class="nc">BiConsumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">super</span> <span class="nc">Throwable</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">,</span> <span class="nc">Executor</span> <span class="n">executor</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">uniWhenCompleteStage</span><span class="o">(</span><span class="n">screenExecutor</span><span class="o">(</span><span class="n">executor</span><span class="o">),</span> <span class="n">action</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>相对于 <code class="language-plaintext highlighter-rouge">Consumer</code> ， <code class="language-plaintext highlighter-rouge">BiConsumer</code> 可以接收 2 个输入对象然后进行“消费”。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">BiConsumer</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">U</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">,</span> <span class="no">U</span> <span class="n">u</span><span class="o">);</span>

    <span class="k">default</span> <span class="nc">BiConsumer</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">U</span><span class="o">&gt;</span> <span class="nf">andThen</span><span class="o">(</span><span class="nc">BiConsumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">super</span> <span class="no">U</span><span class="o">&gt;</span> <span class="n">after</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">after</span><span class="o">);</span>

        <span class="k">return</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">accept</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
            <span class="n">after</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
        <span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">whenComplete()</code> 使用示例如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="s">"hello!"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">whenComplete</span><span class="o">((</span><span class="n">res</span><span class="o">,</span> <span class="n">ex</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="c1">// res 代表返回的结果</span>
            <span class="c1">// ex 的类型为 Throwable ，代表抛出的异常</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
            <span class="c1">// 这里没有抛出异常所有为 null</span>
            <span class="n">assertNull</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>
        <span class="o">});</span>
<span class="n">assertEquals</span><span class="o">(</span><span class="s">"hello!"</span><span class="o">,</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
</code></pre></div></div>

<h3 id="异常处理">异常处理</h3>

<p>你可以通过 <code class="language-plaintext highlighter-rouge">handle()</code> 方法来处理任务执行过程中可能出现的抛出异常的情况。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">handle</span><span class="o">(</span>
    <span class="nc">BiFunction</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,</span> <span class="nc">Throwable</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">U</span><span class="o">&gt;</span> <span class="n">fn</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">uniHandleStage</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">fn</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">handleAsync</span><span class="o">(</span>
    <span class="nc">BiFunction</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,</span> <span class="nc">Throwable</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">U</span><span class="o">&gt;</span> <span class="n">fn</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">uniHandleStage</span><span class="o">(</span><span class="n">defaultExecutor</span><span class="o">(),</span> <span class="n">fn</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">handleAsync</span><span class="o">(</span>
    <span class="nc">BiFunction</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,</span> <span class="nc">Throwable</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">U</span><span class="o">&gt;</span> <span class="n">fn</span><span class="o">,</span> <span class="nc">Executor</span> <span class="n">executor</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">uniHandleStage</span><span class="o">(</span><span class="n">screenExecutor</span><span class="o">(</span><span class="n">executor</span><span class="o">),</span> <span class="n">fn</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>示例代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span>
        <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Computation error!"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="s">"hello!"</span><span class="o">;</span>
<span class="o">}).</span><span class="na">handle</span><span class="o">((</span><span class="n">res</span><span class="o">,</span> <span class="n">ex</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="c1">// res 代表返回的结果</span>
    <span class="c1">// ex 的类型为 Throwable ，代表抛出的异常</span>
    <span class="k">return</span> <span class="n">res</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">res</span> <span class="o">:</span> <span class="s">"world!"</span><span class="o">;</span>
<span class="o">});</span>
<span class="n">assertEquals</span><span class="o">(</span><span class="s">"world!"</span><span class="o">,</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
</code></pre></div></div>

<p>你还可以通过 <code class="language-plaintext highlighter-rouge">exceptionally()</code> 方法来处理异常情况。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span>
        <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Computation error!"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="s">"hello!"</span><span class="o">;</span>
<span class="o">}).</span><span class="na">exceptionally</span><span class="o">(</span><span class="n">ex</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ex</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span><span class="c1">// CompletionException</span>
    <span class="k">return</span> <span class="s">"world!"</span><span class="o">;</span>
<span class="o">});</span>
<span class="n">assertEquals</span><span class="o">(</span><span class="s">"world!"</span><span class="o">,</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
</code></pre></div></div>

<p>如果你想让 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 的结果就是异常的话，可以使用 <code class="language-plaintext highlighter-rouge">completeExceptionally()</code> 方法为其赋值。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">completableFuture</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CompletableFuture</span><span class="o">&lt;&gt;();</span>
<span class="c1">// ...</span>
<span class="n">completableFuture</span><span class="o">.</span><span class="na">completeExceptionally</span><span class="o">(</span>
  <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Calculation failed!"</span><span class="o">));</span>
<span class="c1">// ...</span>
<span class="n">completableFuture</span><span class="o">.</span><span class="na">get</span><span class="o">();</span> <span class="c1">// ExecutionException</span>
</code></pre></div></div>

<h3 id="组合-completablefuture">组合 CompletableFuture</h3>

<p>你可以使用 <code class="language-plaintext highlighter-rouge">thenCompose()</code> 按顺序链接两个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 对象，实现异步的任务链。它的作用是将前一个任务的返回结果作为下一个任务的输入参数，从而形成一个依赖关系。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">thenCompose</span><span class="o">(</span>
    <span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;&gt;</span> <span class="n">fn</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">uniComposeStage</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">fn</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">thenComposeAsync</span><span class="o">(</span>
    <span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;&gt;</span> <span class="n">fn</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">uniComposeStage</span><span class="o">(</span><span class="n">defaultExecutor</span><span class="o">(),</span> <span class="n">fn</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">thenComposeAsync</span><span class="o">(</span>
    <span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;&gt;</span> <span class="n">fn</span><span class="o">,</span>
    <span class="nc">Executor</span> <span class="n">executor</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">uniComposeStage</span><span class="o">(</span><span class="n">screenExecutor</span><span class="o">(</span><span class="n">executor</span><span class="o">),</span> <span class="n">fn</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">thenCompose()</code> 方法会使用示例如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span>
        <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="s">"hello!"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">thenCompose</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"world!"</span><span class="o">));</span>
<span class="n">assertEquals</span><span class="o">(</span><span class="s">"hello!world!"</span><span class="o">,</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
</code></pre></div></div>

<p>在实际开发中，这个方法还是非常有用的。比如说，task1 和 task2 都是异步执行的，但 task1 必须执行完成后才能开始执行 task2（task2 依赖 task1 的执行结果）。</p>

<p>和 <code class="language-plaintext highlighter-rouge">thenCompose()</code> 方法类似的还有 <code class="language-plaintext highlighter-rouge">thenCombine()</code> 方法， 它同样可以组合两个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 对象。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">completableFuture</span>
        <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="s">"hello!"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">thenCombine</span><span class="o">(</span><span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(</span>
                <span class="o">()</span> <span class="o">-&gt;</span> <span class="s">"world!"</span><span class="o">),</span> <span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="o">)</span>
        <span class="o">.</span><span class="na">thenCompose</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"nice!"</span><span class="o">));</span>
<span class="n">assertEquals</span><span class="o">(</span><span class="s">"hello!world!nice!"</span><span class="o">,</span> <span class="n">completableFuture</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
</code></pre></div></div>

<p><strong>那 <code class="language-plaintext highlighter-rouge">thenCompose()</code> 和 <code class="language-plaintext highlighter-rouge">thenCombine()</code> 有什么区别呢？</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">thenCompose()</code> 可以链接两个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 对象，并将前一个任务的返回结果作为下一个任务的参数，它们之间存在着先后顺序。</li>
  <li><code class="language-plaintext highlighter-rouge">thenCombine()</code> 会在两个任务都执行完成后，把两个任务的结果合并。两个任务是并行执行的，它们之间并没有先后依赖顺序。</li>
</ul>

<p>除了 <code class="language-plaintext highlighter-rouge">thenCompose()</code> 和 <code class="language-plaintext highlighter-rouge">thenCombine()</code> 之外， 还有一些其他的组合 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 的方法用于实现不同的效果，满足不同的业务需求。</p>

<p>例如，如果我们想要实现 task1 和 task2 中的任意一个任务执行完后就执行 task3 的话，可以使用 <code class="language-plaintext highlighter-rouge">acceptEither()</code>。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">acceptEither</span><span class="o">(</span>
    <span class="nc">CompletionStage</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">other</span><span class="o">,</span> <span class="nc">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">orAcceptStage</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">other</span><span class="o">,</span> <span class="n">action</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">acceptEitherAsync</span><span class="o">(</span>
    <span class="nc">CompletionStage</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">other</span><span class="o">,</span> <span class="nc">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">orAcceptStage</span><span class="o">(</span><span class="n">asyncPool</span><span class="o">,</span> <span class="n">other</span><span class="o">,</span> <span class="n">action</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>简单举一个例子：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">task</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"任务1开始执行，当前时间："</span> <span class="o">+</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">());</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"任务1执行完毕，当前时间："</span> <span class="o">+</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">());</span>
    <span class="k">return</span> <span class="s">"task1"</span><span class="o">;</span>
<span class="o">});</span>

<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">task2</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"任务2开始执行，当前时间："</span> <span class="o">+</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">());</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"任务2执行完毕，当前时间："</span> <span class="o">+</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">());</span>
    <span class="k">return</span> <span class="s">"task2"</span><span class="o">;</span>
<span class="o">});</span>

<span class="n">task</span><span class="o">.</span><span class="na">acceptEitherAsync</span><span class="o">(</span><span class="n">task2</span><span class="o">,</span> <span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"任务3开始执行，当前时间："</span> <span class="o">+</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">());</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"上一个任务的结果为："</span> <span class="o">+</span> <span class="n">res</span><span class="o">);</span>
<span class="o">});</span>

<span class="c1">// 增加一些延迟时间，确保异步任务有足够的时间完成</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>输出：</p>

<pre><code class="language-plain">任务1开始执行，当前时间：1695088058520
任务2开始执行，当前时间：1695088058521
任务1执行完毕，当前时间：1695088059023
任务3开始执行，当前时间：1695088059023
上一个任务的结果为：task1
任务2执行完毕，当前时间：1695088059523
</code></pre>

<p>任务组合操作<code class="language-plaintext highlighter-rouge">acceptEitherAsync()</code>会在异步任务 1 和异步任务 2 中的任意一个完成时触发执行任务 3，但是需要注意，这个触发时机是不确定的。如果任务 1 和任务 2 都还未完成，那么任务 3 就不能被执行。</p>

<h3 id="并行运行多个-completablefuture">并行运行多个 CompletableFuture</h3>

<p>你可以通过 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 的 <code class="language-plaintext highlighter-rouge">allOf()</code>这个静态方法来并行运行多个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 。</p>

<p>实际项目中，我们经常需要并行运行多个互不相关的任务，这些任务之间没有依赖关系，可以互相独立地运行。</p>

<p>比说我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。像这种情况我们就可以使用并行运行多个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 来处理。</p>

<p>示例代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="n">task1</span> <span class="o">=</span>
  <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()-&gt;{</span>
    <span class="c1">//自定义业务操作</span>
  <span class="o">});</span>
<span class="o">......</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="n">task6</span> <span class="o">=</span>
  <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()-&gt;{</span>
    <span class="c1">//自定义业务操作</span>
  <span class="o">});</span>
<span class="o">......</span>
 <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="n">headerFuture</span><span class="o">=</span><span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">allOf</span><span class="o">(</span><span class="n">task1</span><span class="o">,.....,</span><span class="n">task6</span><span class="o">);</span>

  <span class="k">try</span> <span class="o">{</span>
    <span class="n">headerFuture</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">......</span>
  <span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"all done. "</span><span class="o">);</span>
</code></pre></div></div>

<p>经常和 <code class="language-plaintext highlighter-rouge">allOf()</code> 方法拿来对比的是 <code class="language-plaintext highlighter-rouge">anyOf()</code> 方法。</p>

<p><strong><code class="language-plaintext highlighter-rouge">allOf()</code> 方法会等到所有的 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 都运行完成之后再返回</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Random</span> <span class="n">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span> <span class="o">+</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">1000</span><span class="o">));</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"future1 done..."</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="s">"abc"</span><span class="o">;</span>
<span class="o">});</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future2</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span> <span class="o">+</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">1000</span><span class="o">));</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"future2 done..."</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="s">"efg"</span><span class="o">;</span>
<span class="o">});</span>
</code></pre></div></div>

<p>调用 <code class="language-plaintext highlighter-rouge">join()</code> 可以让程序等<code class="language-plaintext highlighter-rouge">future1</code> 和 <code class="language-plaintext highlighter-rouge">future2</code> 都运行完了之后再继续执行。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="n">completableFuture</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">allOf</span><span class="o">(</span><span class="n">future1</span><span class="o">,</span> <span class="n">future2</span><span class="o">);</span>
<span class="n">completableFuture</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
<span class="n">assertTrue</span><span class="o">(</span><span class="n">completableFuture</span><span class="o">.</span><span class="na">isDone</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"all futures done..."</span><span class="o">);</span>
</code></pre></div></div>

<p>输出：</p>

<pre><code class="language-plain">future1 done...
future2 done...
all futures done...
</code></pre>

<p><strong><code class="language-plaintext highlighter-rouge">anyOf()</code> 方法不会等待所有的 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 都运行完成之后再返回，只要有一个执行完成即可！</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">anyOf</span><span class="o">(</span><span class="n">future1</span><span class="o">,</span> <span class="n">future2</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
</code></pre></div></div>

<p>输出结果可能是：</p>

<pre><code class="language-plain">future2 done...
efg
</code></pre>

<p>也可能是：</p>

<pre><code class="language-plain">future1 done...
abc
</code></pre>

<h2 id="completablefuture-使用建议">CompletableFuture 使用建议</h2>

<h3 id="使用自定义线程池">使用自定义线程池</h3>

<p>我们上面的代码示例中，为了方便，都没有选择自定义线程池。实际项目中，这是不可取的。</p>

<p><code class="language-plaintext highlighter-rouge">CompletableFuture</code> 默认使用全局共享的 <code class="language-plaintext highlighter-rouge">ForkJoinPool.commonPool()</code> 作为执行器，所有未指定执行器的异步任务都会使用该线程池。这意味着应用程序、多个库或框架（如 Spring、第三方库）若都依赖 <code class="language-plaintext highlighter-rouge">CompletableFuture</code>，默认情况下它们都会共享同一个线程池。</p>

<p>虽然 <code class="language-plaintext highlighter-rouge">ForkJoinPool</code> 效率很高，但当同时提交大量任务时，可能会导致资源竞争和线程饥饿，进而影响系统性能。</p>

<p>为避免这些问题，建议为 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 提供自定义线程池，带来以下优势：</p>

<ul>
  <li><strong>隔离性</strong>：为不同任务分配独立的线程池，避免全局线程池资源争夺。</li>
  <li><strong>资源控制</strong>：根据任务特性调整线程池大小和队列类型，优化性能表现。</li>
  <li><strong>异常处理</strong>：通过自定义 <code class="language-plaintext highlighter-rouge">ThreadFactory</code> 更好地处理线程中的异常情况。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nc">ThreadPoolExecutor</span> <span class="n">executor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span>
        <span class="mi">0L</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span>
        <span class="k">new</span> <span class="nc">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;());</span>

<span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">runAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
     <span class="c1">//...</span>
<span class="o">},</span> <span class="n">executor</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="尽量避免使用-get">尽量避免使用 get()</h3>

<p><code class="language-plaintext highlighter-rouge">CompletableFuture</code>的<code class="language-plaintext highlighter-rouge">get()</code>方法是阻塞的，尽量避免使用。如果必须要使用的话，需要添加超时时间，否则可能会导致主线程一直等待，无法执行其他任务。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10_000</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="s">"Hello, world!"</span><span class="o">;</span>
    <span class="o">});</span>

    <span class="c1">// 获取异步任务的返回值，设置超时时间为 5 秒</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="o">|</span> <span class="nc">ExecutionException</span> <span class="o">|</span> <span class="nc">TimeoutException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 处理异常</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>上面这段代码在调用 <code class="language-plaintext highlighter-rouge">get()</code> 时抛出了 <code class="language-plaintext highlighter-rouge">TimeoutException</code> 异常。这样我们就可以在异常处理中进行相应的操作，比如取消任务、重试任务、记录日志等。</p>

<h3 id="正确进行异常处理">正确进行异常处理</h3>

<p>使用 <code class="language-plaintext highlighter-rouge">CompletableFuture</code>的时候一定要以正确的方式进行异常处理，避免异常丢失或者出现不可控问题。</p>

<p>下面是一些建议：</p>

<ul>
  <li>使用 <code class="language-plaintext highlighter-rouge">whenComplete</code> 方法可以在任务完成时触发回调函数，并正确地处理异常，而不是让异常被吞噬或丢失。</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">exceptionally</code> 方法可以处理异常并重新抛出，以便异常能够传播到后续阶段，而不是让异常被忽略或终止。</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">handle</code> 方法可以处理正常的返回结果和异常，并返回一个新的结果，而不是让异常影响正常的业务逻辑。</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">CompletableFuture.allOf</code> 方法可以组合多个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code>，并统一处理所有任务的异常，而不是让异常处理过于冗长或重复。</li>
  <li>……</li>
</ul>

<h3 id="合理组合多个异步任务">合理组合多个异步任务</h3>

<p>正确使用 <code class="language-plaintext highlighter-rouge">thenCompose()</code> 、 <code class="language-plaintext highlighter-rouge">thenCombine()</code> 、<code class="language-plaintext highlighter-rouge">acceptEither()</code>、<code class="language-plaintext highlighter-rouge">allOf()</code>、<code class="language-plaintext highlighter-rouge">anyOf()</code>等方法来组合多个异步任务，以满足实际业务的需求，提高程序执行效率。</p>

<p>实际使用中，我们还可以利用或者参考现成的异步任务编排框架，比如京东的 <a href="https://gitee.com/jd-platform-opensource/asyncTool">asyncTool</a> 。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/asyncTool-readme.png" alt="asyncTool README 文档" /></p>

<h2 id="后记">后记</h2>

<p>这篇文章只是简单介绍了 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 的核心概念和比较常用的一些 API 。如果想要深入学习的话，还可以多找一些书籍和博客看，比如下面几篇文章就挺不错：</p>

<ul>
  <li><a href="https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html">CompletableFuture 原理与实践-外卖商家端 API 的异步化 - 美团技术团队</a>：这篇文章详细介绍了 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 在实际项目中的运用。参考这篇文章，可以对项目中类似的场景进行优化，也算是一个小亮点了。这种性能优化方式比较简单且效果还不错！</li>
  <li><a href="https://mp.weixin.qq.com/s/32Ak-WFLynQfpn0Cg0N-0A">读 RocketMQ 源码，学习并发编程三大神器 - 勇哥 java 实战分享</a>：这篇文章介绍了 RocketMQ 对<code class="language-plaintext highlighter-rouge">CompletableFuture</code>的应用。具体来说，从 RocketMQ 4.7 开始，RocketMQ 引入了 <code class="language-plaintext highlighter-rouge">CompletableFuture</code>来实现异步消息处理 。</li>
</ul>

<p>另外，建议 G 友们可以看看京东的 <a href="https://gitee.com/jd-platform-opensource/asyncTool">asyncTool</a> 这个并发框架，里面大量使用到了 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 。</p>

<!-- @include: @article-footer.snippet.md -->
