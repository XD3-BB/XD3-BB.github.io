<!-- markdownlint-disable MD024 -->

<h2 id="aqs-介绍">AQS 介绍</h2>

<p>AQS 的全称为 <code class="language-plaintext highlighter-rouge">AbstractQueuedSynchronizer</code> ，翻译过来的意思就是抽象队列同步器。这个类在 <code class="language-plaintext highlighter-rouge">java.util.concurrent.locks</code> 包下面。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/AQS.png" alt="" /></p>

<p>AQS 就是一个抽象类，主要用来构建锁和同步器。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AbstractQueuedSynchronizer</span> <span class="kd">extends</span> <span class="nc">AbstractOwnableSynchronizer</span> <span class="kd">implements</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<p>AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code class="language-plaintext highlighter-rouge">ReentrantLock</code>，<code class="language-plaintext highlighter-rouge">Semaphore</code>，其他的诸如 <code class="language-plaintext highlighter-rouge">ReentrantReadWriteLock</code>，<code class="language-plaintext highlighter-rouge">SynchronousQueue</code>等等皆是基于 AQS 的。</p>

<h2 id="aqs-原理">AQS 原理</h2>

<p>在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于 AQS 原理的理解”。下面给大家一个示例供大家参考，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。</p>

<h3 id="aqs-核心思想">AQS 核心思想</h3>

<p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是基于 <strong>CLH 锁</strong> （Craig, Landin, and Hagersten locks） 实现的。</p>

<p>CLH 锁是对自旋锁的一种改进，是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 CLH 队列锁的一个结点（Node）来实现锁的分配。在 CLH 队列锁中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p>

<p>CLH 队列结构如下图所示：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/clh-queue-structure.png" alt="CLH 队列结构" /></p>

<p>关于 AQS 核心数据结构-CLH 锁的详细解读，强烈推荐阅读 <a href="https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg">Java AQS 核心数据结构-CLH 锁 - Qunar 技术沙龙</a> 这篇文章。</p>

<p>AQS(<code class="language-plaintext highlighter-rouge">AbstractQueuedSynchronizer</code>)的核心原理图：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/clh-queue-state.png" alt="CLH 队列" /></p>

<p>AQS 使用 <strong>int 成员变量 <code class="language-plaintext highlighter-rouge">state</code> 表示同步状态</strong>，通过内置的 <strong>FIFO 线程等待/等待队列</strong> 来完成获取资源线程的排队工作。</p>

<p><code class="language-plaintext highlighter-rouge">state</code> 变量由 <code class="language-plaintext highlighter-rouge">volatile</code> 修饰，用于展示当前临界资源的获锁情况。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 共享变量，使用volatile修饰保证线程可见性</span>
<span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">state</span><span class="o">;</span>
</code></pre></div></div>

<p>另外，状态信息 <code class="language-plaintext highlighter-rouge">state</code> 可以通过 <code class="language-plaintext highlighter-rouge">protected</code> 类型的<code class="language-plaintext highlighter-rouge">getState()</code>、<code class="language-plaintext highlighter-rouge">setState()</code>和<code class="language-plaintext highlighter-rouge">compareAndSetState()</code> 进行操作。并且，这几个方法都是 <code class="language-plaintext highlighter-rouge">final</code> 修饰的，在子类中无法被重写。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//返回同步状态的当前值</span>
<span class="kd">protected</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getState</span><span class="o">()</span> <span class="o">{</span>
     <span class="k">return</span> <span class="n">state</span><span class="o">;</span>
<span class="o">}</span>
 <span class="c1">// 设置同步状态的值</span>
<span class="kd">protected</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">setState</span><span class="o">(</span><span class="kt">int</span> <span class="n">newState</span><span class="o">)</span> <span class="o">{</span>
     <span class="n">state</span> <span class="o">=</span> <span class="n">newState</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span>
<span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">compareAndSetState</span><span class="o">(</span><span class="kt">int</span> <span class="n">expect</span><span class="o">,</span> <span class="kt">int</span> <span class="n">update</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">stateOffset</span><span class="o">,</span> <span class="n">expect</span><span class="o">,</span> <span class="n">update</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>以可重入的互斥锁 <code class="language-plaintext highlighter-rouge">ReentrantLock</code> 为例，它的内部维护了一个 <code class="language-plaintext highlighter-rouge">state</code> 变量，用来表示锁的占用状态。<code class="language-plaintext highlighter-rouge">state</code> 的初始值为 0，表示锁处于未锁定状态。当线程 A 调用 <code class="language-plaintext highlighter-rouge">lock()</code> 方法时，会尝试通过 <code class="language-plaintext highlighter-rouge">tryAcquire()</code> 方法独占该锁，并让 <code class="language-plaintext highlighter-rouge">state</code> 的值加 1。如果成功了，那么线程 A 就获取到了锁。如果失败了，那么线程 A 就会被加入到一个等待队列（CLH 队列）中，直到其他线程释放该锁。假设线程 A 获取锁成功了，释放锁之前，A 线程自己是可以重复获取此锁的（<code class="language-plaintext highlighter-rouge">state</code> 会累加）。这就是可重入性的体现：一个线程可以多次获取同一个锁而不会被阻塞。但是，这也意味着，一个线程必须释放与获取的次数相同的锁，才能让 <code class="language-plaintext highlighter-rouge">state</code> 的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。</p>

<p>线程 A 尝试获取锁的过程如下图所示（图源<a href="./reentrantlock.md">从 ReentrantLock 的实现看 AQS 的原理及应用 - 美团技术团队</a>）：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/aqs-exclusive-mode-acquire-lock.png" alt="AQS 独占模式获取锁" /></p>

<p>再以倒计时器 <code class="language-plaintext highlighter-rouge">CountDownLatch</code> 以例，任务分为 N 个子线程去执行，<code class="language-plaintext highlighter-rouge">state</code> 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程开始执行任务，每执行完一个子线程，就调用一次 <code class="language-plaintext highlighter-rouge">countDown()</code> 方法。该方法会尝试使用 CAS(Compare and Swap) 操作，让 <code class="language-plaintext highlighter-rouge">state</code> 的值减少 1。当所有的子线程都执行完毕后（即 <code class="language-plaintext highlighter-rouge">state</code> 的值变为 0），<code class="language-plaintext highlighter-rouge">CountDownLatch</code> 会调用 <code class="language-plaintext highlighter-rouge">unpark()</code> 方法，唤醒主线程。这时，主线程就可以从 <code class="language-plaintext highlighter-rouge">await()</code> 方法（<code class="language-plaintext highlighter-rouge">CountDownLatch</code> 中的<code class="language-plaintext highlighter-rouge">await()</code> 方法而非 AQS 中的）返回，继续执行后续的操作。</p>

<h3 id="aqs-资源共享方式">AQS 资源共享方式</h3>

<p>AQS 定义两种资源共享方式：<code class="language-plaintext highlighter-rouge">Exclusive</code>（独占，只有一个线程能执行，如<code class="language-plaintext highlighter-rouge">ReentrantLock</code>）和<code class="language-plaintext highlighter-rouge">Share</code>（共享，多个线程可同时执行，如<code class="language-plaintext highlighter-rouge">Semaphore</code>/<code class="language-plaintext highlighter-rouge">CountDownLatch</code>）。</p>

<p>一般来说，自定义同步器的共享方式要么是独占，要么是共享，他们也只需实现<code class="language-plaintext highlighter-rouge">tryAcquire-tryRelease</code>、<code class="language-plaintext highlighter-rouge">tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code class="language-plaintext highlighter-rouge">ReentrantReadWriteLock</code>。</p>

<h3 id="自定义同步器">自定义同步器</h3>

<p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>

<ol>
  <li>使用者继承 <code class="language-plaintext highlighter-rouge">AbstractQueuedSynchronizer</code> 并重写指定的方法。</li>
  <li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>

<p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p>

<p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的钩子方法：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span>
<span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span><span class="o">)</span>
<span class="c1">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span>
<span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span><span class="o">)</span>
<span class="c1">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span>
<span class="kd">protected</span> <span class="kt">int</span> <span class="nf">tryAcquireShared</span><span class="o">(</span><span class="kt">int</span><span class="o">)</span>
<span class="c1">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span>
<span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryReleaseShared</span><span class="o">(</span><span class="kt">int</span><span class="o">)</span>
<span class="c1">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span>
<span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">isHeldExclusively</span><span class="o">()</span>
</code></pre></div></div>

<p><strong>什么是钩子方法呢？</strong> 钩子方法是一种被声明在抽象类中的方法，一般使用 <code class="language-plaintext highlighter-rouge">protected</code> 关键字修饰，它可以是空方法（由子类实现），也可以是默认实现的方法。模板设计模式通过钩子方法控制固定步骤的实现。</p>

<p>篇幅问题，这里就不详细介绍模板方法模式了，不太了解的小伙伴可以看看这篇文章：<a href="https://mp.weixin.qq.com/s/zpScSCktFpnSWHWIQem2jg">用 Java8 改造后的模板方法模式真的是 yyds!</a>。</p>

<p>除了上面提到的钩子方法之外，AQS 类中的其他方法都是 <code class="language-plaintext highlighter-rouge">final</code> ，所以无法被其他类重写。</p>

<h2 id="常见同步工具类">常见同步工具类</h2>

<p>下面介绍几个基于 AQS 的常见同步工具类。</p>

<h3 id="semaphore信号量">Semaphore(信号量)</h3>

<h4 id="介绍">介绍</h4>

<p><code class="language-plaintext highlighter-rouge">synchronized</code> 和 <code class="language-plaintext highlighter-rouge">ReentrantLock</code> 都是一次只允许一个线程访问某个资源，而<code class="language-plaintext highlighter-rouge">Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。</p>

<p><code class="language-plaintext highlighter-rouge">Semaphore</code> 的使用简单，我们这里假设有 <code class="language-plaintext highlighter-rouge">N(N&gt;5)</code> 个线程来获取 <code class="language-plaintext highlighter-rouge">Semaphore</code> 中的共享资源，下面的代码表示同一时刻 N 个线程中只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 初始共享资源数量</span>
<span class="kd">final</span> <span class="nc">Semaphore</span> <span class="n">semaphore</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Semaphore</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
<span class="c1">// 获取1个许可</span>
<span class="n">semaphore</span><span class="o">.</span><span class="na">acquire</span><span class="o">();</span>
<span class="c1">// 释放1个许可</span>
<span class="n">semaphore</span><span class="o">.</span><span class="na">release</span><span class="o">();</span>
</code></pre></div></div>

<p>当初始的资源个数为 1 的时候，<code class="language-plaintext highlighter-rouge">Semaphore</code> 退化为排他锁。</p>

<p><code class="language-plaintext highlighter-rouge">Semaphore</code> 有两种模式：。</p>

<ul>
  <li><strong>公平模式：</strong> 调用 <code class="language-plaintext highlighter-rouge">acquire()</code> 方法的顺序就是获取许可证的顺序，遵循 FIFO；</li>
  <li><strong>非公平模式：</strong> 抢占式的。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">Semaphore</code> 对应的两个构造方法如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">Semaphore</span><span class="o">(</span><span class="kt">int</span> <span class="n">permits</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">sync</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NonfairSync</span><span class="o">(</span><span class="n">permits</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nf">Semaphore</span><span class="o">(</span><span class="kt">int</span> <span class="n">permits</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">fair</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">sync</span> <span class="o">=</span> <span class="n">fair</span> <span class="o">?</span> <span class="k">new</span> <span class="nc">FairSync</span><span class="o">(</span><span class="n">permits</span><span class="o">)</span> <span class="o">:</span> <span class="k">new</span> <span class="nc">NonfairSync</span><span class="o">(</span><span class="n">permits</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</strong></p>

<p><code class="language-plaintext highlighter-rouge">Semaphore</code> 通常用于那些资源有明确访问数量限制的场景比如限流（仅限于单机模式，实际项目中推荐使用 Redis +Lua 来做限流）。</p>

<h4 id="原理">原理</h4>

<p><code class="language-plaintext highlighter-rouge">Semaphore</code> 是共享锁的一种实现，它默认构造 AQS 的 <code class="language-plaintext highlighter-rouge">state</code> 值为 <code class="language-plaintext highlighter-rouge">permits</code>，你可以将 <code class="language-plaintext highlighter-rouge">permits</code> 的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p>

<p>以无参 <code class="language-plaintext highlighter-rouge">acquire</code> 方法为例，调用<code class="language-plaintext highlighter-rouge">semaphore.acquire()</code> ，线程尝试获取许可证，如果 <code class="language-plaintext highlighter-rouge">state &gt; 0</code> 的话，则表示可以获取成功，如果 <code class="language-plaintext highlighter-rouge">state &lt;= 0</code> 的话，则表示许可证数量不足，获取失败。</p>

<p>如果可以获取成功的话(<code class="language-plaintext highlighter-rouge">state &gt; 0</code> )，会尝试使用 CAS 操作去修改 <code class="language-plaintext highlighter-rouge">state</code> 的值 <code class="language-plaintext highlighter-rouge">state=state-1</code>。如果获取失败则会创建一个 Node 节点加入等待队列，挂起当前线程。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取1个许可证</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">acquire</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="n">sync</span><span class="o">.</span><span class="na">acquireSharedInterruptibly</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 获取一个或者多个许可证</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">acquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">permits</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">permits</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">();</span>
    <span class="n">sync</span><span class="o">.</span><span class="na">acquireSharedInterruptibly</span><span class="o">(</span><span class="n">permits</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">acquireSharedInterruptibly</code>方法是 <code class="language-plaintext highlighter-rouge">AbstractQueuedSynchronizer</code> 中的默认实现。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 共享模式下获取许可证，获取成功则返回，失败则加入等待队列，挂起线程</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquireSharedInterruptibly</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">InterruptedException</span><span class="o">();</span>
        <span class="c1">// 尝试获取许可证，arg为获取许可证个数，当获取失败时,则创建一个节点加入等待队列，挂起当前线程。</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tryAcquireShared</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
      <span class="n">doAcquireSharedInterruptibly</span><span class="o">(</span><span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这里再以非公平模式（<code class="language-plaintext highlighter-rouge">NonfairSync</code>）的为例，看看 <code class="language-plaintext highlighter-rouge">tryAcquireShared</code> 方法的实现。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 共享模式下尝试获取资源(在Semaphore中的资源即许可证):</span>
<span class="kd">protected</span> <span class="kt">int</span> <span class="nf">tryAcquireShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">nonfairTryAcquireShared</span><span class="o">(</span><span class="n">acquires</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 非公平的共享模式获取许可证</span>
<span class="kd">final</span> <span class="kt">int</span> <span class="nf">nonfairTryAcquireShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="c1">// 当前可用许可证数量</span>
        <span class="kt">int</span> <span class="n">available</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
        <span class="cm">/*
         * 尝试获取许可证，当前可用许可证数量小于等于0时，返回负值，表示获取失败，
         * 当前可用许可证大于0时才可能获取成功，CAS失败了会循环重新获取最新的值尝试获取
         */</span>
        <span class="kt">int</span> <span class="n">remaining</span> <span class="o">=</span> <span class="n">available</span> <span class="o">-</span> <span class="n">acquires</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">remaining</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
            <span class="n">compareAndSetState</span><span class="o">(</span><span class="n">available</span><span class="o">,</span> <span class="n">remaining</span><span class="o">))</span>
            <span class="k">return</span> <span class="n">remaining</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>以无参 <code class="language-plaintext highlighter-rouge">release</code> 方法为例，调用<code class="language-plaintext highlighter-rouge">semaphore.release();</code> ，线程尝试释放许可证，并使用 CAS 操作去修改 <code class="language-plaintext highlighter-rouge">state</code> 的值 <code class="language-plaintext highlighter-rouge">state=state+1</code>。释放许可证成功之后，同时会唤醒等待队列中的一个线程。被唤醒的线程会重新尝试去修改 <code class="language-plaintext highlighter-rouge">state</code> 的值 <code class="language-plaintext highlighter-rouge">state=state-1</code> ，如果 <code class="language-plaintext highlighter-rouge">state &gt; 0</code> 则获取令牌成功，否则重新进入等待队列，挂起线程。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 释放一个许可证</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">release</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">sync</span><span class="o">.</span><span class="na">releaseShared</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 释放一个或者多个许可证</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">release</span><span class="o">(</span><span class="kt">int</span> <span class="n">permits</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">permits</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">();</span>
    <span class="n">sync</span><span class="o">.</span><span class="na">releaseShared</span><span class="o">(</span><span class="n">permits</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">releaseShared</code>方法是 <code class="language-plaintext highlighter-rouge">AbstractQueuedSynchronizer</code> 中的默认实现。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 释放共享锁</span>
<span class="c1">// 如果 tryReleaseShared 返回 true，就唤醒等待队列中的一个或多个线程。</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">releaseShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//释放共享锁</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tryReleaseShared</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
      <span class="c1">//释放当前节点的后置等待节点</span>
      <span class="n">doReleaseShared</span><span class="o">();</span>
      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">tryReleaseShared</code> 方法是<code class="language-plaintext highlighter-rouge">Semaphore</code> 的内部类 <code class="language-plaintext highlighter-rouge">Sync</code> 重写的一个方法， <code class="language-plaintext highlighter-rouge">AbstractQueuedSynchronizer</code>中的默认实现仅仅抛出 <code class="language-plaintext highlighter-rouge">UnsupportedOperationException</code> 异常。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 内部类 Sync 中重写的一个方法</span>
<span class="c1">// 尝试释放资源</span>
<span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryReleaseShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">releases</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">current</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
        <span class="c1">// 可用许可证+1</span>
        <span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">current</span> <span class="o">+</span> <span class="n">releases</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">next</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">)</span> <span class="c1">// overflow</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="s">"Maximum permit count exceeded"</span><span class="o">);</span>
         <span class="c1">// CAS修改state的值</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="n">current</span><span class="o">,</span> <span class="n">next</span><span class="o">))</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>可以看到，上面提到的几个方法底层基本都是通过同步器 <code class="language-plaintext highlighter-rouge">sync</code> 实现的。<code class="language-plaintext highlighter-rouge">Sync</code> 是 <code class="language-plaintext highlighter-rouge">CountDownLatch</code> 的内部类 , 继承了 <code class="language-plaintext highlighter-rouge">AbstractQueuedSynchronizer</code> ，重写了其中的某些方法。并且，Sync 对应的还有两个子类 <code class="language-plaintext highlighter-rouge">NonfairSync</code>（对应非公平模式） 和 <code class="language-plaintext highlighter-rouge">FairSync</code>（对应公平模式）。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Sync</span> <span class="kd">extends</span> <span class="nc">AbstractQueuedSynchronizer</span> <span class="o">{</span>
  <span class="c1">// ...</span>
<span class="o">}</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">NonfairSync</span> <span class="kd">extends</span> <span class="nc">Sync</span> <span class="o">{</span>
  <span class="c1">// ...</span>
<span class="o">}</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">FairSync</span> <span class="kd">extends</span> <span class="nc">Sync</span> <span class="o">{</span>
  <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="实战">实战</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SemaphoreExample</span> <span class="o">{</span>
  <span class="c1">// 请求的数量</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">threadCount</span> <span class="o">=</span> <span class="mi">550</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="c1">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span>
    <span class="nc">ExecutorService</span> <span class="n">threadPool</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">300</span><span class="o">);</span>
    <span class="c1">// 初始许可证数量</span>
    <span class="kd">final</span> <span class="nc">Semaphore</span> <span class="n">semaphore</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Semaphore</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threadCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="kd">final</span> <span class="kt">int</span> <span class="n">threadnum</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
      <span class="n">threadPool</span><span class="o">.</span><span class="na">execute</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span><span class="c1">// Lambda 表达式的运用</span>
        <span class="k">try</span> <span class="o">{</span>
          <span class="n">semaphore</span><span class="o">.</span><span class="na">acquire</span><span class="o">();</span><span class="c1">// 获取一个许可，所以可运行线程数量为20/1=20</span>
          <span class="n">test</span><span class="o">(</span><span class="n">threadnum</span><span class="o">);</span>
          <span class="n">semaphore</span><span class="o">.</span><span class="na">release</span><span class="o">();</span><span class="c1">// 释放一个许可</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
          <span class="c1">// TODO Auto-generated catch block</span>
          <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

      <span class="o">});</span>
    <span class="o">}</span>
    <span class="n">threadPool</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"finish"</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="kt">int</span> <span class="n">threadnum</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span><span class="c1">// 模拟请求的耗时操作</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"threadnum:"</span> <span class="o">+</span> <span class="n">threadnum</span><span class="o">);</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span><span class="c1">// 模拟请求的耗时操作</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>执行 <code class="language-plaintext highlighter-rouge">acquire()</code> 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 <code class="language-plaintext highlighter-rouge">release</code> 方法增加一个许可证，这可能会释放一个阻塞的 <code class="language-plaintext highlighter-rouge">acquire()</code> 方法。然而，其实并没有实际的许可证这个对象，<code class="language-plaintext highlighter-rouge">Semaphore</code> 只是维持了一个可获得许可证的数量。 <code class="language-plaintext highlighter-rouge">Semaphore</code> 经常用于限制获取某种资源的线程数量。</p>

<p>当然一次也可以一次拿取和释放多个许可，不过一般没有必要这样做：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">semaphore</span><span class="o">.</span><span class="na">acquire</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span><span class="c1">// 获取5个许可，所以可运行线程数量为20/5=4</span>
<span class="n">test</span><span class="o">(</span><span class="n">threadnum</span><span class="o">);</span>
<span class="n">semaphore</span><span class="o">.</span><span class="na">release</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span><span class="c1">// 释放5个许可</span>
</code></pre></div></div>

<p>除了 <code class="language-plaintext highlighter-rouge">acquire()</code> 方法之外，另一个比较常用的与之对应的方法是 <code class="language-plaintext highlighter-rouge">tryAcquire()</code> 方法，该方法如果获取不到许可就立即返回 false。</p>

<p><a href="https://github.com/Snailclimb/JavaGuide/issues/645">issue645 补充内容</a>：</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Semaphore</code> 与 <code class="language-plaintext highlighter-rouge">CountDownLatch</code> 一样，也是共享锁的一种实现。它默认构造 AQS 的 <code class="language-plaintext highlighter-rouge">state</code> 为 <code class="language-plaintext highlighter-rouge">permits</code>。当执行任务的线程数量超出 <code class="language-plaintext highlighter-rouge">permits</code>，那么多余的线程将会被放入等待队列 <code class="language-plaintext highlighter-rouge">Park</code>,并自旋判断 <code class="language-plaintext highlighter-rouge">state</code> 是否大于 0。只有当 <code class="language-plaintext highlighter-rouge">state</code> 大于 0 的时候，阻塞的线程才能继续执行,此时先前执行任务的线程继续执行 <code class="language-plaintext highlighter-rouge">release()</code> 方法，<code class="language-plaintext highlighter-rouge">release()</code> 方法使得 state 的变量会加 1，那么自旋的线程便会判断成功。
如此，每次只有最多不超过 <code class="language-plaintext highlighter-rouge">permits</code> 数量的线程能自旋成功，便限制了执行任务线程的数量。</p>
</blockquote>

<h3 id="countdownlatch-倒计时器">CountDownLatch （倒计时器）</h3>

<h4 id="介绍-1">介绍</h4>

<p><code class="language-plaintext highlighter-rouge">CountDownLatch</code> 允许 <code class="language-plaintext highlighter-rouge">count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p>

<p><code class="language-plaintext highlighter-rouge">CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code class="language-plaintext highlighter-rouge">CountDownLatch</code> 使用完毕后，它不能再次被使用。</p>

<h4 id="原理-1">原理</h4>

<p><code class="language-plaintext highlighter-rouge">CountDownLatch</code> 是共享锁的一种实现，它默认构造 AQS 的 <code class="language-plaintext highlighter-rouge">state</code> 值为 <code class="language-plaintext highlighter-rouge">count</code>。这个我们通过 <code class="language-plaintext highlighter-rouge">CountDownLatch</code> 的构造方法即可看出。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">CountDownLatch</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"count &lt; 0"</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">sync</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Sync</span><span class="o">(</span><span class="n">count</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Sync</span> <span class="kd">extends</span> <span class="nc">AbstractQueuedSynchronizer</span> <span class="o">{</span>
    <span class="nc">Sync</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">setState</span><span class="o">(</span><span class="n">count</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="c1">//...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>当线程调用 <code class="language-plaintext highlighter-rouge">countDown()</code> 时，其实使用了<code class="language-plaintext highlighter-rouge">tryReleaseShared</code>方法以 CAS 的操作来减少 <code class="language-plaintext highlighter-rouge">state</code>，直至 <code class="language-plaintext highlighter-rouge">state</code> 为 0 。当 <code class="language-plaintext highlighter-rouge">state</code> 为 0 时，表示所有的线程都调用了 <code class="language-plaintext highlighter-rouge">countDown</code> 方法，那么在 <code class="language-plaintext highlighter-rouge">CountDownLatch</code> 上等待的线程就会被唤醒并继续执行。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">countDown</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// Sync 是 CountDownLatch 的内部类 , 继承了 AbstractQueuedSynchronizer</span>
    <span class="n">sync</span><span class="o">.</span><span class="na">releaseShared</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">releaseShared</code>方法是 <code class="language-plaintext highlighter-rouge">AbstractQueuedSynchronizer</code> 中的默认实现。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 释放共享锁</span>
<span class="c1">// 如果 tryReleaseShared 返回 true，就唤醒等待队列中的一个或多个线程。</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">releaseShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//释放共享锁</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tryReleaseShared</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
      <span class="c1">//释放当前节点的后置等待节点</span>
      <span class="n">doReleaseShared</span><span class="o">();</span>
      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">tryReleaseShared</code> 方法是<code class="language-plaintext highlighter-rouge">CountDownLatch</code> 的内部类 <code class="language-plaintext highlighter-rouge">Sync</code> 重写的一个方法， <code class="language-plaintext highlighter-rouge">AbstractQueuedSynchronizer</code>中的默认实现仅仅抛出 <code class="language-plaintext highlighter-rouge">UnsupportedOperationException</code> 异常。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 对 state 进行递减，直到 state 变成 0；</span>
<span class="c1">// 只有 count 递减到 0 时，countDown 才会返回 true</span>
<span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryReleaseShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">releases</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 自选检查 state 是否为 0</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
        <span class="c1">// 如果 state 已经是 0 了，直接返回 false</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="c1">// 对 state 进行递减</span>
        <span class="kt">int</span> <span class="n">nextc</span> <span class="o">=</span> <span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="c1">// CAS 操作更新 state 的值</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">nextc</span><span class="o">))</span>
            <span class="k">return</span> <span class="n">nextc</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>以无参 <code class="language-plaintext highlighter-rouge">await</code>方法为例，当调用 <code class="language-plaintext highlighter-rouge">await()</code> 的时候，如果 <code class="language-plaintext highlighter-rouge">state</code> 不为 0，那就证明任务还没有执行完毕，<code class="language-plaintext highlighter-rouge">await()</code> 就会一直阻塞，也就是说 <code class="language-plaintext highlighter-rouge">await()</code> 之后的语句不会被执行（<code class="language-plaintext highlighter-rouge">main</code> 线程被加入到等待队列也就是 CLH 队列中了）。然后，<code class="language-plaintext highlighter-rouge">CountDownLatch</code> 会自旋 CAS 判断 <code class="language-plaintext highlighter-rouge">state == 0</code>，如果 <code class="language-plaintext highlighter-rouge">state == 0</code> 的话，就会释放所有等待的线程，<code class="language-plaintext highlighter-rouge">await()</code> 方法之后的语句得到执行。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 等待（也可以叫做加锁）</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">await</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="n">sync</span><span class="o">.</span><span class="na">acquireSharedInterruptibly</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 带有超时时间的等待</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">await</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="nc">TimeUnit</span> <span class="n">unit</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">tryAcquireSharedNanos</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">unit</span><span class="o">.</span><span class="na">toNanos</span><span class="o">(</span><span class="n">timeout</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">acquireSharedInterruptibly</code>方法是 <code class="language-plaintext highlighter-rouge">AbstractQueuedSynchronizer</code> 中的默认实现。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 尝试获取锁，获取成功则返回，失败则加入等待队列，挂起线程</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquireSharedInterruptibly</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">InterruptedException</span><span class="o">();</span>
        <span class="c1">// 尝试获得锁，获取成功则返回</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tryAcquireShared</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
      <span class="c1">// 获取失败加入等待队列，挂起线程</span>
      <span class="n">doAcquireSharedInterruptibly</span><span class="o">(</span><span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">tryAcquireShared</code> 方法是<code class="language-plaintext highlighter-rouge">CountDownLatch</code> 的内部类 <code class="language-plaintext highlighter-rouge">Sync</code> 重写的一个方法，其作用就是判断 <code class="language-plaintext highlighter-rouge">state</code> 的值是否为 0，是的话就返回 1，否则返回 -1。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="kt">int</span> <span class="nf">tryAcquireShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">getState</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="实战-1">实战</h4>

<p><strong>CountDownLatch 的两种典型用法</strong>：</p>

<ol>
  <li>某一线程在开始运行前等待 n 个线程执行完毕 : 将 <code class="language-plaintext highlighter-rouge">CountDownLatch</code> 的计数器初始化为 n （<code class="language-plaintext highlighter-rouge">new CountDownLatch(n)</code>），每当一个任务线程执行完毕，就将计数器减 1 （<code class="language-plaintext highlighter-rouge">countdownlatch.countDown()</code>），当计数器的值变为 0 时，在 <code class="language-plaintext highlighter-rouge">CountDownLatch 上 await()</code> 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</li>
  <li>实现多个线程开始执行任务的最大并行性：注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 <code class="language-plaintext highlighter-rouge">CountDownLatch</code> 对象，将其计数器初始化为 1 （<code class="language-plaintext highlighter-rouge">new CountDownLatch(1)</code>），多个线程在开始执行任务前首先 <code class="language-plaintext highlighter-rouge">coundownlatch.await()</code>，当主线程调用 <code class="language-plaintext highlighter-rouge">countDown()</code> 时，计数器变为 0，多个线程同时被唤醒。</li>
</ol>

<p><strong>CountDownLatch 代码示例</strong>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountDownLatchExample</span> <span class="o">{</span>
  <span class="c1">// 请求的数量</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">THREAD_COUNT</span> <span class="o">=</span> <span class="mi">550</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="c1">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span>
    <span class="c1">// 只是测试使用，实际场景请手动赋值线程池参数</span>
    <span class="nc">ExecutorService</span> <span class="n">threadPool</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">300</span><span class="o">);</span>
    <span class="kd">final</span> <span class="nc">CountDownLatch</span> <span class="n">countDownLatch</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CountDownLatch</span><span class="o">(</span><span class="no">THREAD_COUNT</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">THREAD_COUNT</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="kd">final</span> <span class="kt">int</span> <span class="n">threadNum</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
      <span class="n">threadPool</span><span class="o">.</span><span class="na">execute</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
          <span class="n">test</span><span class="o">(</span><span class="n">threadNum</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
          <span class="c1">// 表示一个请求已经被完成</span>
          <span class="n">countDownLatch</span><span class="o">.</span><span class="na">countDown</span><span class="o">();</span>
        <span class="o">}</span>

      <span class="o">});</span>
    <span class="o">}</span>
    <span class="n">countDownLatch</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
    <span class="n">threadPool</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"finish"</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="kt">int</span> <span class="n">threadnum</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"threadNum:"</span> <span class="o">+</span> <span class="n">threadnum</span><span class="o">);</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>上面的代码中，我们定义了请求的数量为 550，当这 550 个请求被处理完成之后，才会执行<code class="language-plaintext highlighter-rouge">System.out.println("finish");</code>。</p>

<p>与 <code class="language-plaintext highlighter-rouge">CountDownLatch</code> 的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用 <code class="language-plaintext highlighter-rouge">CountDownLatch.await()</code> 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p>

<p>其他 N 个线程必须引用闭锁对象，因为他们需要通知 <code class="language-plaintext highlighter-rouge">CountDownLatch</code> 对象，他们已经完成了各自的任务。这种通知机制是通过 <code class="language-plaintext highlighter-rouge">CountDownLatch.countDown()</code>方法来完成的；每调用一次这个方法，在构造函数中初始化的 count 值就减 1。所以当 N 个线程都调 用了这个方法，count 的值等于 0，然后主线程就能通过 <code class="language-plaintext highlighter-rouge">await()</code>方法，恢复执行自己的任务。</p>

<p>再插一嘴：<code class="language-plaintext highlighter-rouge">CountDownLatch</code> 的 <code class="language-plaintext highlighter-rouge">await()</code> 方法使用不当很容易产生死锁，比如我们上面代码中的 for 循环改为：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threadCount</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
<span class="o">.......</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这样就导致 <code class="language-plaintext highlighter-rouge">count</code> 的值没办法等于 0，然后就会导致一直等待。</p>

<h3 id="cyclicbarrier循环栅栏">CyclicBarrier(循环栅栏)</h3>

<h4 id="介绍-2">介绍</h4>

<p><code class="language-plaintext highlighter-rouge">CyclicBarrier</code> 和 <code class="language-plaintext highlighter-rouge">CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code class="language-plaintext highlighter-rouge">CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code class="language-plaintext highlighter-rouge">CountDownLatch</code> 类似。</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">CountDownLatch</code> 的实现是基于 AQS 的，而 <code class="language-plaintext highlighter-rouge">CycliBarrier</code> 是基于 <code class="language-plaintext highlighter-rouge">ReentrantLock</code>(<code class="language-plaintext highlighter-rouge">ReentrantLock</code> 也属于 AQS 同步器)和 <code class="language-plaintext highlighter-rouge">Condition</code> 的。</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">CyclicBarrier</code> 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p>

<h4 id="原理-2">原理</h4>

<p><code class="language-plaintext highlighter-rouge">CyclicBarrier</code> 内部通过一个 <code class="language-plaintext highlighter-rouge">count</code> 变量作为计数器，<code class="language-plaintext highlighter-rouge">count</code> 的初始值为 <code class="language-plaintext highlighter-rouge">parties</code> 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//每次拦截的线程数</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">parties</span><span class="o">;</span>
<span class="c1">//计数器</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
</code></pre></div></div>

<p>下面我们结合源码来简单看看。</p>

<p>1、<code class="language-plaintext highlighter-rouge">CyclicBarrier</code> 默认的构造方法是 <code class="language-plaintext highlighter-rouge">CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code class="language-plaintext highlighter-rouge">await()</code> 方法告诉 <code class="language-plaintext highlighter-rouge">CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">CyclicBarrier</span><span class="o">(</span><span class="kt">int</span> <span class="n">parties</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">(</span><span class="n">parties</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nf">CyclicBarrier</span><span class="o">(</span><span class="kt">int</span> <span class="n">parties</span><span class="o">,</span> <span class="nc">Runnable</span> <span class="n">barrierAction</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">parties</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">();</span>
    <span class="k">this</span><span class="o">.</span><span class="na">parties</span> <span class="o">=</span> <span class="n">parties</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="n">parties</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">barrierCommand</span> <span class="o">=</span> <span class="n">barrierAction</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>其中，<code class="language-plaintext highlighter-rouge">parties</code> 就代表了有拦截的线程的数量，当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过。</p>

<p>2、当调用 <code class="language-plaintext highlighter-rouge">CyclicBarrier</code> 对象调用 <code class="language-plaintext highlighter-rouge">await()</code> 方法时，实际上调用的是 <code class="language-plaintext highlighter-rouge">dowait(false, 0L)</code>方法。 <code class="language-plaintext highlighter-rouge">await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 <code class="language-plaintext highlighter-rouge">parties</code> 的值时，栅栏才会打开，线程才得以通过执行。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">await</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span><span class="o">,</span> <span class="nc">BrokenBarrierException</span> <span class="o">{</span>
  <span class="k">try</span> <span class="o">{</span>
      <span class="k">return</span> <span class="nf">dowait</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="mi">0L</span><span class="o">);</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">TimeoutException</span> <span class="n">toe</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="n">toe</span><span class="o">);</span> <span class="c1">// cannot happen</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">dowait(false, 0L)</code>方法源码分析如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。上面的示例中 count 的值就为 5。</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
    <span class="cm">/**
     * Main barrier code, covering the various policies.
     */</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">dowait</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">timed</span><span class="o">,</span> <span class="kt">long</span> <span class="n">nanos</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">InterruptedException</span><span class="o">,</span> <span class="nc">BrokenBarrierException</span><span class="o">,</span>
               <span class="nc">TimeoutException</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">lock</span><span class="o">;</span>
        <span class="c1">// 锁住</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="nc">Generation</span> <span class="n">g</span> <span class="o">=</span> <span class="n">generation</span><span class="o">;</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">g</span><span class="o">.</span><span class="na">broken</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">BrokenBarrierException</span><span class="o">();</span>

            <span class="c1">// 如果线程中断了，抛出异常</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">breakBarrier</span><span class="o">();</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">InterruptedException</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="c1">// count 减1</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="o">--</span><span class="n">count</span><span class="o">;</span>
            <span class="c1">// 当 count 数量减为 0 之后说明最后一个线程已经到达栅栏了，也就是达到了可以执行await 方法之后的条件</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// tripped</span>
                <span class="kt">boolean</span> <span class="n">ranAction</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="kd">final</span> <span class="nc">Runnable</span> <span class="n">command</span> <span class="o">=</span> <span class="n">barrierCommand</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">command</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="n">command</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
                    <span class="n">ranAction</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="c1">// 将 count 重置为 parties 属性的初始化值</span>
                    <span class="c1">// 唤醒之前等待的线程</span>
                    <span class="c1">// 下一波执行开始</span>
                    <span class="n">nextGeneration</span><span class="o">();</span>
                    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">ranAction</span><span class="o">)</span>
                        <span class="n">breakBarrier</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// loop until tripped, broken, interrupted, or timed out</span>
            <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">timed</span><span class="o">)</span>
                        <span class="n">trip</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
                    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">nanos</span> <span class="o">&gt;</span> <span class="mi">0L</span><span class="o">)</span>
                        <span class="n">nanos</span> <span class="o">=</span> <span class="n">trip</span><span class="o">.</span><span class="na">awaitNanos</span><span class="o">(</span><span class="n">nanos</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">ie</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">g</span> <span class="o">==</span> <span class="n">generation</span> <span class="o">&amp;&amp;</span> <span class="o">!</span> <span class="n">g</span><span class="o">.</span><span class="na">broken</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">breakBarrier</span><span class="o">();</span>
                        <span class="k">throw</span> <span class="n">ie</span><span class="o">;</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="c1">// We're about to finish waiting even if we had not</span>
                        <span class="c1">// been interrupted, so this interrupt is deemed to</span>
                        <span class="c1">// "belong" to subsequent execution.</span>
                        <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">interrupt</span><span class="o">();</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">g</span><span class="o">.</span><span class="na">broken</span><span class="o">)</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">BrokenBarrierException</span><span class="o">();</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">g</span> <span class="o">!=</span> <span class="n">generation</span><span class="o">)</span>
                    <span class="k">return</span> <span class="n">index</span><span class="o">;</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">timed</span> <span class="o">&amp;&amp;</span> <span class="n">nanos</span> <span class="o">&lt;=</span> <span class="mi">0L</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">breakBarrier</span><span class="o">();</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">TimeoutException</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<h4 id="实战-2">实战</h4>

<p>示例 1：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CyclicBarrierExample1</span> <span class="o">{</span>
  <span class="c1">// 请求的数量</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">threadCount</span> <span class="o">=</span> <span class="mi">550</span><span class="o">;</span>
  <span class="c1">// 需要同步的线程数量</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">CyclicBarrier</span> <span class="n">cyclicBarrier</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CyclicBarrier</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="c1">// 创建线程池</span>
    <span class="nc">ExecutorService</span> <span class="n">threadPool</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threadCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="kd">final</span> <span class="kt">int</span> <span class="n">threadNum</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
      <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
      <span class="n">threadPool</span><span class="o">.</span><span class="na">execute</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
          <span class="n">test</span><span class="o">(</span><span class="n">threadNum</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
          <span class="c1">// TODO Auto-generated catch block</span>
          <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">BrokenBarrierException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
          <span class="c1">// TODO Auto-generated catch block</span>
          <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
      <span class="o">});</span>
    <span class="o">}</span>
    <span class="n">threadPool</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="kt">int</span> <span class="n">threadnum</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span><span class="o">,</span> <span class="nc">BrokenBarrierException</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"threadnum:"</span> <span class="o">+</span> <span class="n">threadnum</span> <span class="o">+</span> <span class="s">"is ready"</span><span class="o">);</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="cm">/**等待60秒，保证子线程完全执行结束*/</span>
      <span class="n">cyclicBarrier</span><span class="o">.</span><span class="na">await</span><span class="o">(</span><span class="mi">60</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"-----CyclicBarrierException------"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"threadnum:"</span> <span class="o">+</span> <span class="n">threadnum</span> <span class="o">+</span> <span class="s">"is finish"</span><span class="o">);</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>运行结果，如下：</p>

<pre><code class="language-plain">threadnum:0is ready
threadnum:1is ready
threadnum:2is ready
threadnum:3is ready
threadnum:4is ready
threadnum:4is finish
threadnum:0is finish
threadnum:1is finish
threadnum:2is finish
threadnum:3is finish
threadnum:5is ready
threadnum:6is ready
threadnum:7is ready
threadnum:8is ready
threadnum:9is ready
threadnum:9is finish
threadnum:5is finish
threadnum:8is finish
threadnum:7is finish
threadnum:6is finish
......
</code></pre>

<p>可以看到当线程数量也就是请求数量达到我们定义的 5 个的时候， <code class="language-plaintext highlighter-rouge">await()</code> 方法之后的方法才被执行。</p>

<p>另外，<code class="language-plaintext highlighter-rouge">CyclicBarrier</code> 还提供一个更高级的构造函数 <code class="language-plaintext highlighter-rouge">CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在线程到达屏障时，优先执行 <code class="language-plaintext highlighter-rouge">barrierAction</code>，方便处理更复杂的业务场景。</p>

<p>示例 2：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CyclicBarrierExample2</span> <span class="o">{</span>
  <span class="c1">// 请求的数量</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">threadCount</span> <span class="o">=</span> <span class="mi">550</span><span class="o">;</span>
  <span class="c1">// 需要同步的线程数量</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">CyclicBarrier</span> <span class="n">cyclicBarrier</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CyclicBarrier</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"------当线程数达到之后，优先执行------"</span><span class="o">);</span>
  <span class="o">});</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="c1">// 创建线程池</span>
    <span class="nc">ExecutorService</span> <span class="n">threadPool</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threadCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="kd">final</span> <span class="kt">int</span> <span class="n">threadNum</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
      <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
      <span class="n">threadPool</span><span class="o">.</span><span class="na">execute</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
          <span class="n">test</span><span class="o">(</span><span class="n">threadNum</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
          <span class="c1">// TODO Auto-generated catch block</span>
          <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">BrokenBarrierException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
          <span class="c1">// TODO Auto-generated catch block</span>
          <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
      <span class="o">});</span>
    <span class="o">}</span>
    <span class="n">threadPool</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="kt">int</span> <span class="n">threadnum</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span><span class="o">,</span> <span class="nc">BrokenBarrierException</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"threadnum:"</span> <span class="o">+</span> <span class="n">threadnum</span> <span class="o">+</span> <span class="s">"is ready"</span><span class="o">);</span>
    <span class="n">cyclicBarrier</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"threadnum:"</span> <span class="o">+</span> <span class="n">threadnum</span> <span class="o">+</span> <span class="s">"is finish"</span><span class="o">);</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>运行结果，如下：</p>

<pre><code class="language-plain">threadnum:0is ready
threadnum:1is ready
threadnum:2is ready
threadnum:3is ready
threadnum:4is ready
------当线程数达到之后，优先执行------
threadnum:4is finish
threadnum:0is finish
threadnum:2is finish
threadnum:1is finish
threadnum:3is finish
threadnum:5is ready
threadnum:6is ready
threadnum:7is ready
threadnum:8is ready
threadnum:9is ready
------当线程数达到之后，优先执行------
threadnum:9is finish
threadnum:5is finish
threadnum:6is finish
threadnum:8is finish
threadnum:7is finish
......
</code></pre>

<h2 id="参考">参考</h2>

<ul>
  <li>Java 并发之 AQS 详解：<a href="https://www.cnblogs.com/waterystone/p/4920797.html">https://www.cnblogs.com/waterystone/p/4920797.html</a></li>
  <li>从 ReentrantLock 的实现看 AQS 的原理及应用：<a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</a></li>
</ul>

<!-- @include: @article-footer.snippet.md -->
