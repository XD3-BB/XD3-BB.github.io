<blockquote>
  <p>本文来自一枝花算不算浪漫投稿， 原文地址：<a href="https://juejin.cn/post/6844904151567040519">https://juejin.cn/post/6844904151567040519</a>。</p>
</blockquote>

<h3 id="前言">前言</h3>

<p><img src="./images/thread-local/1.png" alt="" /></p>

<p><strong>全文共 10000+字，31 张图，这篇文章同样耗费了不少的时间和精力才创作完成，原创不易，请大家点点关注+在看，感谢。</strong></p>

<p>对于<code class="language-plaintext highlighter-rouge">ThreadLocal</code>，大家的第一反应可能是很简单呀，线程的变量副本，每个线程隔离。那这里有几个问题大家可以思考一下：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ThreadLocal</code>的 key 是<strong>弱引用</strong>，那么在 <code class="language-plaintext highlighter-rouge">ThreadLocal.get()</code>的时候，发生<strong>GC</strong>之后，key 是否为<strong>null</strong>？</li>
  <li><code class="language-plaintext highlighter-rouge">ThreadLocal</code>中<code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>的<strong>数据结构</strong>？</li>
  <li><code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>的<strong>Hash 算法</strong>？</li>
  <li><code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>中<strong>Hash 冲突</strong>如何解决？</li>
  <li><code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>的<strong>扩容机制</strong>？</li>
  <li><code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>中<strong>过期 key 的清理机制</strong>？<strong>探测式清理</strong>和<strong>启发式清理</strong>流程？</li>
  <li><code class="language-plaintext highlighter-rouge">ThreadLocalMap.set()</code>方法实现原理？</li>
  <li><code class="language-plaintext highlighter-rouge">ThreadLocalMap.get()</code>方法实现原理？</li>
  <li>项目中<code class="language-plaintext highlighter-rouge">ThreadLocal</code>使用情况？遇到的坑？</li>
  <li>……</li>
</ul>

<p>上述的一些问题你是否都已经掌握的很清楚了呢？本文将围绕这些问题使用图文方式来剖析<code class="language-plaintext highlighter-rouge">ThreadLocal</code>的<strong>点点滴滴</strong>。</p>

<h3 id="目录">目录</h3>

<p><strong>注明：</strong> 本文源码基于<code class="language-plaintext highlighter-rouge">JDK 1.8</code></p>

<h3 id="threadlocal代码演示"><code class="language-plaintext highlighter-rouge">ThreadLocal</code>代码演示</h3>

<p>我们先看下<code class="language-plaintext highlighter-rouge">ThreadLocal</code>使用示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadLocalTest</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">messages</span> <span class="o">=</span> <span class="nc">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">ThreadLocalTest</span><span class="o">&gt;</span> <span class="n">holder</span> <span class="o">=</span> <span class="nc">ThreadLocal</span><span class="o">.</span><span class="na">withInitial</span><span class="o">(</span><span class="nl">ThreadLocalTest:</span><span class="o">:</span><span class="k">new</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">holder</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">messages</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">clear</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">holder</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">messages</span><span class="o">;</span>
        <span class="n">holder</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"size: "</span> <span class="o">+</span> <span class="n">holder</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">messages</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">messages</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ThreadLocalTest</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"一枝花算不算浪漫"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">holder</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">messages</span><span class="o">);</span>
        <span class="nc">ThreadLocalTest</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>打印结果：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="n">一枝花算不算浪漫</span><span class="o">]</span>
<span class="nl">size:</span> <span class="mi">0</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ThreadLocal</code>对象可以提供线程局部变量，每个线程<code class="language-plaintext highlighter-rouge">Thread</code>拥有一份自己的<strong>副本变量</strong>，多个线程互不干扰。</p>

<h3 id="threadlocal的数据结构"><code class="language-plaintext highlighter-rouge">ThreadLocal</code>的数据结构</h3>

<p><img src="./images/thread-local/2.png" alt="" /></p>

<p><code class="language-plaintext highlighter-rouge">Thread</code>类有一个类型为<code class="language-plaintext highlighter-rouge">ThreadLocal.ThreadLocalMap</code>的实例变量<code class="language-plaintext highlighter-rouge">threadLocals</code>，也就是说每个线程有一个自己的<code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>。</p>

<p><code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>有自己的独立实现，可以简单地将它的<code class="language-plaintext highlighter-rouge">key</code>视作<code class="language-plaintext highlighter-rouge">ThreadLocal</code>，<code class="language-plaintext highlighter-rouge">value</code>为代码中放入的值（实际上<code class="language-plaintext highlighter-rouge">key</code>并不是<code class="language-plaintext highlighter-rouge">ThreadLocal</code>本身，而是它的一个<strong>弱引用</strong>）。</p>

<p>每个线程在往<code class="language-plaintext highlighter-rouge">ThreadLocal</code>里放值的时候，都会往自己的<code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>里存，读也是以<code class="language-plaintext highlighter-rouge">ThreadLocal</code>作为引用，在自己的<code class="language-plaintext highlighter-rouge">map</code>里找对应的<code class="language-plaintext highlighter-rouge">key</code>，从而实现了<strong>线程隔离</strong>。</p>

<p><code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>有点类似<code class="language-plaintext highlighter-rouge">HashMap</code>的结构，只是<code class="language-plaintext highlighter-rouge">HashMap</code>是由<strong>数组+链表</strong>实现的，而<code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>中并没有<strong>链表</strong>结构。</p>

<p>我们还要注意<code class="language-plaintext highlighter-rouge">Entry</code>， 它的<code class="language-plaintext highlighter-rouge">key</code>是<code class="language-plaintext highlighter-rouge">ThreadLocal&lt;?&gt; k</code> ，继承自<code class="language-plaintext highlighter-rouge">WeakReference</code>， 也就是我们常说的弱引用类型。</p>

<h3 id="gc-之后-key-是否为-null">GC 之后 key 是否为 null？</h3>

<p>回应开头的那个问题， <code class="language-plaintext highlighter-rouge">ThreadLocal</code> 的<code class="language-plaintext highlighter-rouge">key</code>是弱引用，那么在<code class="language-plaintext highlighter-rouge">ThreadLocal.get()</code>的时候，发生<code class="language-plaintext highlighter-rouge">GC</code>之后，<code class="language-plaintext highlighter-rouge">key</code>是否是<code class="language-plaintext highlighter-rouge">null</code>？</p>

<p>为了搞清楚这个问题，我们需要搞清楚<code class="language-plaintext highlighter-rouge">Java</code>的<strong>四种引用类型</strong>：</p>

<ul>
  <li><strong>强引用</strong>：我们常常 new 出来的对象就是强引用类型，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候</li>
  <li><strong>软引用</strong>：使用 SoftReference 修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收</li>
  <li><strong>弱引用</strong>：使用 WeakReference 修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收</li>
  <li><strong>虚引用</strong>：虚引用是最弱的引用，在 Java 中使用 PhantomReference 进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知</li>
</ul>

<p>接着再来看下代码，我们使用反射的方式来看看<code class="language-plaintext highlighter-rouge">GC</code>后<code class="language-plaintext highlighter-rouge">ThreadLocal</code>中的数据情况：(下面代码来源自：<a href="https://blog.csdn.net/thewindkee/article/details/103726942">https://blog.csdn.net/thewindkee/article/details/103726942</a> 本地运行演示 GC 回收场景)</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadLocalDemo</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">NoSuchFieldException</span><span class="o">,</span> <span class="nc">IllegalAccessException</span><span class="o">,</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;</span><span class="n">test</span><span class="o">(</span><span class="s">"abc"</span><span class="o">,</span><span class="kc">false</span><span class="o">));</span>
        <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"--gc后--"</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">test</span><span class="o">(</span><span class="s">"def"</span><span class="o">,</span> <span class="kc">true</span><span class="o">));</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span><span class="kt">boolean</span> <span class="n">isGC</span><span class="o">)</span>  <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">&lt;&gt;().</span><span class="na">set</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isGC</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">gc</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
            <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Thread</span><span class="o">&gt;</span> <span class="n">clz</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
            <span class="nc">Field</span> <span class="n">field</span> <span class="o">=</span> <span class="n">clz</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"threadLocals"</span><span class="o">);</span>
            <span class="n">field</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
            <span class="nc">Object</span> <span class="nc">ThreadLocalMap</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
            <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">tlmClass</span> <span class="o">=</span> <span class="nc">ThreadLocalMap</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
            <span class="nc">Field</span> <span class="n">tableField</span> <span class="o">=</span> <span class="n">tlmClass</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"table"</span><span class="o">);</span>
            <span class="n">tableField</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
            <span class="nc">Object</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Object</span><span class="o">[])</span> <span class="n">tableField</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="nc">ThreadLocalMap</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Object</span> <span class="n">o</span> <span class="o">:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">entryClass</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
                    <span class="nc">Field</span> <span class="n">valueField</span> <span class="o">=</span> <span class="n">entryClass</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"value"</span><span class="o">);</span>
                    <span class="nc">Field</span> <span class="n">referenceField</span> <span class="o">=</span> <span class="n">entryClass</span><span class="o">.</span><span class="na">getSuperclass</span><span class="o">().</span><span class="na">getSuperclass</span><span class="o">().</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"referent"</span><span class="o">);</span>
                    <span class="n">valueField</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
                    <span class="n">referenceField</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"弱引用key:%s,值:%s"</span><span class="o">,</span> <span class="n">referenceField</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">o</span><span class="o">),</span> <span class="n">valueField</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">o</span><span class="o">)));</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>结果如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">弱引用key:</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">ThreadLocal</span><span class="err">@</span><span class="mi">433619</span><span class="n">b6</span><span class="o">,</span><span class="nl">值:</span><span class="n">abc</span>
<span class="nl">弱引用key:</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">ThreadLocal</span><span class="err">@</span><span class="mi">418</span><span class="n">a15e3</span><span class="o">,</span><span class="nl">值:</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">ref</span><span class="o">.</span><span class="na">SoftReference</span><span class="nd">@bf97a12</span>
<span class="o">--</span><span class="n">gc后</span><span class="o">--</span>
<span class="nl">弱引用key:</span><span class="kc">null</span><span class="o">,</span><span class="nl">值:</span><span class="n">def</span>
</code></pre></div></div>

<p><img src="./images/thread-local/3.png" alt="" /></p>

<p>如图所示，因为这里创建的<code class="language-plaintext highlighter-rouge">ThreadLocal</code>并没有指向任何值，也就是没有任何引用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">&lt;&gt;().</span><span class="na">set</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
</code></pre></div></div>

<p>所以这里在<code class="language-plaintext highlighter-rouge">GC</code>之后，<code class="language-plaintext highlighter-rouge">key</code>就会被回收，我们看到上面<code class="language-plaintext highlighter-rouge">debug</code>中的<code class="language-plaintext highlighter-rouge">referent=null</code>, 如果<strong>改动一下代码：</strong></p>

<p><img src="./images/thread-local/4.png" alt="" /></p>

<p>这个问题刚开始看，如果没有过多思考，<strong>弱引用</strong>，还有<strong>垃圾回收</strong>，那么肯定会觉得是<code class="language-plaintext highlighter-rouge">null</code>。</p>

<p>其实是不对的，因为题目说的是在做 <code class="language-plaintext highlighter-rouge">ThreadLocal.get()</code> 操作，证明其实还是有<strong>强引用</strong>存在的，所以 <code class="language-plaintext highlighter-rouge">key</code> 并不为 <code class="language-plaintext highlighter-rouge">null</code>，如下图所示，<code class="language-plaintext highlighter-rouge">ThreadLocal</code>的<strong>强引用</strong>仍然是存在的。</p>

<p><img src="./images/thread-local/5.png" alt="" /></p>

<p>如果我们的<strong>强引用</strong>不存在的话，那么 <code class="language-plaintext highlighter-rouge">key</code> 就会被回收，也就是会出现我们 <code class="language-plaintext highlighter-rouge">value</code> 没被回收，<code class="language-plaintext highlighter-rouge">key</code> 被回收，导致 <code class="language-plaintext highlighter-rouge">value</code> 永远存在，出现内存泄漏。</p>

<h3 id="threadlocalset方法源码详解"><code class="language-plaintext highlighter-rouge">ThreadLocal.set()</code>方法源码详解</h3>

<p><img src="./images/thread-local/6.png" alt="" /></p>

<p><code class="language-plaintext highlighter-rouge">ThreadLocal</code>中的<code class="language-plaintext highlighter-rouge">set</code>方法原理如上图所示，很简单，主要是判断<code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>是否存在，然后使用<code class="language-plaintext highlighter-rouge">ThreadLocal</code>中的<code class="language-plaintext highlighter-rouge">set</code>方法进行数据处理。</p>

<p>代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
    <span class="nc">ThreadLocalMap</span> <span class="n">map</span> <span class="o">=</span> <span class="n">getMap</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">map</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">map</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
    <span class="k">else</span>
        <span class="nf">createMap</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">createMap</span><span class="o">(</span><span class="nc">Thread</span> <span class="n">t</span><span class="o">,</span> <span class="no">T</span> <span class="n">firstValue</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">t</span><span class="o">.</span><span class="na">threadLocals</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocalMap</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">firstValue</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>主要的核心逻辑还是在<code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>中的，一步步往下看，后面还有更详细的剖析。</p>

<h3 id="threadlocalmap-hash-算法"><code class="language-plaintext highlighter-rouge">ThreadLocalMap</code> Hash 算法</h3>

<p>既然是<code class="language-plaintext highlighter-rouge">Map</code>结构，那么<code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>当然也要实现自己的<code class="language-plaintext highlighter-rouge">hash</code>算法来解决散列表数组冲突问题。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">threadLocalHashCode</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>中<code class="language-plaintext highlighter-rouge">hash</code>算法很简单，这里<code class="language-plaintext highlighter-rouge">i</code>就是当前 key 在散列表中对应的数组下标位置。</p>

<p>这里最关键的就是<code class="language-plaintext highlighter-rouge">threadLocalHashCode</code>值的计算，<code class="language-plaintext highlighter-rouge">ThreadLocal</code>中有一个属性为<code class="language-plaintext highlighter-rouge">HASH_INCREMENT = 0x61c88647</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">threadLocalHashCode</span> <span class="o">=</span> <span class="n">nextHashCode</span><span class="o">();</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">AtomicInteger</span> <span class="n">nextHashCode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AtomicInteger</span><span class="o">();</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">HASH_INCREMENT</span> <span class="o">=</span> <span class="mh">0x61c88647</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">nextHashCode</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">nextHashCode</span><span class="o">.</span><span class="na">getAndAdd</span><span class="o">(</span><span class="no">HASH_INCREMENT</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ThreadLocalMap</span> <span class="o">{</span>
        <span class="nc">ThreadLocalMap</span><span class="o">(</span><span class="nc">ThreadLocal</span><span class="o">&lt;?&gt;</span> <span class="n">firstKey</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">firstValue</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">table</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Entry</span><span class="o">[</span><span class="no">INITIAL_CAPACITY</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">firstKey</span><span class="o">.</span><span class="na">threadLocalHashCode</span> <span class="o">&amp;</span> <span class="o">(</span><span class="no">INITIAL_CAPACITY</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>

            <span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Entry</span><span class="o">(</span><span class="n">firstKey</span><span class="o">,</span> <span class="n">firstValue</span><span class="o">);</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">setThreshold</span><span class="o">(</span><span class="no">INITIAL_CAPACITY</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>每当创建一个<code class="language-plaintext highlighter-rouge">ThreadLocal</code>对象，这个<code class="language-plaintext highlighter-rouge">ThreadLocal.nextHashCode</code> 这个值就会增长 <code class="language-plaintext highlighter-rouge">0x61c88647</code> 。</p>

<p>这个值很特殊，它是<strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong>。<code class="language-plaintext highlighter-rouge">hash</code>增量为 这个数字，带来的好处就是 <code class="language-plaintext highlighter-rouge">hash</code> <strong>分布非常均匀</strong>。</p>

<p>我们自己可以尝试下：</p>

<p><img src="./images/thread-local/8.png" alt="" /></p>

<p>可以看到产生的哈希码分布很均匀，这里不去细纠<strong>斐波那契</strong>具体算法，感兴趣的可以自行查阅相关资料。</p>

<h3 id="threadlocalmap-hash-冲突"><code class="language-plaintext highlighter-rouge">ThreadLocalMap</code> Hash 冲突</h3>

<blockquote>
  <p><strong>注明：</strong> 下面所有示例图中，<strong>绿色块</strong><code class="language-plaintext highlighter-rouge">Entry</code>代表<strong>正常数据</strong>，<strong>灰色块</strong>代表<code class="language-plaintext highlighter-rouge">Entry</code>的<code class="language-plaintext highlighter-rouge">key</code>值为<code class="language-plaintext highlighter-rouge">null</code>，<strong>已被垃圾回收</strong>。<strong>白色块</strong>表示<code class="language-plaintext highlighter-rouge">Entry</code>为<code class="language-plaintext highlighter-rouge">null</code>。</p>
</blockquote>

<p>虽然<code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>中使用了<strong>黄金分割数</strong>来作为<code class="language-plaintext highlighter-rouge">hash</code>计算因子，大大减少了<code class="language-plaintext highlighter-rouge">Hash</code>冲突的概率，但是仍然会存在冲突。</p>

<p><code class="language-plaintext highlighter-rouge">HashMap</code>中解决冲突的方法是在数组上构造一个<strong>链表</strong>结构，冲突的数据挂载到链表上，如果链表长度超过一定数量则会转化成<strong>红黑树</strong>。</p>

<p>而 <code class="language-plaintext highlighter-rouge">ThreadLocalMap</code> 中并没有链表结构，所以这里不能使用 <code class="language-plaintext highlighter-rouge">HashMap</code> 解决冲突的方式了。</p>

<p><img src="./images/thread-local/7.png" alt="" /></p>

<p>如上图所示，如果我们插入一个<code class="language-plaintext highlighter-rouge">value=27</code>的数据，通过 <code class="language-plaintext highlighter-rouge">hash</code> 计算后应该落入槽位 4 中，而槽位 4 已经有了 <code class="language-plaintext highlighter-rouge">Entry</code> 数据。</p>

<p>此时就会线性向后查找，一直找到 <code class="language-plaintext highlighter-rouge">Entry</code> 为 <code class="language-plaintext highlighter-rouge">null</code> 的槽位才会停止查找，将当前元素放入此槽位中。当然迭代过程中还有其他的情况，比如遇到了 <code class="language-plaintext highlighter-rouge">Entry</code> 不为 <code class="language-plaintext highlighter-rouge">null</code> 且 <code class="language-plaintext highlighter-rouge">key</code> 值相等的情况，还有 <code class="language-plaintext highlighter-rouge">Entry</code> 中的 <code class="language-plaintext highlighter-rouge">key</code> 值为 <code class="language-plaintext highlighter-rouge">null</code> 的情况等等都会有不同的处理，后面会一一详细讲解。</p>

<p>这里还画了一个<code class="language-plaintext highlighter-rouge">Entry</code>中的<code class="language-plaintext highlighter-rouge">key</code>为<code class="language-plaintext highlighter-rouge">null</code>的数据（<strong>Entry=2 的灰色块数据</strong>），因为<code class="language-plaintext highlighter-rouge">key</code>值是<strong>弱引用</strong>类型，所以会有这种数据存在。在<code class="language-plaintext highlighter-rouge">set</code>过程中，如果遇到了<code class="language-plaintext highlighter-rouge">key</code>过期的<code class="language-plaintext highlighter-rouge">Entry</code>数据，实际上是会进行一轮<strong>探测式清理</strong>操作的，具体操作方式后面会讲到。</p>

<h3 id="threadlocalmapset详解"><code class="language-plaintext highlighter-rouge">ThreadLocalMap.set()</code>详解</h3>

<h4 id="threadlocalmapset原理图解"><code class="language-plaintext highlighter-rouge">ThreadLocalMap.set()</code>原理图解</h4>

<p>看完了<code class="language-plaintext highlighter-rouge">ThreadLocal</code> <strong>hash 算法</strong>后，我们再来看<code class="language-plaintext highlighter-rouge">set</code>是如何实现的。</p>

<p>往<code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>中<code class="language-plaintext highlighter-rouge">set</code>数据（<strong>新增</strong>或者<strong>更新</strong>数据）分为好几种情况，针对不同的情况我们画图来说明。</p>

<p><strong>第一种情况：</strong> 通过<code class="language-plaintext highlighter-rouge">hash</code>计算后的槽位对应的<code class="language-plaintext highlighter-rouge">Entry</code>数据为空：</p>

<p><img src="./images/thread-local/9.png" alt="" /></p>

<p>这里直接将数据放到该槽位即可。</p>

<p><strong>第二种情况：</strong> 槽位数据不为空，<code class="language-plaintext highlighter-rouge">key</code>值与当前<code class="language-plaintext highlighter-rouge">ThreadLocal</code>通过<code class="language-plaintext highlighter-rouge">hash</code>计算获取的<code class="language-plaintext highlighter-rouge">key</code>值一致：</p>

<p><img src="./images/thread-local/10.png" alt="" /></p>

<p>这里直接更新该槽位的数据。</p>

<p><strong>第三种情况：</strong> 槽位数据不为空，往后遍历过程中，在找到<code class="language-plaintext highlighter-rouge">Entry</code>为<code class="language-plaintext highlighter-rouge">null</code>的槽位之前，没有遇到<code class="language-plaintext highlighter-rouge">key</code>过期的<code class="language-plaintext highlighter-rouge">Entry</code>：</p>

<p><img src="./images/thread-local/11.png" alt="" /></p>

<p>遍历散列数组，线性往后查找，如果找到<code class="language-plaintext highlighter-rouge">Entry</code>为<code class="language-plaintext highlighter-rouge">null</code>的槽位，则将数据放入该槽位中，或者往后遍历过程中，遇到了<strong>key 值相等</strong>的数据，直接更新即可。</p>

<p><strong>第四种情况：</strong> 槽位数据不为空，往后遍历过程中，在找到<code class="language-plaintext highlighter-rouge">Entry</code>为<code class="language-plaintext highlighter-rouge">null</code>的槽位之前，遇到<code class="language-plaintext highlighter-rouge">key</code>过期的<code class="language-plaintext highlighter-rouge">Entry</code>，如下图，往后遍历过程中，遇到了<code class="language-plaintext highlighter-rouge">index=7</code>的槽位数据<code class="language-plaintext highlighter-rouge">Entry</code>的<code class="language-plaintext highlighter-rouge">key=null</code>：</p>

<p><img src="./images/thread-local/12.png" alt="" /></p>

<p>散列数组下标为 7 位置对应的<code class="language-plaintext highlighter-rouge">Entry</code>数据<code class="language-plaintext highlighter-rouge">key</code>为<code class="language-plaintext highlighter-rouge">null</code>，表明此数据<code class="language-plaintext highlighter-rouge">key</code>值已经被垃圾回收掉了，此时就会执行<code class="language-plaintext highlighter-rouge">replaceStaleEntry()</code>方法，该方法含义是<strong>替换过期数据的逻辑</strong>，以<strong>index=7</strong>位起点开始遍历，进行探测式数据清理工作。</p>

<p>初始化探测式清理过期数据扫描的开始位置：<code class="language-plaintext highlighter-rouge">slotToExpunge = staleSlot = 7</code></p>

<p>以当前<code class="language-plaintext highlighter-rouge">staleSlot</code>开始 向前迭代查找，找其他过期的数据，然后更新过期数据起始扫描下标<code class="language-plaintext highlighter-rouge">slotToExpunge</code>。<code class="language-plaintext highlighter-rouge">for</code>循环迭代，直到碰到<code class="language-plaintext highlighter-rouge">Entry</code>为<code class="language-plaintext highlighter-rouge">null</code>结束。</p>

<p>如果找到了过期的数据，继续向前迭代，直到遇到<code class="language-plaintext highlighter-rouge">Entry=null</code>的槽位才停止迭代，如下图所示，<strong>slotToExpunge 被更新为 0</strong>：</p>

<p><img src="./images/thread-local/13.png" alt="" /></p>

<p>以当前节点(<code class="language-plaintext highlighter-rouge">index=7</code>)向前迭代，检测是否有过期的<code class="language-plaintext highlighter-rouge">Entry</code>数据，如果有则更新<code class="language-plaintext highlighter-rouge">slotToExpunge</code>值。碰到<code class="language-plaintext highlighter-rouge">null</code>则结束探测。以上图为例<code class="language-plaintext highlighter-rouge">slotToExpunge</code>被更新为 0。</p>

<p>上面向前迭代的操作是为了更新探测清理过期数据的起始下标<code class="language-plaintext highlighter-rouge">slotToExpunge</code>的值，这个值在后面会讲解，它是用来判断当前过期槽位<code class="language-plaintext highlighter-rouge">staleSlot</code>之前是否还有过期元素。</p>

<p>接着开始以<code class="language-plaintext highlighter-rouge">staleSlot</code>位置(<code class="language-plaintext highlighter-rouge">index=7</code>)向后迭代，<strong>如果找到了相同 key 值的 Entry 数据：</strong></p>

<p><img src="./images/thread-local/14.png" alt="" /></p>

<p>从当前节点<code class="language-plaintext highlighter-rouge">staleSlot</code>向后查找<code class="language-plaintext highlighter-rouge">key</code>值相等的<code class="language-plaintext highlighter-rouge">Entry</code>元素，找到后更新<code class="language-plaintext highlighter-rouge">Entry</code>的值并交换<code class="language-plaintext highlighter-rouge">staleSlot</code>元素的位置(<code class="language-plaintext highlighter-rouge">staleSlot</code>位置为过期元素)，更新<code class="language-plaintext highlighter-rouge">Entry</code>数据，然后开始进行过期<code class="language-plaintext highlighter-rouge">Entry</code>的清理工作，如下图所示：</p>

<p><img src="https://oss.javaguide.cn/java-guide-blog/view.png" alt="" />向后遍历过程中，如果没有找到相同 key 值的 Entry 数据：</p>

<p><img src="./images/thread-local/15.png" alt="" /></p>

<p>从当前节点<code class="language-plaintext highlighter-rouge">staleSlot</code>向后查找<code class="language-plaintext highlighter-rouge">key</code>值相等的<code class="language-plaintext highlighter-rouge">Entry</code>元素，直到<code class="language-plaintext highlighter-rouge">Entry</code>为<code class="language-plaintext highlighter-rouge">null</code>则停止寻找。通过上图可知，此时<code class="language-plaintext highlighter-rouge">table</code>中没有<code class="language-plaintext highlighter-rouge">key</code>值相同的<code class="language-plaintext highlighter-rouge">Entry</code>。</p>

<p>创建新的<code class="language-plaintext highlighter-rouge">Entry</code>，替换<code class="language-plaintext highlighter-rouge">table[stableSlot]</code>位置：</p>

<p><img src="./images/thread-local/16.png" alt="" /></p>

<p>替换完成后也是进行过期元素清理工作，清理工作主要是有两个方法：<code class="language-plaintext highlighter-rouge">expungeStaleEntry()</code>和<code class="language-plaintext highlighter-rouge">cleanSomeSlots()</code>，具体细节后面会讲到，请继续往后看。</p>

<h4 id="threadlocalmapset源码详解"><code class="language-plaintext highlighter-rouge">ThreadLocalMap.set()</code>源码详解</h4>

<p>上面已经用图的方式解析了<code class="language-plaintext highlighter-rouge">set()</code>实现的原理，其实已经很清晰了，我们接着再看下源码：</p>

<p><code class="language-plaintext highlighter-rouge">java.lang.ThreadLocal</code>.<code class="language-plaintext highlighter-rouge">ThreadLocalMap.set()</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">ThreadLocal</span><span class="o">&lt;?&gt;</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Entry</span><span class="o">[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">threadLocalHashCode</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>

    <span class="k">for</span> <span class="o">(</span><span class="nc">Entry</span> <span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
         <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
         <span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="n">nextIndex</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">len</span><span class="o">)])</span> <span class="o">{</span>
        <span class="nc">ThreadLocal</span><span class="o">&lt;?&gt;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">replaceStaleEntry</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Entry</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="o">++</span><span class="n">size</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">cleanSomeSlots</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">sz</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">sz</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="o">)</span>
        <span class="n">rehash</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这里会通过<code class="language-plaintext highlighter-rouge">key</code>来计算在散列表中的对应位置，然后以当前<code class="language-plaintext highlighter-rouge">key</code>对应的桶的位置向后查找，找到可以使用的桶。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Entry</span><span class="o">[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">threadLocalHashCode</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
</code></pre></div></div>

<p>什么情况下桶才是可以使用的呢？</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">k = key</code> 说明是替换操作，可以使用</li>
  <li>碰到一个过期的桶，执行替换逻辑，占用过期桶</li>
  <li>查找过程中，碰到桶中<code class="language-plaintext highlighter-rouge">Entry=null</code>的情况，直接使用</li>
</ol>

<p>接着就是执行<code class="language-plaintext highlighter-rouge">for</code>循环遍历，向后查找，我们先看下<code class="language-plaintext highlighter-rouge">nextIndex()</code>、<code class="language-plaintext highlighter-rouge">prevIndex()</code>方法实现：</p>

<p><img src="./images/thread-local/17.png" alt="" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">nextIndex</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">)</span> <span class="o">?</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">prevIndex</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">((</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>接着看剩下<code class="language-plaintext highlighter-rouge">for</code>循环中的逻辑：</p>

<ol>
  <li>遍历当前<code class="language-plaintext highlighter-rouge">key</code>值对应的桶中<code class="language-plaintext highlighter-rouge">Entry</code>数据为空，这说明散列数组这里没有数据冲突，跳出<code class="language-plaintext highlighter-rouge">for</code>循环，直接<code class="language-plaintext highlighter-rouge">set</code>数据到对应的桶中</li>
  <li>如果<code class="language-plaintext highlighter-rouge">key</code>值对应的桶中<code class="language-plaintext highlighter-rouge">Entry</code>数据不为空<br />
2.1 如果<code class="language-plaintext highlighter-rouge">k = key</code>，说明当前<code class="language-plaintext highlighter-rouge">set</code>操作是一个替换操作，做替换逻辑，直接返回<br />
2.2 如果<code class="language-plaintext highlighter-rouge">key = null</code>，说明当前桶位置的<code class="language-plaintext highlighter-rouge">Entry</code>是过期数据，执行<code class="language-plaintext highlighter-rouge">replaceStaleEntry()</code>方法(核心方法)，然后返回</li>
  <li><code class="language-plaintext highlighter-rouge">for</code>循环执行完毕，继续往下执行说明向后迭代的过程中遇到了<code class="language-plaintext highlighter-rouge">entry</code>为<code class="language-plaintext highlighter-rouge">null</code>的情况<br />
3.1 在<code class="language-plaintext highlighter-rouge">Entry</code>为<code class="language-plaintext highlighter-rouge">null</code>的桶中创建一个新的<code class="language-plaintext highlighter-rouge">Entry</code>对象<br />
3.2 执行<code class="language-plaintext highlighter-rouge">++size</code>操作</li>
  <li>调用<code class="language-plaintext highlighter-rouge">cleanSomeSlots()</code>做一次启发式清理工作，清理散列数组中<code class="language-plaintext highlighter-rouge">Entry</code>的<code class="language-plaintext highlighter-rouge">key</code>过期的数据<br />
4.1 如果清理工作完成后，未清理到任何数据，且<code class="language-plaintext highlighter-rouge">size</code>超过了阈值(数组长度的 2/3)，进行<code class="language-plaintext highlighter-rouge">rehash()</code>操作<br />
4.2 <code class="language-plaintext highlighter-rouge">rehash()</code>中会先进行一轮探测式清理，清理过期<code class="language-plaintext highlighter-rouge">key</code>，清理完成后如果<strong>size &gt;= threshold - threshold / 4</strong>，就会执行真正的扩容逻辑(扩容逻辑往后看)</li>
</ol>

<p>接着重点看下<code class="language-plaintext highlighter-rouge">replaceStaleEntry()</code>方法，<code class="language-plaintext highlighter-rouge">replaceStaleEntry()</code>方法提供替换过期数据的功能，我们可以对应上面<strong>第四种情况</strong>的原理图来再回顾下，具体代码如下：</p>

<p><code class="language-plaintext highlighter-rouge">java.lang.ThreadLocal.ThreadLocalMap.replaceStaleEntry()</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">replaceStaleEntry</span><span class="o">(</span><span class="nc">ThreadLocal</span><span class="o">&lt;?&gt;</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">value</span><span class="o">,</span>
                                       <span class="kt">int</span> <span class="n">staleSlot</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Entry</span><span class="o">[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="nc">Entry</span> <span class="n">e</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">slotToExpunge</span> <span class="o">=</span> <span class="n">staleSlot</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">prevIndex</span><span class="o">(</span><span class="n">staleSlot</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
         <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
         <span class="n">i</span> <span class="o">=</span> <span class="n">prevIndex</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">len</span><span class="o">))</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">slotToExpunge</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nextIndex</span><span class="o">(</span><span class="n">staleSlot</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
         <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
         <span class="n">i</span> <span class="o">=</span> <span class="n">nextIndex</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">len</span><span class="o">))</span> <span class="o">{</span>

        <span class="nc">ThreadLocal</span><span class="o">&lt;?&gt;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>

            <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">staleSlot</span><span class="o">];</span>
            <span class="n">tab</span><span class="o">[</span><span class="n">staleSlot</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">slotToExpunge</span> <span class="o">==</span> <span class="n">staleSlot</span><span class="o">)</span>
                <span class="n">slotToExpunge</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="n">cleanSomeSlots</span><span class="o">(</span><span class="n">expungeStaleEntry</span><span class="o">(</span><span class="n">slotToExpunge</span><span class="o">),</span> <span class="n">len</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">slotToExpunge</span> <span class="o">==</span> <span class="n">staleSlot</span><span class="o">)</span>
            <span class="n">slotToExpunge</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">tab</span><span class="o">[</span><span class="n">staleSlot</span><span class="o">].</span><span class="na">value</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">tab</span><span class="o">[</span><span class="n">staleSlot</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Entry</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">slotToExpunge</span> <span class="o">!=</span> <span class="n">staleSlot</span><span class="o">)</span>
        <span class="n">cleanSomeSlots</span><span class="o">(</span><span class="n">expungeStaleEntry</span><span class="o">(</span><span class="n">slotToExpunge</span><span class="o">),</span> <span class="n">len</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">slotToExpunge</code>表示开始探测式清理过期数据的开始下标，默认从当前的<code class="language-plaintext highlighter-rouge">staleSlot</code>开始。以当前的<code class="language-plaintext highlighter-rouge">staleSlot</code>开始，向前迭代查找，找到没有过期的数据，<code class="language-plaintext highlighter-rouge">for</code>循环一直碰到<code class="language-plaintext highlighter-rouge">Entry</code>为<code class="language-plaintext highlighter-rouge">null</code>才会结束。如果向前找到了过期数据，更新探测清理过期数据的开始下标为 i，即<code class="language-plaintext highlighter-rouge">slotToExpunge=i</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">prevIndex</span><span class="o">(</span><span class="n">staleSlot</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
     <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
     <span class="n">i</span> <span class="o">=</span> <span class="n">prevIndex</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">len</span><span class="o">)){</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
        <span class="n">slotToExpunge</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>接着开始从<code class="language-plaintext highlighter-rouge">staleSlot</code>向后查找，也是碰到<code class="language-plaintext highlighter-rouge">Entry</code>为<code class="language-plaintext highlighter-rouge">null</code>的桶结束。
如果迭代过程中，<strong>碰到 k == key</strong>，这说明这里是替换逻辑，替换新数据并且交换当前<code class="language-plaintext highlighter-rouge">staleSlot</code>位置。如果<code class="language-plaintext highlighter-rouge">slotToExpunge == staleSlot</code>，这说明<code class="language-plaintext highlighter-rouge">replaceStaleEntry()</code>一开始向前查找过期数据时并未找到过期的<code class="language-plaintext highlighter-rouge">Entry</code>数据，接着向后查找过程中也未发现过期数据，修改开始探测式清理过期数据的下标为当前循环的 index，即<code class="language-plaintext highlighter-rouge">slotToExpunge = i</code>。最后调用<code class="language-plaintext highlighter-rouge">cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</code>进行启发式过期数据清理。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>

    <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">staleSlot</span><span class="o">];</span>
    <span class="n">tab</span><span class="o">[</span><span class="n">staleSlot</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">slotToExpunge</span> <span class="o">==</span> <span class="n">staleSlot</span><span class="o">)</span>
        <span class="n">slotToExpunge</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

    <span class="n">cleanSomeSlots</span><span class="o">(</span><span class="n">expungeStaleEntry</span><span class="o">(</span><span class="n">slotToExpunge</span><span class="o">),</span> <span class="n">len</span><span class="o">);</span>
    <span class="k">return</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">cleanSomeSlots()</code>和<code class="language-plaintext highlighter-rouge">expungeStaleEntry()</code>方法后面都会细讲，这两个是和清理相关的方法，一个是过期<code class="language-plaintext highlighter-rouge">key</code>相关<code class="language-plaintext highlighter-rouge">Entry</code>的启发式清理(<code class="language-plaintext highlighter-rouge">Heuristically scan</code>)，另一个是过期<code class="language-plaintext highlighter-rouge">key</code>相关<code class="language-plaintext highlighter-rouge">Entry</code>的探测式清理。</p>

<p><strong>如果 k != key</strong>则会接着往下走，<code class="language-plaintext highlighter-rouge">k == null</code>说明当前遍历的<code class="language-plaintext highlighter-rouge">Entry</code>是一个过期数据，<code class="language-plaintext highlighter-rouge">slotToExpunge == staleSlot</code>说明，一开始的向前查找数据并未找到过期的<code class="language-plaintext highlighter-rouge">Entry</code>。如果条件成立，则更新<code class="language-plaintext highlighter-rouge">slotToExpunge</code> 为当前位置，这个前提是前驱节点扫描时未发现过期数据。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">slotToExpunge</span> <span class="o">==</span> <span class="n">staleSlot</span><span class="o">)</span>
    <span class="n">slotToExpunge</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
</code></pre></div></div>

<p>往后迭代的过程中如果没有找到<code class="language-plaintext highlighter-rouge">k == key</code>的数据，且碰到<code class="language-plaintext highlighter-rouge">Entry</code>为<code class="language-plaintext highlighter-rouge">null</code>的数据，则结束当前的迭代操作。此时说明这里是一个添加的逻辑，将新的数据添加到<code class="language-plaintext highlighter-rouge">table[staleSlot]</code> 对应的<code class="language-plaintext highlighter-rouge">slot</code>中。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tab</span><span class="o">[</span><span class="n">staleSlot</span><span class="o">].</span><span class="na">value</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="n">tab</span><span class="o">[</span><span class="n">staleSlot</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Entry</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
</code></pre></div></div>

<p>最后判断除了<code class="language-plaintext highlighter-rouge">staleSlot</code>以外，还发现了其他过期的<code class="language-plaintext highlighter-rouge">slot</code>数据，就要开启清理数据的逻辑：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">slotToExpunge</span> <span class="o">!=</span> <span class="n">staleSlot</span><span class="o">)</span>
    <span class="n">cleanSomeSlots</span><span class="o">(</span><span class="n">expungeStaleEntry</span><span class="o">(</span><span class="n">slotToExpunge</span><span class="o">),</span> <span class="n">len</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="threadlocalmap过期-key-的探测式清理流程"><code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>过期 key 的探测式清理流程</h3>

<p>上面我们有提及<code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>的两种过期<code class="language-plaintext highlighter-rouge">key</code>数据清理方式：<strong>探测式清理</strong>和<strong>启发式清理</strong>。</p>

<p>我们先讲下探测式清理，也就是<code class="language-plaintext highlighter-rouge">expungeStaleEntry</code>方法，遍历散列数组，从开始位置向后探测清理过期数据，将过期数据的<code class="language-plaintext highlighter-rouge">Entry</code>设置为<code class="language-plaintext highlighter-rouge">null</code>，沿途中碰到未过期的数据则将此数据<code class="language-plaintext highlighter-rouge">rehash</code>后重新在<code class="language-plaintext highlighter-rouge">table</code>数组中定位，如果定位的位置已经有了数据，则会将未过期的数据放到最靠近此位置的<code class="language-plaintext highlighter-rouge">Entry=null</code>的桶中，使<code class="language-plaintext highlighter-rouge">rehash</code>后的<code class="language-plaintext highlighter-rouge">Entry</code>数据距离正确的桶的位置更近一些。操作逻辑如下：</p>

<p><img src="./images/thread-local/18.png" alt="" /></p>

<p>如上图，<code class="language-plaintext highlighter-rouge">set(27)</code> 经过 hash 计算后应该落到<code class="language-plaintext highlighter-rouge">index=4</code>的桶中，由于<code class="language-plaintext highlighter-rouge">index=4</code>桶已经有了数据，所以往后迭代最终数据放入到<code class="language-plaintext highlighter-rouge">index=7</code>的桶中，放入后一段时间后<code class="language-plaintext highlighter-rouge">index=5</code>中的<code class="language-plaintext highlighter-rouge">Entry</code>数据<code class="language-plaintext highlighter-rouge">key</code>变为了<code class="language-plaintext highlighter-rouge">null</code></p>

<p><img src="./images/thread-local/19.png" alt="" /></p>

<p>如果再有其他数据<code class="language-plaintext highlighter-rouge">set</code>到<code class="language-plaintext highlighter-rouge">map</code>中，就会触发<strong>探测式清理</strong>操作。</p>

<p>如上图，执行<strong>探测式清理</strong>后，<code class="language-plaintext highlighter-rouge">index=5</code>的数据被清理掉，继续往后迭代，到<code class="language-plaintext highlighter-rouge">index=7</code>的元素时，经过<code class="language-plaintext highlighter-rouge">rehash</code>后发现该元素正确的<code class="language-plaintext highlighter-rouge">index=4</code>，而此位置已经有了数据，往后查找离<code class="language-plaintext highlighter-rouge">index=4</code>最近的<code class="language-plaintext highlighter-rouge">Entry=null</code>的节点(刚被探测式清理掉的数据：<code class="language-plaintext highlighter-rouge">index=5</code>)，找到后移动<code class="language-plaintext highlighter-rouge">index= 7</code>的数据到<code class="language-plaintext highlighter-rouge">index=5</code>中，此时桶的位置离正确的位置<code class="language-plaintext highlighter-rouge">index=4</code>更近了。</p>

<p>经过一轮探测式清理后，<code class="language-plaintext highlighter-rouge">key</code>过期的数据会被清理掉，没过期的数据经过<code class="language-plaintext highlighter-rouge">rehash</code>重定位后所处的桶位置理论上更接近<code class="language-plaintext highlighter-rouge">i= key.hashCode &amp; (tab.len - 1)</code>的位置。这种优化会提高整个散列表查询性能。</p>

<p>接着看下<code class="language-plaintext highlighter-rouge">expungeStaleEntry()</code>具体流程，我们还是以先原理图后源码讲解的方式来一步步梳理：</p>

<p><img src="./images/thread-local/20.png" alt="" /></p>

<p>我们假设<code class="language-plaintext highlighter-rouge">expungeStaleEntry(3)</code> 来调用此方法，如上图所示，我们可以看到<code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>中<code class="language-plaintext highlighter-rouge">table</code>的数据情况，接着执行清理操作：</p>

<p><img src="./images/thread-local/21.png" alt="" /></p>

<p>第一步是清空当前<code class="language-plaintext highlighter-rouge">staleSlot</code>位置的数据，<code class="language-plaintext highlighter-rouge">index=3</code>位置的<code class="language-plaintext highlighter-rouge">Entry</code>变成了<code class="language-plaintext highlighter-rouge">null</code>。然后接着往后探测：</p>

<p><img src="./images/thread-local/22.png" alt="" /></p>

<p>执行完第二步后，index=4 的元素挪到 index=3 的槽位中。</p>

<p>继续往后迭代检查，碰到正常数据，计算该数据位置是否偏移，如果被偏移，则重新计算<code class="language-plaintext highlighter-rouge">slot</code>位置，目的是让正常数据尽可能存放在正确位置或离正确位置更近的位置</p>

<p><img src="./images/thread-local/23.png" alt="" /></p>

<p>在往后迭代的过程中碰到空的槽位，终止探测，这样一轮探测式清理工作就完成了，接着我们继续看看具体<strong>实现源代码</strong>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">int</span> <span class="nf">expungeStaleEntry</span><span class="o">(</span><span class="kt">int</span> <span class="n">staleSlot</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Entry</span><span class="o">[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

    <span class="n">tab</span><span class="o">[</span><span class="n">staleSlot</span><span class="o">].</span><span class="na">value</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">tab</span><span class="o">[</span><span class="n">staleSlot</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">size</span><span class="o">--;</span>

    <span class="nc">Entry</span> <span class="n">e</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">nextIndex</span><span class="o">(</span><span class="n">staleSlot</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
         <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
         <span class="n">i</span> <span class="o">=</span> <span class="n">nextIndex</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">len</span><span class="o">))</span> <span class="o">{</span>
        <span class="nc">ThreadLocal</span><span class="o">&lt;?&gt;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">size</span><span class="o">--;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="na">threadLocalHashCode</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

                <span class="k">while</span> <span class="o">(</span><span class="n">tab</span><span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="n">nextIndex</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
                <span class="n">tab</span><span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这里我们还是以<code class="language-plaintext highlighter-rouge">staleSlot=3</code> 来做示例说明，首先是将<code class="language-plaintext highlighter-rouge">tab[staleSlot]</code>槽位的数据清空，然后设置<code class="language-plaintext highlighter-rouge">size--</code>
接着以<code class="language-plaintext highlighter-rouge">staleSlot</code>位置往后迭代，如果遇到<code class="language-plaintext highlighter-rouge">k==null</code>的过期数据，也是清空该槽位数据，然后<code class="language-plaintext highlighter-rouge">size--</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ThreadLocal</span><span class="o">&lt;?&gt;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>

<span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">size</span><span class="o">--;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>如果<code class="language-plaintext highlighter-rouge">key</code>没有过期，重新计算当前<code class="language-plaintext highlighter-rouge">key</code>的下标位置是不是当前槽位下标位置，如果不是，那么说明产生了<code class="language-plaintext highlighter-rouge">hash</code>冲突，此时以新计算出来正确的槽位位置往后迭代，找到最近一个可以存放<code class="language-plaintext highlighter-rouge">entry</code>的位置。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="na">threadLocalHashCode</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">tab</span><span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">nextIndex</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>

    <span class="n">tab</span><span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这里是处理正常的产生<code class="language-plaintext highlighter-rouge">Hash</code>冲突的数据，经过迭代后，有过<code class="language-plaintext highlighter-rouge">Hash</code>冲突数据的<code class="language-plaintext highlighter-rouge">Entry</code>位置会更靠近正确位置，这样的话，查询的时候 效率才会更高。</p>

<h3 id="threadlocalmap扩容机制"><code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>扩容机制</h3>

<p>在<code class="language-plaintext highlighter-rouge">ThreadLocalMap.set()</code>方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中<code class="language-plaintext highlighter-rouge">Entry</code>的数量已经达到了列表的扩容阈值<code class="language-plaintext highlighter-rouge">(len*2/3)</code>，就开始执行<code class="language-plaintext highlighter-rouge">rehash()</code>逻辑：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(!</span><span class="n">cleanSomeSlots</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">sz</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">sz</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="o">)</span>
    <span class="n">rehash</span><span class="o">();</span>
</code></pre></div></div>

<p>接着看下<code class="language-plaintext highlighter-rouge">rehash()</code>具体实现：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">rehash</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">expungeStaleEntries</span><span class="o">();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">threshold</span> <span class="o">-</span> <span class="n">threshold</span> <span class="o">/</span> <span class="mi">4</span><span class="o">)</span>
        <span class="n">resize</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">expungeStaleEntries</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Entry</span><span class="o">[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
        <span class="nc">Entry</span> <span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">e</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">expungeStaleEntry</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这里首先是会进行探测式清理工作，从<code class="language-plaintext highlighter-rouge">table</code>的起始位置往后清理，上面有分析清理的详细流程。清理完成之后，<code class="language-plaintext highlighter-rouge">table</code>中可能有一些<code class="language-plaintext highlighter-rouge">key</code>为<code class="language-plaintext highlighter-rouge">null</code>的<code class="language-plaintext highlighter-rouge">Entry</code>数据被清理掉，所以此时通过判断<code class="language-plaintext highlighter-rouge">size &gt;= threshold - threshold / 4</code> 也就是<code class="language-plaintext highlighter-rouge">size &gt;= threshold * 3/4</code> 来决定是否扩容。</p>

<p>我们还记得上面进行<code class="language-plaintext highlighter-rouge">rehash()</code>的阈值是<code class="language-plaintext highlighter-rouge">size &gt;= threshold</code>，所以当面试官套路我们<code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>扩容机制的时候 我们一定要说清楚这两个步骤：</p>

<p><img src="./images/thread-local/24.png" alt="" /></p>

<p>接着看看具体的<code class="language-plaintext highlighter-rouge">resize()</code>方法，为了方便演示，我们以<code class="language-plaintext highlighter-rouge">oldTab.len=8</code>来举例：</p>

<p><img src="./images/thread-local/25.png" alt="" /></p>

<p>扩容后的<code class="language-plaintext highlighter-rouge">tab</code>的大小为<code class="language-plaintext highlighter-rouge">oldLen * 2</code>，然后遍历老的散列表，重新计算<code class="language-plaintext highlighter-rouge">hash</code>位置，然后放到新的<code class="language-plaintext highlighter-rouge">tab</code>数组中，如果出现<code class="language-plaintext highlighter-rouge">hash</code>冲突则往后寻找最近的<code class="language-plaintext highlighter-rouge">entry</code>为<code class="language-plaintext highlighter-rouge">null</code>的槽位，遍历完成之后，<code class="language-plaintext highlighter-rouge">oldTab</code>中所有的<code class="language-plaintext highlighter-rouge">entry</code>数据都已经放入到新的<code class="language-plaintext highlighter-rouge">tab</code>中了。重新计算<code class="language-plaintext highlighter-rouge">tab</code>下次扩容的<strong>阈值</strong>，具体代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">resize</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Entry</span><span class="o">[]</span> <span class="n">oldTab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">oldLen</span> <span class="o">=</span> <span class="n">oldTab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">newLen</span> <span class="o">=</span> <span class="n">oldLen</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
    <span class="nc">Entry</span><span class="o">[]</span> <span class="n">newTab</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Entry</span><span class="o">[</span><span class="n">newLen</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">oldLen</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Entry</span> <span class="n">e</span> <span class="o">=</span> <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">ThreadLocal</span><span class="o">&lt;?&gt;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="na">threadLocalHashCode</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">newLen</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">newTab</span><span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="n">nextIndex</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">newLen</span><span class="o">);</span>
                <span class="n">newTab</span><span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="n">setThreshold</span><span class="o">(</span><span class="n">newLen</span><span class="o">);</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">newTab</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="threadlocalmapget详解"><code class="language-plaintext highlighter-rouge">ThreadLocalMap.get()</code>详解</h3>

<p>上面已经看完了<code class="language-plaintext highlighter-rouge">set()</code>方法的源码，其中包括<code class="language-plaintext highlighter-rouge">set</code>数据、清理数据、优化数据桶的位置等操作，接着看看<code class="language-plaintext highlighter-rouge">get()</code>操作的原理。</p>

<h4 id="threadlocalmapget图解"><code class="language-plaintext highlighter-rouge">ThreadLocalMap.get()</code>图解</h4>

<p><strong>第一种情况：</strong> 通过查找<code class="language-plaintext highlighter-rouge">key</code>值计算出散列表中<code class="language-plaintext highlighter-rouge">slot</code>位置，然后该<code class="language-plaintext highlighter-rouge">slot</code>位置中的<code class="language-plaintext highlighter-rouge">Entry.key</code>和查找的<code class="language-plaintext highlighter-rouge">key</code>一致，则直接返回：</p>

<p><img src="./images/thread-local/26.png" alt="" /></p>

<p><strong>第二种情况：</strong> <code class="language-plaintext highlighter-rouge">slot</code>位置中的<code class="language-plaintext highlighter-rouge">Entry.key</code>和要查找的<code class="language-plaintext highlighter-rouge">key</code>不一致：</p>

<p><img src="./images/thread-local/27.png" alt="" /></p>

<p>我们以<code class="language-plaintext highlighter-rouge">get(ThreadLocal1)</code>为例，通过<code class="language-plaintext highlighter-rouge">hash</code>计算后，正确的<code class="language-plaintext highlighter-rouge">slot</code>位置应该是 4，而<code class="language-plaintext highlighter-rouge">index=4</code>的槽位已经有了数据，且<code class="language-plaintext highlighter-rouge">key</code>值不等于<code class="language-plaintext highlighter-rouge">ThreadLocal1</code>，所以需要继续往后迭代查找。</p>

<p>迭代到<code class="language-plaintext highlighter-rouge">index=5</code>的数据时，此时<code class="language-plaintext highlighter-rouge">Entry.key=null</code>，触发一次探测式数据回收操作，执行<code class="language-plaintext highlighter-rouge">expungeStaleEntry()</code>方法，执行完后，<code class="language-plaintext highlighter-rouge">index 5,8</code>的数据都会被回收，而<code class="language-plaintext highlighter-rouge">index 6,7</code>的数据都会前移。<code class="language-plaintext highlighter-rouge">index 6,7</code>前移之后，继续从 <code class="language-plaintext highlighter-rouge">index=5</code> 往后迭代，于是就在 <code class="language-plaintext highlighter-rouge">index=6</code> 找到了<code class="language-plaintext highlighter-rouge">key</code>值相等的<code class="language-plaintext highlighter-rouge">Entry</code>数据，如下图所示：</p>

<p><img src="./images/thread-local/28.png" alt="" /></p>

<h4 id="threadlocalmapget源码详解"><code class="language-plaintext highlighter-rouge">ThreadLocalMap.get()</code>源码详解</h4>

<p><code class="language-plaintext highlighter-rouge">java.lang.ThreadLocal.ThreadLocalMap.getEntry()</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nc">Entry</span> <span class="nf">getEntry</span><span class="o">(</span><span class="nc">ThreadLocal</span><span class="o">&lt;?&gt;</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">threadLocalHashCode</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">table</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="nc">Entry</span> <span class="n">e</span> <span class="o">=</span> <span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">e</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">e</span><span class="o">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="nf">getEntryAfterMiss</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="nc">Entry</span> <span class="nf">getEntryAfterMiss</span><span class="o">(</span><span class="nc">ThreadLocal</span><span class="o">&lt;?&gt;</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="nc">Entry</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Entry</span><span class="o">[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ThreadLocal</span><span class="o">&lt;?&gt;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">e</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">expungeStaleEntry</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="k">else</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">nextIndex</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="threadlocalmap过期-key-的启发式清理流程"><code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>过期 key 的启发式清理流程</h3>

<p>上面多次提及到<code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>过期 key 的两种清理方式：<strong>探测式清理(expungeStaleEntry())</strong>、<strong>启发式清理(cleanSomeSlots())</strong></p>

<p>探测式清理是以当前<code class="language-plaintext highlighter-rouge">Entry</code> 往后清理，遇到值为<code class="language-plaintext highlighter-rouge">null</code>则结束清理，属于<strong>线性探测清理</strong>。</p>

<p>而启发式清理被作者定义为：<strong>Heuristically scan some cells looking for stale entries</strong>.</p>

<p><img src="./images/thread-local/29.png" alt="" /></p>

<p>具体代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">cleanSomeSlots</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">removed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="nc">Entry</span><span class="o">[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">do</span> <span class="o">{</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">nextIndex</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
        <span class="nc">Entry</span> <span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">e</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">len</span><span class="o">;</span>
            <span class="n">removed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">expungeStaleEntry</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">while</span> <span class="o">(</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;&gt;&gt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">removed</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="inheritablethreadlocal"><code class="language-plaintext highlighter-rouge">InheritableThreadLocal</code></h3>

<p>我们使用<code class="language-plaintext highlighter-rouge">ThreadLocal</code>的时候，在异步场景下是无法给子线程共享父线程中创建的线程副本数据的。</p>

<p>为了解决这个问题，JDK 中还有一个<code class="language-plaintext highlighter-rouge">InheritableThreadLocal</code>类，我们来看一个例子：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">InheritableThreadLocalDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nc">ThreadLocal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">&lt;&gt;();</span>
        <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">inheritableThreadLocal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InheritableThreadLocal</span><span class="o">&lt;&gt;();</span>
        <span class="nc">ThreadLocal</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">"父类数据:threadLocal"</span><span class="o">);</span>
        <span class="n">inheritableThreadLocal</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">"父类数据:inheritableThreadLocal"</span><span class="o">);</span>

        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"子线程获取父类ThreadLocal数据："</span> <span class="o">+</span> <span class="nc">ThreadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"子线程获取父类inheritableThreadLocal数据："</span> <span class="o">+</span> <span class="n">inheritableThreadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>打印结果：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">子线程获取父类ThreadLocal数据</span><span class="err">：</span><span class="kc">null</span>
<span class="n">子线程获取父类inheritableThreadLocal数据</span><span class="err">：</span><span class="nl">父类数据:</span><span class="n">inheritableThreadLocal</span>
</code></pre></div></div>

<p>实现原理是子线程是通过在父线程中通过调用<code class="language-plaintext highlighter-rouge">new Thread()</code>方法来创建子线程，<code class="language-plaintext highlighter-rouge">Thread#init</code>方法在<code class="language-plaintext highlighter-rouge">Thread</code>的构造方法中被调用。在<code class="language-plaintext highlighter-rouge">init</code>方法中拷贝父线程数据到子线程中：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">(</span><span class="nc">ThreadGroup</span> <span class="n">g</span><span class="o">,</span> <span class="nc">Runnable</span> <span class="n">target</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span>
                      <span class="kt">long</span> <span class="n">stackSize</span><span class="o">,</span> <span class="nc">AccessControlContext</span> <span class="n">acc</span><span class="o">,</span>
                      <span class="kt">boolean</span> <span class="n">inheritThreadLocals</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">name</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">(</span><span class="s">"name cannot be null"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">inheritThreadLocals</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span><span class="o">.</span><span class="na">inheritableThreadLocals</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">this</span><span class="o">.</span><span class="na">inheritableThreadLocals</span> <span class="o">=</span>
            <span class="nc">ThreadLocal</span><span class="o">.</span><span class="na">createInheritedMap</span><span class="o">(</span><span class="n">parent</span><span class="o">.</span><span class="na">inheritableThreadLocals</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">stackSize</span> <span class="o">=</span> <span class="n">stackSize</span><span class="o">;</span>
    <span class="n">tid</span> <span class="o">=</span> <span class="n">nextThreadID</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>但<code class="language-plaintext highlighter-rouge">InheritableThreadLocal</code>仍然有缺陷，一般我们做异步化处理都是使用的线程池，而<code class="language-plaintext highlighter-rouge">InheritableThreadLocal</code>是在<code class="language-plaintext highlighter-rouge">new Thread</code>中的<code class="language-plaintext highlighter-rouge">init()</code>方法给赋值的，而线程池是线程复用的逻辑，所以这里会存在问题。</p>

<p>当然，有问题出现就会有解决问题的方案，阿里巴巴开源了一个<code class="language-plaintext highlighter-rouge">TransmittableThreadLocal</code>组件就可以解决这个问题，这里就不再延伸，感兴趣的可自行查阅资料。</p>

<h3 id="threadlocal项目中使用实战"><code class="language-plaintext highlighter-rouge">ThreadLocal</code>项目中使用实战</h3>

<h4 id="threadlocal使用场景"><code class="language-plaintext highlighter-rouge">ThreadLocal</code>使用场景</h4>

<p>我们现在项目中日志记录用的是<code class="language-plaintext highlighter-rouge">ELK+Logstash</code>，最后在<code class="language-plaintext highlighter-rouge">Kibana</code>中进行展示和检索。</p>

<p>现在都是分布式系统统一对外提供服务，项目间调用的关系可以通过 <code class="language-plaintext highlighter-rouge">traceId</code> 来关联，但是不同项目之间如何传递 <code class="language-plaintext highlighter-rouge">traceId</code> 呢？</p>

<p>这里我们使用 <code class="language-plaintext highlighter-rouge">org.slf4j.MDC</code> 来实现此功能，内部就是通过 <code class="language-plaintext highlighter-rouge">ThreadLocal</code> 来实现的，具体实现如下：</p>

<p>当前端发送请求到<strong>服务 A</strong>时，<strong>服务 A</strong>会生成一个类似<code class="language-plaintext highlighter-rouge">UUID</code>的<code class="language-plaintext highlighter-rouge">traceId</code>字符串，将此字符串放入当前线程的<code class="language-plaintext highlighter-rouge">ThreadLocal</code>中，在调用<strong>服务 B</strong>的时候，将<code class="language-plaintext highlighter-rouge">traceId</code>写入到请求的<code class="language-plaintext highlighter-rouge">Header</code>中，<strong>服务 B</strong>在接收请求时会先判断请求的<code class="language-plaintext highlighter-rouge">Header</code>中是否有<code class="language-plaintext highlighter-rouge">traceId</code>，如果存在则写入自己线程的<code class="language-plaintext highlighter-rouge">ThreadLocal</code>中。</p>

<p><img src="./images/thread-local/30.png" alt="" /></p>

<p>图中的<code class="language-plaintext highlighter-rouge">requestId</code>即为我们各个系统链路关联的<code class="language-plaintext highlighter-rouge">traceId</code>，系统间互相调用，通过这个<code class="language-plaintext highlighter-rouge">requestId</code>即可找到对应链路，这里还有会有一些其他场景：</p>

<p><img src="./images/thread-local/31.png" alt="" /></p>

<p>针对于这些场景，我们都可以有相应的解决方案，如下所示</p>

<h4 id="feign-远程调用解决方案">Feign 远程调用解决方案</h4>

<p><strong>服务发送请求：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="nd">@Slf4j</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FeignInvokeInterceptor</span> <span class="kd">implements</span> <span class="nc">RequestInterceptor</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">apply</span><span class="o">(</span><span class="nc">RequestTemplate</span> <span class="n">template</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">requestId</span> <span class="o">=</span> <span class="no">MDC</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"requestId"</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">isNotBlank</span><span class="o">(</span><span class="n">requestId</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">template</span><span class="o">.</span><span class="na">header</span><span class="o">(</span><span class="s">"requestId"</span><span class="o">,</span> <span class="n">requestId</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>服务接收请求：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Slf4j</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LogInterceptor</span> <span class="kd">extends</span> <span class="nc">HandlerInterceptorAdapter</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterCompletion</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">arg0</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">arg1</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">arg2</span><span class="o">,</span> <span class="nc">Exception</span> <span class="n">arg3</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">MDC</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="s">"requestId"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">arg0</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">arg1</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">arg2</span><span class="o">,</span> <span class="nc">ModelAndView</span> <span class="n">arg3</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">preHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

        <span class="nc">String</span> <span class="n">requestId</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getHeader</span><span class="o">(</span><span class="nc">BaseConstant</span><span class="o">.</span><span class="na">REQUEST_ID_KEY</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">isBlank</span><span class="o">(</span><span class="n">requestId</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">requestId</span> <span class="o">=</span> <span class="no">UUID</span><span class="o">.</span><span class="na">randomUUID</span><span class="o">().</span><span class="na">toString</span><span class="o">().</span><span class="na">replace</span><span class="o">(</span><span class="s">"-"</span><span class="o">,</span> <span class="s">""</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="no">MDC</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"requestId"</span><span class="o">,</span> <span class="n">requestId</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="线程池异步调用requestid-传递">线程池异步调用，requestId 传递</h4>

<p>因为<code class="language-plaintext highlighter-rouge">MDC</code>是基于<code class="language-plaintext highlighter-rouge">ThreadLocal</code>去实现的，异步过程中，子线程并没有办法获取到父线程<code class="language-plaintext highlighter-rouge">ThreadLocal</code>存储的数据，所以这里可以自定义线程池执行器，修改其中的<code class="language-plaintext highlighter-rouge">run()</code>方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyThreadPoolTaskExecutor</span> <span class="kd">extends</span> <span class="nc">ThreadPoolTaskExecutor</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">runnable</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">context</span> <span class="o">=</span> <span class="no">MDC</span><span class="o">.</span><span class="na">getCopyOfContextMap</span><span class="o">();</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">execute</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">run</span><span class="o">(</span><span class="n">runnable</span><span class="o">,</span> <span class="n">context</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">runnable</span><span class="o">,</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">context</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="no">MDC</span><span class="o">.</span><span class="na">setContextMap</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">runnable</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="no">MDC</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="使用-mq-发送消息给第三方系统">使用 MQ 发送消息给第三方系统</h4>

<p>在 MQ 发送的消息体中自定义属性<code class="language-plaintext highlighter-rouge">requestId</code>，接收方消费消息后，自己解析<code class="language-plaintext highlighter-rouge">requestId</code>使用即可。</p>

<!-- @include: @article-footer.snippet.md -->
