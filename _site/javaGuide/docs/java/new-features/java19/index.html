<p>JDK 19 定于 2022 年 9 月 20 日正式发布以供生产使用，非长期支持版本。不过，JDK 19 中有一些比较重要的新特性值得关注。</p>

<p>JDK 19 只有 7 个新特性：</p>

<ul>
  <li><a href="https://openjdk.org/jeps/405">JEP 405: Record Patterns（记录模式）</a>（预览）</li>
  <li><a href="https://openjdk.org/jeps/422">JEP 422: Linux/RISC-V Port</a></li>
  <li><a href="https://openjdk.org/jeps/424">JEP 424: Foreign Function &amp; Memory API（外部函数和内存 API）</a>（预览）</li>
  <li><a href="https://openjdk.org/jeps/425">JEP 425: Virtual Threads（虚拟线程）</a>（预览）</li>
  <li><a href="https://openjdk.java.net/jeps/426">JEP 426: Vector（向量）API</a>（第四次孵化）</li>
  <li><a href="https://openjdk.java.net/jeps/427">JEP 427: Pattern Matching for switch（switch 模式匹配）</a></li>
  <li><a href="https://openjdk.org/jeps/428">JEP 428: Structured Concurrency（结构化并发）</a>（孵化）</li>
</ul>

<p>这里只对 424、425、426、428 这 4 个我觉得比较重要的新特性进行详细介绍。</p>

<p>相关阅读：<a href="https://openjdk.org/projects/jdk/19/">OpenJDK Java 19 文档</a></p>

<h2 id="jep-424-外部函数和内存-api预览">JEP 424: 外部函数和内存 API（预览）</h2>

<p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。</p>

<p>外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 <a href="https://openjdk.java.net/jeps/412">JEP 412</a> 提出。第二轮孵化由<a href="https://openjdk.org/jeps/419">JEP 419</a> 提出并集成到了 Java 18 中，预览由 <a href="https://openjdk.org/jeps/424">JEP 424</a> 提出并集成到了 Java 19 中。</p>

<p>在没有外部函数和内存 API 之前：</p>

<ul>
  <li>Java 通过 <a href="https://hg.openjdk.java.net/jdk/jdk/file/tip/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java"><code class="language-plaintext highlighter-rouge">sun.misc.Unsafe</code></a> 提供一些执行低级别、不安全操作的方法（如直接访问系统内存资源、自主管理内存资源等），<code class="language-plaintext highlighter-rouge">Unsafe</code> 类让 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力的同时，也增加了 Java 语言的不安全性，不正确使用 <code class="language-plaintext highlighter-rouge">Unsafe</code> 类会使得程序出错的概率变大。</li>
  <li>Java 1.1 就已通过 Java 原生接口（JNI）支持了原生方法调用，但并不好用。JNI 实现起来过于复杂，步骤繁琐（具体的步骤可以参考这篇文章：<a href="https://www.baeldung.com/jni">Guide to JNI (Java Native Interface)</a> ），不受 JVM 的语言安全机制控制，影响 Java 语言的跨平台特性。并且，JNI 的性能也不行，因为 JNI 方法调用不能从许多常见的 JIT 优化(如内联)中受益。虽然<a href="https://github.com/java-native-access/jna">JNA</a>、<a href="https://github.com/jnr/jnr-ffi">JNR</a>和<a href="https://github.com/bytedeco/javacpp">JavaCPP</a>等框架对 JNI 进行了改进，但效果还是不太理想。</li>
</ul>

<p>引入外部函数和内存 API 就是为了解决 Java 访问外部函数和外部内存存在的一些痛点。</p>

<p>Foreign Function &amp; Memory API (FFM API) 定义了类和接口：</p>

<ul>
  <li>分配外部内存：<code class="language-plaintext highlighter-rouge">MemorySegment</code>、<code class="language-plaintext highlighter-rouge">MemoryAddress</code>和<code class="language-plaintext highlighter-rouge">SegmentAllocator</code>；</li>
  <li>操作和访问结构化的外部内存：<code class="language-plaintext highlighter-rouge">MemoryLayout</code>, <code class="language-plaintext highlighter-rouge">VarHandle</code>；</li>
  <li>控制外部内存的分配和释放：<code class="language-plaintext highlighter-rouge">MemorySession</code>；</li>
  <li>调用外部函数：<code class="language-plaintext highlighter-rouge">Linker</code>、<code class="language-plaintext highlighter-rouge">FunctionDescriptor</code>和<code class="language-plaintext highlighter-rouge">SymbolLookup</code>。</li>
</ul>

<p>下面是 FFM API 使用示例，这段代码获取了 C 库函数的 <code class="language-plaintext highlighter-rouge">radixsort</code> 方法句柄，然后使用它对 Java 数组中的四个字符串进行排序。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. 在C库路径上查找外部函数</span>
<span class="nc">Linker</span> <span class="n">linker</span> <span class="o">=</span> <span class="nc">Linker</span><span class="o">.</span><span class="na">nativeLinker</span><span class="o">();</span>
<span class="nc">SymbolLookup</span> <span class="n">stdlib</span> <span class="o">=</span> <span class="n">linker</span><span class="o">.</span><span class="na">defaultLookup</span><span class="o">();</span>
<span class="nc">MethodHandle</span> <span class="n">radixSort</span> <span class="o">=</span> <span class="n">linker</span><span class="o">.</span><span class="na">downcallHandle</span><span class="o">(</span>
                             <span class="n">stdlib</span><span class="o">.</span><span class="na">lookup</span><span class="o">(</span><span class="s">"radixsort"</span><span class="o">),</span> <span class="o">...);</span>
<span class="c1">// 2. 分配堆上内存以存储四个字符串</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">javaStrings</span>   <span class="o">=</span> <span class="o">{</span> <span class="s">"mouse"</span><span class="o">,</span> <span class="s">"cat"</span><span class="o">,</span> <span class="s">"dog"</span><span class="o">,</span> <span class="s">"car"</span> <span class="o">};</span>
<span class="c1">// 3. 分配堆外内存以存储四个指针</span>
<span class="nc">SegmentAllocator</span> <span class="n">allocator</span> <span class="o">=</span> <span class="n">implicitAllocator</span><span class="o">();</span>
<span class="nc">MemorySegment</span> <span class="n">offHeap</span>  <span class="o">=</span> <span class="n">allocator</span><span class="o">.</span><span class="na">allocateArray</span><span class="o">(</span><span class="nc">ValueLayout</span><span class="o">.</span><span class="na">ADDRESS</span><span class="o">,</span> <span class="n">javaStrings</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
<span class="c1">// 4. 将字符串从堆上复制到堆外</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">javaStrings</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="c1">// 在堆外分配一个字符串，然后存储指向它的指针</span>
    <span class="nc">MemorySegment</span> <span class="n">cString</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">.</span><span class="na">allocateUtf8String</span><span class="o">(</span><span class="n">javaStrings</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
    <span class="n">offHeap</span><span class="o">.</span><span class="na">setAtIndex</span><span class="o">(</span><span class="nc">ValueLayout</span><span class="o">.</span><span class="na">ADDRESS</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">cString</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 5. 通过调用外部函数对堆外数据进行排序</span>
<span class="n">radixSort</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">offHeap</span><span class="o">,</span> <span class="n">javaStrings</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="nc">MemoryAddress</span><span class="o">.</span><span class="na">NULL</span><span class="o">,</span> <span class="sc">'\0'</span><span class="o">);</span>
<span class="c1">// 6. 将(重新排序的)字符串从堆外复制到堆上</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">javaStrings</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">MemoryAddress</span> <span class="n">cStringPtr</span> <span class="o">=</span> <span class="n">offHeap</span><span class="o">.</span><span class="na">getAtIndex</span><span class="o">(</span><span class="nc">ValueLayout</span><span class="o">.</span><span class="na">ADDRESS</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
    <span class="n">javaStrings</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">cStringPtr</span><span class="o">.</span><span class="na">getUtf8String</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>
<span class="k">assert</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">javaStrings</span><span class="o">,</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]</span> <span class="o">{</span><span class="s">"car"</span><span class="o">,</span> <span class="s">"cat"</span><span class="o">,</span> <span class="s">"dog"</span><span class="o">,</span> <span class="s">"mouse"</span><span class="o">});</span>  <span class="c1">// true</span>
</code></pre></div></div>

<h2 id="jep-425-虚拟线程预览">JEP 425: 虚拟线程（预览）</h2>

<p>虚拟线程（Virtual Thread-）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p>

<p>虚拟线程在其他多线程语言中已经被证实是十分有用的，比如 Go 中的 Goroutine、Erlang 中的进程。</p>

<p>虚拟线程避免了上下文切换的额外耗费，兼顾了多线程的优点，简化了高并发程序的复杂，可以有效减少编写、维护和观察高吞吐量并发应用程序的工作量。</p>

<p>知乎有一个关于 Java 19 虚拟线程的讨论，感兴趣的可以去看看：<a href="https://www.zhihu.com/question/536743167">https://www.zhihu.com/question/536743167</a> 。</p>

<p>Java 虚拟线程的详细解读和原理可以看下面这两篇文章：</p>

<ul>
  <li><a href="https://mp.weixin.qq.com/s/vdLXhZdWyxc6K-D3Aj03LA">虚拟线程原理及性能分析｜得物技术</a></li>
  <li><a href="https://mp.weixin.qq.com/s/yyApBXxpXxVwttr01Hld6Q">Java19 正式 GA！看虚拟线程如何大幅提高系统吞吐量</a></li>
  <li><a href="https://www.cnblogs.com/throwable/p/16758997.html">虚拟线程 - VirtualThread 源码透视</a></li>
</ul>

<h2 id="jep-426-向量-api第四次孵化">JEP 426: 向量 API（第四次孵化）</h2>

<p>向量（Vector） API 最初由 <a href="https://openjdk.java.net/jeps/338">JEP 338</a> 提出，并作为<a href="http://openjdk.java.net/jeps/11">孵化 API</a>集成到 Java 16 中。第二轮孵化由 <a href="https://openjdk.java.net/jeps/414">JEP 414</a> 提出并集成到 Java 17 中，第三轮孵化由 <a href="https://openjdk.java.net/jeps/417">JEP 417</a> 提出并集成到 Java 18 中，第四轮由 <a href="https://openjdk.java.net/jeps/426">JEP 426</a> 提出并集成到了 Java 19 中。</p>

<p>在 <a href="./java18.md">Java 18 新特性概览</a> 中，我有详细介绍到向量 API，这里就不再做额外的介绍了。</p>

<h2 id="jep-428-结构化并发孵化">JEP 428: 结构化并发(孵化)</h2>

<p>JDK 19 引入了结构化并发，一种多线程编程方法，目的是为了通过结构化并发 API 来简化多线程编程，并不是为了取代<code class="language-plaintext highlighter-rouge">java.util.concurrent</code>，目前处于孵化器阶段。</p>

<p>结构化并发将不同线程中运行的多个任务视为单个工作单元，从而简化错误处理、提高可靠性并增强可观察性。也就是说，结构化并发保留了单线程代码的可读性、可维护性和可观察性。</p>

<p>结构化并发的基本 API 是<a href="https://download.java.net/java/early_access/loom/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/StructuredTaskScope.html"><code class="language-plaintext highlighter-rouge">StructuredTaskScope</code></a>。<code class="language-plaintext highlighter-rouge">StructuredTaskScope</code> 支持将任务拆分为多个并发子任务，在它们自己的线程中执行，并且子任务必须在主任务继续之前完成。</p>

<p><code class="language-plaintext highlighter-rouge">StructuredTaskScope</code> 的基本用法如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">try</span> <span class="o">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StructuredTaskScope</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;())</span> <span class="o">{</span>
        <span class="c1">// 使用fork方法派生线程来执行子任务</span>
        <span class="nc">Future</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">future1</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(</span><span class="n">task1</span><span class="o">);</span>
        <span class="nc">Future</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future2</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(</span><span class="n">task2</span><span class="o">);</span>
        <span class="c1">// 等待线程完成</span>
        <span class="n">scope</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="c1">// 结果的处理可能包括处理或重新抛出异常</span>
        <span class="o">...</span> <span class="n">process</span> <span class="n">results</span><span class="o">/</span><span class="n">exceptions</span> <span class="o">...</span>
    <span class="o">}</span> <span class="c1">// close</span>
</code></pre></div></div>

<p>结构化并发非常适合虚拟线程，虚拟线程是 JDK 实现的轻量级线程。许多虚拟线程共享同一个操作系统线程，从而允许非常多的虚拟线程。</p>

<!-- @include: @article-footer.snippet.md -->
