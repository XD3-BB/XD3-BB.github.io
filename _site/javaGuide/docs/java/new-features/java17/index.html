<p>Java 17 在 2021 年 9 月 14 日正式发布，是一个长期支持（LTS）版本。</p>

<p>下面这张图是 Oracle 官方给出的 Oracle JDK 支持的时间线。可以看得到，Java</p>

<p>17 最多可以支持到 2029 年 9 月份。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/new-features/4c1611fad59449edbbd6e233690e9fa7.png" alt="" /></p>

<p>Java 17 将是继 Java 8 以来最重要的长期支持（LTS）版本，是 Java 社区八年努力的成果。Spring 6.x 和 Spring Boot 3.x 最低支持的就是 Java 17。</p>

<p>这次更新共带来 14 个新特性：</p>

<ul>
  <li><a href="https://openjdk.java.net/jeps/306">JEP 306:Restore Always-Strict Floating-Point Semantics（恢复始终严格的浮点语义）</a></li>
  <li><a href="https://openjdk.java.net/jeps/356">JEP 356:Enhanced Pseudo-Random Number Generators（增强的伪随机数生成器）</a></li>
  <li><a href="https://openjdk.java.net/jeps/382">JEP 382:New macOS Rendering Pipeline（新的 macOS 渲染管道）</a></li>
  <li><a href="https://openjdk.java.net/jeps/391">JEP 391:macOS/AArch64 Port（支持 macOS AArch64）</a></li>
  <li><a href="https://openjdk.java.net/jeps/398">JEP 398:Deprecate the Applet API for Removal（删除已弃用的 Applet API）</a></li>
  <li><a href="https://openjdk.java.net/jeps/403">JEP 403:Strongly Encapsulate JDK Internals（更强大的封装 JDK 内部元素）</a></li>
  <li><a href="https://openjdk.java.net/jeps/406">JEP 406:Pattern Matching for switch (switch 的类型匹配)</a>（预览）</li>
  <li><a href="https://openjdk.java.net/jeps/407">JEP 407:Remove RMI Activation（删除远程方法调用激活机制）</a></li>
  <li><a href="https://openjdk.java.net/jeps/409">JEP 409:Sealed Classes（密封类）</a>（转正）</li>
  <li><a href="https://openjdk.java.net/jeps/410">JEP 410:Remove the Experimental AOT and JIT Compiler（删除实验性的 AOT 和 JIT 编译器）</a></li>
  <li><a href="https://openjdk.java.net/jeps/411">JEP 411:Deprecate the Security Manager for Removal（弃用安全管理器以进行删除）</a></li>
  <li><a href="https://openjdk.java.net/jeps/412">JEP 412:Foreign Function &amp; Memory API (外部函数和内存 API)</a>（孵化）</li>
  <li><a href="https://openjdk.java.net/jeps/417">JEP 414:Vector（向量） API</a>（第二次孵化）</li>
  <li><a href="https://openjdk.java.net/jeps/415">JEP 415:Context-Specific Deserialization Filters</a></li>
</ul>

<p>这里只对 356、398、413、406、407、409、410、411、412、414 这几个我觉得比较重要的新特性进行详细介绍。</p>

<p>相关阅读：<a href="https://openjdk.java.net/projects/jdk/17/">OpenJDK Java 17 文档</a> 。</p>

<h2 id="jep-356增强的伪随机数生成器">JEP 356:增强的伪随机数生成器</h2>

<p>JDK 17 之前，我们可以借助 <code class="language-plaintext highlighter-rouge">Random</code>、<code class="language-plaintext highlighter-rouge">ThreadLocalRandom</code>和<code class="language-plaintext highlighter-rouge">SplittableRandom</code>来生成随机数。不过，这 3 个类都各有缺陷，且缺少常见的伪随机算法支持。</p>

<p>Java 17 为伪随机数生成器 （pseudorandom number generator，PRNG，又称为确定性随机位生成器）增加了新的接口类型和实现，使得开发者更容易在应用程序中互换使用各种 PRNG 算法。</p>

<blockquote>
  <p><a href="https://ctf-wiki.org/crypto/streamcipher/prng/intro/">PRNG</a> 用来生成接近于绝对随机数序列的数字序列。一般来说，PRNG 会依赖于一个初始值，也称为种子，来生成对应的伪随机数序列。只要种子确定了，PRNG 所生成的随机数就是完全确定的，因此其生成的随机数序列并不是真正随机的。</p>
</blockquote>

<p>使用示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">RandomGeneratorFactory</span><span class="o">&lt;</span><span class="nc">RandomGenerator</span><span class="o">&gt;</span> <span class="n">l128X256MixRandom</span> <span class="o">=</span> <span class="nc">RandomGeneratorFactory</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"L128X256MixRandom"</span><span class="o">);</span>
<span class="c1">// 使用时间戳作为随机数种子</span>
<span class="nc">RandomGenerator</span> <span class="n">randomGenerator</span> <span class="o">=</span> <span class="n">l128X256MixRandom</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">());</span>
<span class="c1">// 生成随机数</span>
<span class="n">randomGenerator</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
</code></pre></div></div>

<h2 id="jep-398弃用-applet-api-以进行删除">JEP 398:弃用 Applet API 以进行删除</h2>

<p>Applet API 用于编写在 Web 浏览器端运行的 Java 小程序，很多年前就已经被淘汰了，已经没有理由使用了。</p>

<p>Applet API 在 Java 9 时被标记弃用（<a href="https://openjdk.java.net/jeps/289">JEP 289</a>），但不是为了删除。</p>

<h2 id="jep-406switch-的类型匹配预览">JEP 406:switch 的类型匹配（预览）</h2>

<p>正如 <code class="language-plaintext highlighter-rouge">instanceof</code> 一样， <code class="language-plaintext highlighter-rouge">switch</code> 也紧跟着增加了类型匹配自动转换功能。</p>

<p><code class="language-plaintext highlighter-rouge">instanceof</code> 代码示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Old code</span>
<span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">String</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span><span class="n">o</span><span class="o">;</span>
    <span class="o">...</span> <span class="n">use</span> <span class="n">s</span> <span class="o">...</span>
<span class="o">}</span>

<span class="c1">// New code</span>
<span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span> <span class="n">use</span> <span class="n">s</span> <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">switch</code> 代码示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Old code</span>
<span class="kd">static</span> <span class="nc">String</span> <span class="nf">formatter</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">formatted</span> <span class="o">=</span> <span class="s">"unknown"</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Integer</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">formatted</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"int %d"</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Long</span> <span class="n">l</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">formatted</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"long %d"</span><span class="o">,</span> <span class="n">l</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Double</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">formatted</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"double %f"</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">formatted</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"String %s"</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">formatted</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// New code</span>
<span class="kd">static</span> <span class="nc">String</span> <span class="nf">formatterPatternSwitch</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">switch</span> <span class="o">(</span><span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Integer</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"int %d"</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="k">case</span> <span class="nc">Long</span> <span class="n">l</span>    <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"long %d"</span><span class="o">,</span> <span class="n">l</span><span class="o">);</span>
        <span class="k">case</span> <span class="nc">Double</span> <span class="n">d</span>  <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"double %f"</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
        <span class="k">case</span> <span class="nc">String</span> <span class="n">s</span>  <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"String %s"</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
        <span class="k">default</span>        <span class="o">-&gt;</span> <span class="n">o</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">};</span>
<span class="o">}</span>

</code></pre></div></div>

<p>对于 <code class="language-plaintext highlighter-rouge">null</code> 值的判断也进行了优化。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Old code</span>
<span class="kd">static</span> <span class="kt">void</span> <span class="nf">testFooBar</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"oops!"</span><span class="o">);</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="s">"Foo"</span><span class="o">,</span> <span class="s">"Bar"</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Great"</span><span class="o">);</span>
        <span class="k">default</span>           <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Ok"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// New code</span>
<span class="kd">static</span> <span class="kt">void</span> <span class="nf">testFooBar</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="kc">null</span>         <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Oops"</span><span class="o">);</span>
        <span class="k">case</span> <span class="s">"Foo"</span><span class="o">,</span> <span class="s">"Bar"</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Great"</span><span class="o">);</span>
        <span class="k">default</span>           <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Ok"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="jep-407删除远程方法调用激活机制">JEP 407:删除远程方法调用激活机制</h2>

<p>删除远程方法调用 (RMI) 激活机制，同时保留 RMI 的其余部分。RMI 激活机制已过时且不再使用。</p>

<h2 id="jep-409密封类转正">JEP 409:密封类（转正）</h2>

<p>密封类由 <a href="https://openjdk.java.net/jeps/360">JEP 360</a> 提出预览，集成到了 Java 15 中。在 JDK 16 中， 密封类得到了改进（更加严格的引用检查和密封类的继承关系），由 <a href="https://openjdk.java.net/jeps/397">JEP 397</a> 提出了再次预览。</p>

<p>在 <a href="./java14-15.md">Java 14 &amp; 15 新特性概览</a> 中，我有详细介绍到密封类，这里就不再做额外的介绍了。</p>

<h2 id="jep-410删除实验性的-aot-和-jit-编译器">JEP 410:删除实验性的 AOT 和 JIT 编译器</h2>

<p>在 Java 9 的 <a href="https://openjdk.java.net/jeps/295">JEP 295</a> ,引入了实验性的提前 (AOT) 编译器，在启动虚拟机之前将 Java 类编译为本机代码。</p>

<p>Java 17，删除实验性的提前 (AOT) 和即时 (JIT) 编译器，因为该编译器自推出以来很少使用，维护它所需的工作量很大。保留实验性的 Java 级 JVM 编译器接口 (JVMCI)，以便开发人员可以继续使用外部构建的编译器版本进行 JIT 编译。</p>

<h2 id="jep-411弃用安全管理器以进行删除">JEP 411:弃用安全管理器以进行删除</h2>

<p>弃用安全管理器以便在将来的版本中删除。</p>

<p>安全管理器可追溯到 Java 1.0，多年来，它一直不是保护客户端 Java 代码的主要方法，也很少用于保护服务器端代码。为了推动 Java 向前发展，Java 17 弃用安全管理器，以便与旧版 Applet API ( <a href="https://openjdk.java.net/jeps/398">JEP 398</a> ) 一起移除。</p>

<h2 id="jep-412外部函数和内存-api孵化">JEP 412:外部函数和内存 API（孵化）</h2>

<p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。</p>

<p>外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 <a href="https://openjdk.java.net/jeps/412">JEP 412</a> 提出。第二轮孵化由<a href="https://openjdk.org/jeps/419">JEP 419</a> 提出并集成到了 Java 18 中，预览由 <a href="https://openjdk.org/jeps/424">JEP 424</a> 提出并集成到了 Java 19 中。</p>

<p>在 <a href="./java19.md">Java 19 新特性概览</a> 中，我有详细介绍到外部函数和内存 API，这里就不再做额外的介绍了。</p>

<h2 id="jep-414向量-api第二次孵化">JEP 414:向量 API（第二次孵化）</h2>

<p>向量（Vector） API 最初由 <a href="https://openjdk.java.net/jeps/338">JEP 338</a> 提出，并作为<a href="http://openjdk.java.net/jeps/11">孵化 API</a>集成到 Java 16 中。第二轮孵化由 <a href="https://openjdk.java.net/jeps/414">JEP 414</a> 提出并集成到 Java 17 中，第三轮孵化由 <a href="https://openjdk.java.net/jeps/417">JEP 417</a> 提出并集成到 Java 18 中，第四轮由 <a href="https://openjdk.java.net/jeps/426">JEP 426</a> 提出并集成到了 Java 19 中。</p>

<p>该孵化器 API 提供了一个 API 的初始迭代以表达一些向量计算，这些计算在运行时可靠地编译为支持的 CPU 架构上的最佳向量硬件指令，从而获得优于同等标量计算的性能，充分利用单指令多数据（SIMD）技术（大多数现代 CPU 上都可以使用的一种指令）。尽管 HotSpot 支持自动向量化，但是可转换的标量操作集有限且易受代码更改的影响。该 API 将使开发人员能够轻松地用 Java 编写可移植的高性能向量算法。</p>

<p>在 <a href="./java18.md">Java 18 新特性概览</a> 中，我有详细介绍到向量 API，这里就不再做额外的介绍了。</p>

<!-- @include: @article-footer.snippet.md -->
