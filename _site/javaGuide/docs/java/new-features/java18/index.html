<p>Java 18 在 2022 年 3 月 22 日正式发布，非长期支持版本。</p>

<p>Java 18 带来了 9 个新特性：</p>

<ul>
  <li><a href="https://openjdk.java.net/jeps/400">JEP 400:UTF-8 by Default（默认字符集为 UTF-8）</a></li>
  <li><a href="https://openjdk.java.net/jeps/408">JEP 408:Simple Web Server（简易的 Web 服务器）</a></li>
  <li><a href="https://openjdk.java.net/jeps/413">JEP 413:Code Snippets in Java API Documentation（Java API 文档中的代码片段）</a></li>
  <li><a href="https://openjdk.java.net/jeps/416">JEP 416:Reimplement Core Reflection with Method Handles（使用方法句柄重新实现反射核心）</a></li>
  <li><a href="https://openjdk.java.net/jeps/417">JEP 417:Vector（向量） API</a>（第三次孵化）</li>
  <li><a href="https://openjdk.java.net/jeps/418">JEP 418:Internet-Address Resolution（互联网地址解析）SPI</a></li>
  <li><a href="https://openjdk.java.net/jeps/419">JEP 419:Foreign Function &amp; Memory API（外部函数和内存 API）</a>（第二次孵化）</li>
  <li><a href="https://openjdk.java.net/jeps/420">JEP 420:Pattern Matching for switch（switch 模式匹配）</a>（第二次预览）</li>
  <li><a href="https://openjdk.java.net/jeps/421">JEP 421:Deprecate Finalization for Removal</a></li>
</ul>

<p>Java 17 中包含 14 个特性，Java 16 中包含 17 个特性，Java 15 中包含 14 个特性，Java 14 中包含 16 个特性。相比于前面发布的版本来说，Java 18 的新特性少了很多。</p>

<p>这里只对 400、408、413、416、417、418、419 这几个我觉得比较重要的新特性进行详细介绍。</p>

<p>相关阅读：</p>

<ul>
  <li><a href="https://openjdk.java.net/projects/jdk/18/">OpenJDK Java 18 文档</a></li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>[IntelliJ IDEA</td>
          <td>Java 18 功能支持](https://mp.weixin.qq.com/s/PocFKR9z9u7-YCZHsrA5kQ)</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h2 id="jep-400默认字符集为-utf-8">JEP 400:默认字符集为 UTF-8</h2>

<p>JDK 终于将 UTF-8 设置为默认字符集。</p>

<p>在 Java 17 及更早版本中，默认字符集是在 Java 虚拟机运行时才确定的，取决于不同的操作系统、区域设置等因素，因此存在潜在的风险。就比如说你在 Mac 上运行正常的一段打印文字到控制台的 Java 程序到了 Windows 上就会出现乱码，如果你不手动更改字符集的话。</p>

<h2 id="jep-408简易的-web-服务器">JEP 408:简易的 Web 服务器</h2>

<p>Java 18 之后，你可以使用 <code class="language-plaintext highlighter-rouge">jwebserver</code> 命令启动一个简易的静态 Web 服务器。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>jwebserver
Binding to loopback by default. For all interfaces use <span class="s2">"-b 0.0.0.0"</span> or <span class="s2">"-b ::"</span><span class="nb">.</span>
Serving /cwd and subdirectories on 127.0.0.1 port 8000
URL: http://127.0.0.1:8000/
</code></pre></div></div>

<p>这个服务器不支持 CGI 和 Servlet，只限于静态文件。</p>

<h2 id="jep-413优化-java-api-文档中的代码片段">JEP 413:优化 Java API 文档中的代码片段</h2>

<p>在 Java 18 之前，如果我们想要在 Javadoc 中引入代码片段可以使用 <code class="language-plaintext highlighter-rouge">&lt;pre&gt;{@code ...}&lt;/pre&gt;</code> 。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;{</span><span class="nd">@code</span>
    <span class="n">lines</span> <span class="n">of</span> <span class="n">source</span> <span class="n">code</span>
<span class="o">}&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">&lt;pre&gt;{@code ...}&lt;/pre&gt;</code> 这种方式生成的效果比较一般。</p>

<p>在 Java 18 之后，可以通过 <code class="language-plaintext highlighter-rouge">@snippet</code> 标签来做这件事情。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * The following code shows how to use {@code Optional.isPresent}:
 * {@snippet :
 * if (v.isPresent()) {
 *     System.out.println("v: " + v.get());
 * }
 * }
 */</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">@snippet</code> 这种方式生成的效果更好且使用起来更方便一些。</p>

<h2 id="jep-416使用方法句柄重新实现反射核心">JEP 416:使用方法句柄重新实现反射核心</h2>

<p>Java 18 改进了 <code class="language-plaintext highlighter-rouge">java.lang.reflect.Method</code>、<code class="language-plaintext highlighter-rouge">Constructor</code> 的实现逻辑，使之性能更好，速度更快。这项改动不会改动相关 API ，这意味着开发中不需要改动反射相关代码，就可以体验到性能更好反射。</p>

<p>OpenJDK 官方给出了新老实现的反射性能基准测试结果。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/new-features/JEP416Benchmark.png" alt="新老实现的反射性能基准测试结果" /></p>

<h2 id="jep-417-向量-api第三次孵化">JEP 417: 向量 API（第三次孵化）</h2>

<p>向量（Vector） API 最初由 <a href="https://openjdk.java.net/jeps/338">JEP 338</a> 提出，并作为<a href="http://openjdk.java.net/jeps/11">孵化 API</a>集成到 Java 16 中。第二轮孵化由 <a href="https://openjdk.java.net/jeps/414">JEP 414</a> 提出并集成到 Java 17 中，第三轮孵化由 <a href="https://openjdk.java.net/jeps/417">JEP 417</a> 提出并集成到 Java 18 中，第四轮由 <a href="https://openjdk.java.net/jeps/426">JEP 426</a> 提出并集成到了 Java 19 中。</p>

<p>向量计算由对向量的一系列操作组成。向量 API 用来表达向量计算，该计算可以在运行时可靠地编译为支持的 CPU 架构上的最佳向量指令，从而实现优于等效标量计算的性能。</p>

<p>向量 API 的目标是为用户提供简洁易用且与平台无关的表达范围广泛的向量计算。</p>

<p>这是对数组元素的简单标量计算：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">scalarComputation</span><span class="o">(</span><span class="kt">float</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">float</span><span class="o">[]</span> <span class="n">b</span><span class="o">,</span> <span class="kt">float</span><span class="o">[]</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">*</span> <span class="o">-</span><span class="mf">1.0f</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这是使用 Vector API 进行的等效向量计算：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">final</span> <span class="nc">VectorSpecies</span><span class="o">&lt;</span><span class="nc">Float</span><span class="o">&gt;</span> <span class="no">SPECIES</span> <span class="o">=</span> <span class="nc">FloatVector</span><span class="o">.</span><span class="na">SPECIES_PREFERRED</span><span class="o">;</span>

<span class="kt">void</span> <span class="nf">vectorComputation</span><span class="o">(</span><span class="kt">float</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">float</span><span class="o">[]</span> <span class="n">b</span><span class="o">,</span> <span class="kt">float</span><span class="o">[]</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">upperBound</span> <span class="o">=</span> <span class="no">SPECIES</span><span class="o">.</span><span class="na">loopBound</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">upperBound</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="no">SPECIES</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// FloatVector va, vb, vc;</span>
        <span class="kt">var</span> <span class="n">va</span> <span class="o">=</span> <span class="nc">FloatVector</span><span class="o">.</span><span class="na">fromArray</span><span class="o">(</span><span class="no">SPECIES</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="kt">var</span> <span class="n">vb</span> <span class="o">=</span> <span class="nc">FloatVector</span><span class="o">.</span><span class="na">fromArray</span><span class="o">(</span><span class="no">SPECIES</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="kt">var</span> <span class="n">vc</span> <span class="o">=</span> <span class="n">va</span><span class="o">.</span><span class="na">mul</span><span class="o">(</span><span class="n">va</span><span class="o">)</span>
                   <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">vb</span><span class="o">.</span><span class="na">mul</span><span class="o">(</span><span class="n">vb</span><span class="o">))</span>
                   <span class="o">.</span><span class="na">neg</span><span class="o">();</span>
        <span class="n">vc</span><span class="o">.</span><span class="na">intoArray</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">*</span> <span class="o">-</span><span class="mf">1.0f</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>在 JDK 18 中，向量 API 的性能得到了进一步的优化。</p>

<h2 id="jep-418互联网地址解析-spi">JEP 418:互联网地址解析 SPI</h2>

<p>Java 18 定义了一个全新的 SPI（service-provider interface），用于主要名称和地址的解析，以便 <code class="language-plaintext highlighter-rouge">java.net.InetAddress</code> 可以使用平台之外的第三方解析器。</p>

<h2 id="jep-419foreign-function--memory-api第二次孵化">JEP 419:Foreign Function &amp; Memory API（第二次孵化）</h2>

<p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。</p>

<p>外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 <a href="https://openjdk.java.net/jeps/412">JEP 412</a> 提出。第二轮孵化由<a href="https://openjdk.org/jeps/419">JEP 419</a> 提出并集成到了 Java 18 中，预览由 <a href="https://openjdk.org/jeps/424">JEP 424</a> 提出并集成到了 Java 19 中。</p>

<p>在 <a href="./java19.md">Java 19 新特性概览</a> 中，我有详细介绍到外部函数和内存 API，这里就不再做额外的介绍了。</p>

<!-- @include: @article-footer.snippet.md -->
