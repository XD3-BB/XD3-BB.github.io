<p>JDK 21 于 2023 年 9 月 19 日 发布，这是一个非常重要的版本，里程碑式。</p>

<p>JDK21 是 LTS（长期支持版），至此为止，目前有 JDK8、JDK11、JDK17 和 JDK21 这四个长期支持版了。</p>

<p>JDK 21 共有 15 个新特性，这篇文章会挑选其中较为重要的一些新特性进行详细介绍：</p>

<ul>
  <li><a href="https://openjdk.org/jeps/430">JEP 430：String Templates（字符串模板）</a>（预览）</li>
  <li>
    <p><a href="https://openjdk.org/jeps/431">JEP 431：Sequenced Collections（序列化集合）</a></p>
  </li>
  <li>
    <p><a href="https://openjdk.org/jeps/439">JEP 439：Generational ZGC（分代 ZGC）</a></p>
  </li>
  <li>
    <p><a href="https://openjdk.org/jeps/440">JEP 440：Record Patterns（记录模式）</a></p>
  </li>
  <li>
    <p><a href="https://openjdk.org/jeps/442">JEP 441：Pattern Matching for switch（switch 的模式匹配）</a></p>
  </li>
  <li>
    <p><a href="https://openjdk.org/jeps/442">JEP 442：Foreign Function &amp; Memory API（外部函数和内存 API）</a>（第三次预览）</p>
  </li>
  <li>
    <p><a href="https://openjdk.org/jeps/443">JEP 443：Unnamed Patterns and Variables（未命名模式和变量</a>（预览）</p>
  </li>
  <li>
    <p><a href="https://openjdk.org/jeps/444">JEP 444：Virtual Threads（虚拟线程）</a></p>
  </li>
  <li><a href="https://openjdk.org/jeps/445">JEP 445：Unnamed Classes and Instance Main Methods（未命名类和实例 main 方法 ）</a>（预览）</li>
</ul>

<h2 id="jep-430字符串模板预览">JEP 430：字符串模板（预览）</h2>

<p>String Templates(字符串模板) 目前仍然是 JDK 21 中的一个预览功能。</p>

<p>String Templates 提供了一种更简洁、更直观的方式来动态构建字符串。通过使用占位符<code class="language-plaintext highlighter-rouge">${}</code>，我们可以将变量的值直接嵌入到字符串中，而不需要手动处理。在运行时，Java 编译器会将这些占位符替换为实际的变量值。并且，表达式支持局部变量、静态/非静态字段甚至方法、计算结果等特性。</p>

<p>实际上，String Templates（字符串模板）再大多数编程语言中都存在:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">"</span><span class="s2">Greetings !</span><span class="dl">"</span><span class="p">;</span>  <span class="c1">//Angular</span>
<span class="s2">`Greetings </span><span class="p">${</span> <span class="nx">name</span> <span class="p">}</span><span class="s2">!`</span><span class="p">;</span>    <span class="c1">//Typescript</span>
<span class="nx">$</span><span class="dl">"</span><span class="s2">Greetings { name }!</span><span class="dl">"</span>    <span class="c1">//Visual basic</span>
<span class="nx">f</span><span class="dl">"</span><span class="s2">Greetings { name }!</span><span class="dl">"</span>    <span class="c1">//Python</span>
</code></pre></div></div>

<p>Java 在没有 String Templates 之前，我们通常使用字符串拼接或格式化方法来构建字符串：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//concatenation</span>
<span class="n">message</span> <span class="o">=</span> <span class="s">"Greetings "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"!"</span><span class="o">;</span>

<span class="c1">//String.format()</span>
<span class="n">message</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"Greetings %s!"</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>  <span class="c1">//concatenation</span>

<span class="c1">//MessageFormat</span>
<span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MessageFormat</span><span class="o">(</span><span class="s">"Greetings {0}!"</span><span class="o">).</span><span class="na">format</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>

<span class="c1">//StringBuilder</span>
<span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">().</span><span class="na">append</span><span class="o">(</span><span class="s">"Greetings "</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="n">name</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">"!"</span><span class="o">).</span><span class="na">toString</span><span class="o">();</span>
</code></pre></div></div>

<p>这些方法或多或少都存在一些缺点，比如难以阅读、冗长、复杂。</p>

<p>Java 使用 String Templates 进行字符串拼接，可以直接在字符串中嵌入表达式，而无需进行额外的处理：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="no">STR</span><span class="o">.</span><span class="s">"Greetings \{name}!"</span><span class="o">;</span>
</code></pre></div></div>

<p>在上面的模板表达式中：</p>

<ul>
  <li>STR 是模板处理器。</li>
  <li><code class="language-plaintext highlighter-rouge">\{name}</code>为表达式，运行时，这些表达式将被相应的变量值替换。</li>
</ul>

<p>Java 目前支持三种模板处理器：</p>

<ul>
  <li>STR：自动执行字符串插值，即将模板中的每个嵌入式表达式替换为其值（转换为字符串）。</li>
  <li>FMT：和 STR 类似，但是它还可以接受格式说明符，这些格式说明符出现在嵌入式表达式的左边，用来控制输出的样式。</li>
  <li>RAW：不会像 STR 和 FMT 模板处理器那样自动处理字符串模板，而是返回一个 <code class="language-plaintext highlighter-rouge">StringTemplate</code> 对象，这个对象包含了模板中的文本和表达式的信息。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Lokesh"</span><span class="o">;</span>

<span class="c1">//STR</span>
<span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="no">STR</span><span class="o">.</span><span class="s">"Greetings \{name}."</span><span class="o">;</span>

<span class="c1">//FMT</span>
<span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="no">STR</span><span class="o">.</span><span class="s">"Greetings %-12s\{name}."</span><span class="o">;</span>

<span class="c1">//RAW</span>
<span class="nc">StringTemplate</span> <span class="n">st</span> <span class="o">=</span> <span class="no">RAW</span><span class="o">.</span><span class="s">"Greetings \{name}."</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="no">STR</span><span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="n">st</span><span class="o">);</span>
</code></pre></div></div>

<p>除了 JDK 自带的三种模板处理器外，你还可以实现 <code class="language-plaintext highlighter-rouge">StringTemplate.Processor</code> 接口来创建自己的模板处理器，只需要继承 <code class="language-plaintext highlighter-rouge">StringTemplate.Processor</code>接口，然后实现 <code class="language-plaintext highlighter-rouge">process</code> 方法即可。</p>

<p>我们可以使用局部变量、静态/非静态字段甚至方法作为嵌入表达式：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//variable</span>
<span class="n">message</span> <span class="o">=</span> <span class="no">STR</span><span class="o">.</span><span class="s">"Greetings \{name}!"</span><span class="o">;</span>

<span class="c1">//method</span>
<span class="n">message</span> <span class="o">=</span> <span class="no">STR</span><span class="o">.</span><span class="s">"Greetings \{getName()}!"</span><span class="o">;</span>

<span class="c1">//field</span>
<span class="n">message</span> <span class="o">=</span> <span class="no">STR</span><span class="o">.</span><span class="s">"Greetings \{this.name}!"</span><span class="o">;</span>
</code></pre></div></div>

<p>还可以在表达式中执行计算并打印结果：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="o">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="no">STR</span><span class="o">.</span><span class="s">"\{x} + \{y} = \{x + y}"</span><span class="o">;</span>  <span class="c1">//"10 + 20 = 30"</span>
</code></pre></div></div>

<p>为了提高可读性，我们可以将嵌入的表达式分成多行:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">time</span> <span class="o">=</span> <span class="no">STR</span><span class="o">.</span><span class="s">"The current time is \{
    //sample comment - current time in HH:mm:ss
    DateTimeFormatter
      .ofPattern("</span><span class="nl">HH:mm:</span><span class="n">ss</span><span class="s">")
      .format(LocalTime.now())
  }."</span><span class="o">;</span>
</code></pre></div></div>

<h2 id="jep431序列化集合">JEP431：序列化集合</h2>

<p>JDK 21 引入了一种新的集合类型：<strong>Sequenced Collections（序列化集合，也叫有序集合）</strong>，这是一种具有确定出现顺序（encounter order）的集合（无论我们遍历这样的集合多少次，元素的出现顺序始终是固定的）。序列化集合提供了处理集合的第一个和最后一个元素以及反向视图（与原始集合相反的顺序）的简单方法。</p>

<p>Sequenced Collections 包括以下三个接口：</p>

<ul>
  <li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedCollection.html"><code class="language-plaintext highlighter-rouge">SequencedCollection</code></a></li>
  <li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedSet.html"><code class="language-plaintext highlighter-rouge">SequencedSet</code></a></li>
  <li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedMap.html"><code class="language-plaintext highlighter-rouge">SequencedMap</code></a></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">SequencedCollection</code> 接口继承了 <code class="language-plaintext highlighter-rouge">Collection</code>接口， 提供了在集合两端访问、添加或删除元素以及获取集合的反向视图的方法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">SequencedCollection</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Collection</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>

  <span class="c1">// New Method</span>

  <span class="nc">SequencedCollection</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">reversed</span><span class="o">();</span>

  <span class="c1">// Promoted methods from Deque&lt;E&gt;</span>

  <span class="kt">void</span> <span class="nf">addFirst</span><span class="o">(</span><span class="no">E</span><span class="o">);</span>
  <span class="kt">void</span> <span class="nf">addLast</span><span class="o">(</span><span class="no">E</span><span class="o">);</span>

  <span class="no">E</span> <span class="nf">getFirst</span><span class="o">();</span>
  <span class="no">E</span> <span class="nf">getLast</span><span class="o">();</span>

  <span class="no">E</span> <span class="nf">removeFirst</span><span class="o">();</span>
  <span class="no">E</span> <span class="nf">removeLast</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">List</code> 和 <code class="language-plaintext highlighter-rouge">Deque</code> 接口实现了<code class="language-plaintext highlighter-rouge">SequencedCollection</code> 接口。</p>

<p>这里以 <code class="language-plaintext highlighter-rouge">ArrayList</code> 为例，演示一下实际使用效果：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">arrayList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

<span class="n">arrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>   <span class="c1">// List contains: [1]</span>

<span class="n">arrayList</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>  <span class="c1">// List contains: [0, 1]</span>
<span class="n">arrayList</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>   <span class="c1">// List contains: [0, 1, 2]</span>

<span class="nc">Integer</span> <span class="n">firstElement</span> <span class="o">=</span> <span class="n">arrayList</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>  <span class="c1">// 0</span>
<span class="nc">Integer</span> <span class="n">lastElement</span> <span class="o">=</span> <span class="n">arrayList</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>  <span class="c1">// 2</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">reversed</span> <span class="o">=</span> <span class="n">arrayList</span><span class="o">.</span><span class="na">reversed</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">reversed</span><span class="o">);</span> <span class="c1">// Prints [2, 1, 0]</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">SequencedSet</code>接口直接继承了 <code class="language-plaintext highlighter-rouge">SequencedCollection</code> 接口并重写了 <code class="language-plaintext highlighter-rouge">reversed()</code> 方法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">SequencedSet</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">SequencedCollection</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="nc">SequencedSet</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">reversed</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">SortedSet</code> 和 <code class="language-plaintext highlighter-rouge">LinkedHashSet</code> 实现了<code class="language-plaintext highlighter-rouge">SequencedSet</code>接口。</p>

<p>这里以 <code class="language-plaintext highlighter-rouge">LinkedHashSet</code> 为例，演示一下实际使用效果：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">LinkedHashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">linkedHashSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;(</span><span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span>

<span class="nc">Integer</span> <span class="n">firstElement</span> <span class="o">=</span> <span class="n">linkedHashSet</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>   <span class="c1">// 1</span>
<span class="nc">Integer</span> <span class="n">lastElement</span> <span class="o">=</span> <span class="n">linkedHashSet</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>    <span class="c1">// 3</span>

<span class="n">linkedHashSet</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>  <span class="c1">//List contains: [0, 1, 2, 3]</span>
<span class="n">linkedHashSet</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>   <span class="c1">//List contains: [0, 1, 2, 3, 4]</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">linkedHashSet</span><span class="o">.</span><span class="na">reversed</span><span class="o">());</span>   <span class="c1">//Prints [5, 3, 2, 1, 0]</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">SequencedMap</code> 接口继承了 <code class="language-plaintext highlighter-rouge">Map</code>接口， 提供了在集合两端访问、添加或删除键值对、获取包含 key 的 <code class="language-plaintext highlighter-rouge">SequencedSet</code>、包含 value 的 <code class="language-plaintext highlighter-rouge">SequencedCollection</code>、包含 entry（键值对） 的 <code class="language-plaintext highlighter-rouge">SequencedSet</code>以及获取集合的反向视图的方法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">SequencedMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>

  <span class="c1">// New Methods</span>

  <span class="nc">SequencedMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">reversed</span><span class="o">();</span>

  <span class="nc">SequencedSet</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="nf">sequencedKeySet</span><span class="o">();</span>
  <span class="nc">SequencedCollection</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">sequencedValues</span><span class="o">();</span>
  <span class="nc">SequencedSet</span><span class="o">&lt;</span><span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="nf">sequencedEntrySet</span><span class="o">();</span>

  <span class="no">V</span> <span class="nf">putFirst</span><span class="o">(</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">);</span>
  <span class="no">V</span> <span class="nf">putLast</span><span class="o">(</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">);</span>


  <span class="c1">// Promoted Methods from NavigableMap&lt;K, V&gt;</span>

  <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">firstEntry</span><span class="o">();</span>
  <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">lastEntry</span><span class="o">();</span>

  <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">pollFirstEntry</span><span class="o">();</span>
  <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">pollLastEntry</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">SortedMap</code> 和<code class="language-plaintext highlighter-rouge">LinkedHashMap</code> 实现了<code class="language-plaintext highlighter-rouge">SequencedMap</code> 接口。</p>

<p>这里以 <code class="language-plaintext highlighter-rouge">LinkedHashMap</code> 为例，演示一下实际使用效果：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">LinkedHashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashMap</span><span class="o">&lt;&gt;();</span>

<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"One"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">"Two"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s">"Three"</span><span class="o">);</span>

<span class="n">map</span><span class="o">.</span><span class="na">firstEntry</span><span class="o">();</span>   <span class="c1">//1=One</span>
<span class="n">map</span><span class="o">.</span><span class="na">lastEntry</span><span class="o">();</span>    <span class="c1">//3=Three</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>  <span class="c1">//{1=One, 2=Two, 3=Three}</span>

<span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">first</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">pollFirstEntry</span><span class="o">();</span>   <span class="c1">//1=One</span>
<span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">last</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">pollLastEntry</span><span class="o">();</span>    <span class="c1">//3=Three</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>  <span class="c1">//{2=Two}</span>

<span class="n">map</span><span class="o">.</span><span class="na">putFirst</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"One"</span><span class="o">);</span>     <span class="c1">//{1=One, 2=Two}</span>
<span class="n">map</span><span class="o">.</span><span class="na">putLast</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s">"Three"</span><span class="o">);</span>    <span class="c1">//{1=One, 2=Two, 3=Three}</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>  <span class="c1">//{1=One, 2=Two, 3=Three}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">reversed</span><span class="o">());</span>   <span class="c1">//{3=Three, 2=Two, 1=One}</span>
</code></pre></div></div>

<h2 id="jep-439分代-zgc">JEP 439：分代 ZGC</h2>

<p>JDK21 中对 ZGC 进行了功能扩展，增加了分代 GC 功能。不过，默认是关闭的，需要通过配置打开：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 启用分代ZGC
java <span class="nt">-XX</span>:+UseZGC <span class="nt">-XX</span>:+ZGenerational ...
</code></pre></div></div>

<p>在未来的版本中，官方会把 ZGenerational 设为默认值，即默认打开 ZGC 的分代 GC。在更晚的版本中，非分代 ZGC 就被移除。</p>

<blockquote>
  <p>In a future release we intend to make Generational ZGC the default, at which point -XX:-ZGenerational will select non-generational ZGC. In an even later release we intend to remove non-generational ZGC, at which point the ZGenerational option will become obsolete.</p>

  <p>在将来的版本中，我们打算将 Generational ZGC 作为默认选项，此时-XX:-ZGenerational 将选择非分代 ZGC。在更晚的版本中，我们打算移除非分代 ZGC，此时 ZGenerational 选项将变得过时。</p>
</blockquote>

<p>分代 ZGC 可以显著减少垃圾回收过程中的停顿时间，并提高应用程序的响应性能。这对于大型 Java 应用程序和高并发场景下的性能优化非常有价值。</p>

<h2 id="jep-440记录模式">JEP 440：记录模式</h2>

<p>记录模式在 Java 19 进行了第一次预览， 由 <a href="https://openjdk.org/jeps/405">JEP 405</a> 提出。JDK 20 中是第二次预览，由 <a href="https://openjdk.org/jeps/432">JEP 432</a> 提出。最终，记录模式在 JDK21 顺利转正。</p>

<p><a href="./java20.md">Java 20 新特性概览</a>已经详细介绍过记录模式，这里就不重复了。</p>

<h2 id="jep-441switch-的模式匹配">JEP 441：switch 的模式匹配</h2>

<p>增强 Java 中的 switch 表达式和语句，允许在 case 标签中使用模式。当模式匹配时，执行 case 标签对应的代码。</p>

<p>在下面的代码中，switch 表达式使用了类型模式来进行匹配。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="nc">String</span> <span class="nf">formatterPatternSwitch</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">switch</span> <span class="o">(</span><span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Integer</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"int %d"</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="k">case</span> <span class="nc">Long</span> <span class="n">l</span>    <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"long %d"</span><span class="o">,</span> <span class="n">l</span><span class="o">);</span>
        <span class="k">case</span> <span class="nc">Double</span> <span class="n">d</span>  <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"double %f"</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
        <span class="k">case</span> <span class="nc">String</span> <span class="n">s</span>  <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"String %s"</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
        <span class="k">default</span>        <span class="o">-&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">};</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="jep-442外部函数和内存-api第三次预览">JEP 442：外部函数和内存 API（第三次预览）</h2>

<p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。</p>

<p>外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 <a href="https://openjdk.java.net/jeps/412">JEP 412</a> 提出。Java 18 中进行了第二次孵化，由<a href="https://openjdk.org/jeps/419">JEP 419</a> 提出。Java 19 中是第一次预览，由 <a href="https://openjdk.org/jeps/424">JEP 424</a> 提出。JDK 20 中是第二次预览，由 <a href="https://openjdk.org/jeps/434">JEP 434</a> 提出。JDK 21 中是第三次预览，由 <a href="https://openjdk.org/jeps/442">JEP 442</a> 提出。</p>

<p>在 <a href="./java19.md">Java 19 新特性概览</a> 中，我有详细介绍到外部函数和内存 API，这里就不再做额外的介绍了。</p>

<h2 id="jep-443未命名模式和变量预览">JEP 443：未命名模式和变量（预览）</h2>

<p>未命名模式和变量使得我们可以使用下划线 <code class="language-plaintext highlighter-rouge">_</code> 表示未命名的变量以及模式匹配时不使用的组件，旨在提高代码的可读性和可维护性。</p>

<p>未命名变量的典型场景是 <code class="language-plaintext highlighter-rouge">try-with-resources</code> 语句、 <code class="language-plaintext highlighter-rouge">catch</code> 子句中的异常变量和<code class="language-plaintext highlighter-rouge">for</code>循环。当变量不需要使用的时候就可以使用下划线 <code class="language-plaintext highlighter-rouge">_</code>代替，这样清晰标识未被使用的变量。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="kt">var</span> <span class="n">_</span> <span class="o">=</span> <span class="nc">ScopedContext</span><span class="o">.</span><span class="na">acquire</span><span class="o">())</span> <span class="o">{</span>
  <span class="c1">// No use of acquired resource</span>
<span class="o">}</span>
<span class="k">try</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">_</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">_</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">runOnce</span><span class="o">();</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>未命名模式是一个无条件的模式，并不绑定任何值。未命名模式变量出现在类型模式中。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="k">instanceof</span> <span class="nf">ColoredPoint</span><span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="nc">Color</span> <span class="n">c</span><span class="o">))</span> <span class="o">{</span> <span class="o">...</span> <span class="n">c</span> <span class="o">...</span> <span class="o">}</span>

<span class="k">switch</span> <span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nf">Box</span><span class="o">(</span><span class="nc">RedBall</span> <span class="n">_</span><span class="o">),</span> <span class="nc">Box</span><span class="o">(</span><span class="nc">BlueBall</span> <span class="n">_</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">processBox</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
    <span class="k">case</span> <span class="nf">Box</span><span class="o">(</span><span class="nc">GreenBall</span> <span class="n">_</span><span class="o">)</span>                <span class="o">-&gt;</span> <span class="n">stopProcessing</span><span class="o">();</span>
    <span class="k">case</span> <span class="nf">Box</span><span class="o">(</span><span class="n">_</span><span class="o">)</span>                          <span class="o">-&gt;</span> <span class="n">pickAnotherBox</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="jep-444虚拟线程">JEP 444：虚拟线程</h2>

<p>虚拟线程是一项重量级的更新，一定一定要重视！</p>

<p>虚拟线程在 Java 19 中进行了第一次预览，由<a href="https://openjdk.org/jeps/425">JEP 425</a>提出。JDK 20 中是第二次预览。最终，虚拟线程在 JDK21 顺利转正。</p>

<p><a href="./java20.md">Java 20 新特性概览</a>已经详细介绍过虚拟线程，这里就不重复了。</p>

<h2 id="jep-445未命名类和实例-main-方法-预览">JEP 445：未命名类和实例 main 方法 （预览）</h2>

<p>这个特性主要简化了 <code class="language-plaintext highlighter-rouge">main</code> 方法的的声明。对于 Java 初学者来说，这个 <code class="language-plaintext highlighter-rouge">main</code> 方法的声明引入了太多的 Java 语法概念，不利于初学者快速上手。</p>

<p>没有使用该特性之前定义一个 <code class="language-plaintext highlighter-rouge">main</code> 方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>使用该新特性之后定义一个 <code class="language-plaintext highlighter-rouge">main</code> 方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">main</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>进一步精简(未命名的类允许我们不定义类名)：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="o">()</span> <span class="o">{</span>
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="参考">参考</h2>

<ul>
  <li>Java 21 String Templates：<a href="https://howtodoinjava.com/java/java-string-templates/">https://howtodoinjava.com/java/java-string-templates/</a></li>
  <li>Java 21 Sequenced Collections：<a href="https://howtodoinjava.com/java/sequenced-collections/">https://howtodoinjava.com/java/sequenced-collections/</a></li>
</ul>
