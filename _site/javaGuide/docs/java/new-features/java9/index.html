<p><strong>Java 9</strong> 发布于 2017 年 9 月 21 日 。作为 Java 8 之后 3 年半才发布的新版本，Java 9 带来了很多重大的变化其中最重要的改动是 Java 平台模块系统的引入，其他还有诸如集合、<code class="language-plaintext highlighter-rouge">Stream</code> 流……。</p>

<p>你可以在 <a href="http://jdk.java.net/archive/">Archived OpenJDK General-Availability Releases</a> 上下载自己需要的 JDK 版本！官方的新特性说明文档地址：<a href="https://openjdk.java.net/projects/jdk/">https://openjdk.java.net/projects/jdk/</a> 。</p>

<p><strong>概览（精选了一部分）</strong>：</p>

<ul>
  <li><a href="https://openjdk.java.net/jeps/222">JEP 222: Java 命令行工具</a></li>
  <li><a href="https://openjdk.java.net/jeps/261">JEP 261: 模块化系统</a></li>
  <li><a href="https://openjdk.java.net/jeps/248">JEP 248：G1 成为默认垃圾回收器</a></li>
  <li><a href="https://openjdk.java.net/jeps/193">JEP 193: 变量句柄</a></li>
  <li><a href="https://openjdk.java.net/jeps/254">JEP 254：字符串存储结构优化</a></li>
</ul>

<h2 id="jshell">JShell</h2>

<p>JShell 是 Java 9 新增的一个实用工具。为 Java 提供了类似于 Python 的实时命令行交互工具。</p>

<p>在 JShell 中可以直接输入表达式并查看其执行结果。</p>

<p><img src="https://oss.javaguide.cn/java-guide-blog/image-20210816083417616.png" alt="" /></p>

<p><strong>JShell 为我们带来了哪些好处呢？</strong></p>

<ol>
  <li>降低了输出第一行 Java 版”Hello World！”的门槛，能够提高新手的学习热情。</li>
  <li>在处理简单的小逻辑，验证简单的小问题时，比 IDE 更有效率（并不是为了取代 IDE，对于复杂逻辑的验证，IDE 更合适，两者互补）。</li>
  <li>……</li>
</ol>

<p><strong>JShell 的代码和普通的可编译代码，有什么不一样？</strong></p>

<ol>
  <li>一旦语句输入完成，JShell 立即就能返回执行的结果，而不再需要编辑器、编译器、解释器。</li>
  <li>JShell 支持变量的重复声明，后面声明的会覆盖前面声明的。</li>
  <li>JShell 支持独立的表达式比如普通的加法运算 <code class="language-plaintext highlighter-rouge">1 + 1</code>。</li>
  <li>……</li>
</ol>

<h2 id="模块化系统">模块化系统</h2>

<p>模块系统是<a href="https://openjdk.java.net/projects/jigsaw/">Jigsaw Project</a>的一部分，把模块化开发实践引入到了 Java 平台中，可以让我们的代码可重用性更好！</p>

<p><strong>什么是模块系统？</strong> 官方的定义是：</p>

<blockquote>
  <p>A uniquely named, reusable group of related packages, as well as resources (such as images and XML files) and a module descriptor。</p>
</blockquote>

<p>简单来说，你可以将一个模块看作是一组唯一命名、可重用的包、资源和模块描述文件（<code class="language-plaintext highlighter-rouge">module-info.java</code>）。</p>

<p>任意一个 jar 文件，只要加上一个模块描述文件（<code class="language-plaintext highlighter-rouge">module-info.java</code>），就可以升级为一个模块。</p>

<p><img src="https://oss.javaguide.cn/java-guide-blog/module-structure.png" alt="" /></p>

<p>在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 <strong><a href="http://openjdk.java.net/jeps/282">jlink</a> 工具</strong> (Jlink 是随 Java 9 一起发布的新命令行工具。它允许开发人员为基于模块的 Java 应用程序创建自己的轻量级、定制的 JRE)，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。</p>

<p>我们可以通过 <code class="language-plaintext highlighter-rouge">exports</code> 关键词精准控制哪些类可以对外开放使用，哪些类只能内部使用。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">module</span> <span class="n">my</span><span class="o">.</span><span class="na">module</span> <span class="o">{</span>
    <span class="c1">//exports 公开指定包的所有公共成员</span>
    <span class="n">exports</span> <span class="n">com</span><span class="o">.</span><span class="na">my</span><span class="o">.</span><span class="na">package</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
<span class="o">}</span>

<span class="n">module</span> <span class="n">my</span><span class="o">.</span><span class="na">module</span> <span class="o">{</span>
     <span class="c1">//exports…to 限制访问的成员范围</span>
    <span class="n">export</span> <span class="n">com</span><span class="o">.</span><span class="na">my</span><span class="o">.</span><span class="na">package</span><span class="o">.</span><span class="na">name</span> <span class="n">to</span> <span class="n">com</span><span class="o">.</span><span class="na">specific</span><span class="o">.</span><span class="na">package</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>想要深入了解 Java 9 的模块化，可以参考下面这几篇文章：</p>

<ul>
  <li><a href="https://openjdk.java.net/projects/jigsaw/quick-start">《Project Jigsaw: Module System Quick-Start Guide》</a></li>
  <li><a href="https://stacktraceguru.com/java9/module-introduction">《Java 9 Modules: part 1》</a></li>
  <li><a href="http://www.cnblogs.com/IcanFixIt/p/6947763.html">Java 9 揭秘（2. 模块化系统）</a></li>
</ul>

<h2 id="g1-成为默认垃圾回收器">G1 成为默认垃圾回收器</h2>

<p>在 Java 8 的时候，默认垃圾回收器是 Parallel Scavenge（新生代）+Parallel Old（老年代）。到了 Java 9, CMS 垃圾回收器被废弃了，<strong>G1（Garbage-First Garbage Collector）</strong> 成为了默认垃圾回收器。</p>

<p>G1 还是在 Java 7 中被引入的，经过两个版本优异的表现成为成为默认垃圾回收器。</p>

<h2 id="快速创建不可变集合">快速创建不可变集合</h2>

<p>增加了<code class="language-plaintext highlighter-rouge">List.of()</code>、<code class="language-plaintext highlighter-rouge">Set.of()</code>、<code class="language-plaintext highlighter-rouge">Map.of()</code> 和 <code class="language-plaintext highlighter-rouge">Map.ofEntries()</code>等工厂方法来创建不可变集合（有点参考 Guava 的味道）：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Java"</span><span class="o">,</span> <span class="s">"C++"</span><span class="o">);</span>
<span class="nc">Set</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Java"</span><span class="o">,</span> <span class="s">"C++"</span><span class="o">);</span>
<span class="nc">Map</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Java"</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="s">"C++"</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
</code></pre></div></div>

<p>使用 <code class="language-plaintext highlighter-rouge">of()</code> 创建的集合为不可变集合，不能进行添加、删除、替换、 排序等操作，不然会报 <code class="language-plaintext highlighter-rouge">java.lang.UnsupportedOperationException</code> 异常。</p>

<h2 id="string-存储结构优化">String 存储结构优化</h2>

<p>Java 8 及之前的版本，<code class="language-plaintext highlighter-rouge">String</code> 一直是用 <code class="language-plaintext highlighter-rouge">char[]</code> 存储。在 Java 9 之后，<code class="language-plaintext highlighter-rouge">String</code> 的实现改用 <code class="language-plaintext highlighter-rouge">byte[]</code> 数组存储字符串，节省了空间。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">String</span> <span class="kd">implements</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span><span class="o">,</span><span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;,</span> <span class="nc">CharSequence</span> <span class="o">{</span>
    <span class="c1">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span>
    <span class="nd">@Stable</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">value</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="接口私有方法">接口私有方法</h2>

<p>Java 9 允许在接口中使用私有方法。这样的话，接口的使用就更加灵活了，有点像是一个简化版的抽象类。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MyInterface</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">methodPrivate</span><span class="o">(){</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="try-with-resources-增强">try-with-resources 增强</h2>

<p>在 Java 9 之前，我们只能在 <code class="language-plaintext highlighter-rouge">try-with-resources</code> 块中声明变量：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">Scanner</span> <span class="n">scanner</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"testRead.txt"</span><span class="o">));</span>
    <span class="nc">PrintWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"testWrite.txt"</span><span class="o">)))</span> <span class="o">{</span>
    <span class="c1">// omitted</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在 Java 9 之后，在 <code class="language-plaintext highlighter-rouge">try-with-resources</code> 语句中可以使用 effectively-final 变量。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="nc">Scanner</span> <span class="n">scanner</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"testRead.txt"</span><span class="o">));</span>
<span class="nc">PrintWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"testWrite.txt"</span><span class="o">))</span>
<span class="k">try</span> <span class="o">(</span><span class="n">scanner</span><span class="o">;</span><span class="n">writer</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// omitted</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>什么是 effectively-final 变量？</strong> 简单来说就是没有被 <code class="language-plaintext highlighter-rouge">final</code> 修饰但是值在初始化后从未更改的变量。</p>

<p>正如上面的代码所演示的那样，即使 <code class="language-plaintext highlighter-rouge">writer</code> 变量没有被显示声明为 <code class="language-plaintext highlighter-rouge">final</code>，但它在第一次被赋值后就不会改变了，因此，它就是 effectively-final 变量。</p>

<h2 id="stream--optional-增强">Stream &amp; Optional 增强</h2>

<p><code class="language-plaintext highlighter-rouge">Stream</code> 中增加了新的方法 <code class="language-plaintext highlighter-rouge">ofNullable()</code>、<code class="language-plaintext highlighter-rouge">dropWhile()</code>、<code class="language-plaintext highlighter-rouge">takeWhile()</code> 以及 <code class="language-plaintext highlighter-rouge">iterate()</code> 方法的重载方法。</p>

<p>Java 9 中的 <code class="language-plaintext highlighter-rouge">ofNullable()</code> 方 法允许我们创建一个单元素的 <code class="language-plaintext highlighter-rouge">Stream</code>，可以包含一个非空元素，也可以创建一个空 <code class="language-plaintext highlighter-rouge">Stream</code>。 而在 Java 8 中则不可以创建空的 <code class="language-plaintext highlighter-rouge">Stream</code> 。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stringStream</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">ofNullable</span><span class="o">(</span><span class="s">"Java"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">stringStream</span><span class="o">.</span><span class="na">count</span><span class="o">());</span><span class="c1">// 1</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nullStream</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">ofNullable</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">nullStream</span><span class="o">.</span><span class="na">count</span><span class="o">());</span><span class="c1">//0</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">takeWhile()</code> 方法可以从 <code class="language-plaintext highlighter-rouge">Stream</code> 中依次获取满足条件的元素，直到不满足条件为止结束获取。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integerList</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">11</span><span class="o">,</span> <span class="mi">33</span><span class="o">,</span> <span class="mi">66</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">13</span><span class="o">);</span>
<span class="n">integerList</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">takeWhile</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span><span class="c1">// 11 33</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">dropWhile()</code> 方法的效果和 <code class="language-plaintext highlighter-rouge">takeWhile()</code> 相反。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integerList2</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">11</span><span class="o">,</span> <span class="mi">33</span><span class="o">,</span> <span class="mi">66</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">13</span><span class="o">);</span>
<span class="n">integerList2</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">dropWhile</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span><span class="c1">// 66 8 9 13</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">iterate()</code> 方法的新重载方法提供了一个 <code class="language-plaintext highlighter-rouge">Predicate</code> 参数 (判断条件)来决定什么时候结束迭代</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">iterate</span><span class="o">(</span><span class="kd">final</span> <span class="no">T</span> <span class="n">seed</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">UnaryOperator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
<span class="o">}</span>
<span class="c1">// 新增加的重载方法</span>
<span class="kd">public</span> <span class="kd">static</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">iterate</span><span class="o">(</span><span class="no">T</span> <span class="n">seed</span><span class="o">,</span> <span class="nc">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">hasNext</span><span class="o">,</span> <span class="nc">UnaryOperator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>

<span class="o">}</span>
</code></pre></div></div>

<p>两者的使用对比如下，新的 <code class="language-plaintext highlighter-rouge">iterate()</code> 重载方法更加灵活一些。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 使用原始 iterate() 方法输出数字 1~10</span>
<span class="nc">Stream</span><span class="o">.</span><span class="na">iterate</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
<span class="c1">// 使用新的 iterate() 重载方法输出数字 1~10</span>
<span class="nc">Stream</span><span class="o">.</span><span class="na">iterate</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Optional</code> 类中新增了 <code class="language-plaintext highlighter-rouge">ifPresentOrElse()</code>、<code class="language-plaintext highlighter-rouge">or()</code> 和 <code class="language-plaintext highlighter-rouge">stream()</code> 等方法</p>

<p><code class="language-plaintext highlighter-rouge">ifPresentOrElse()</code> 方法接受两个参数 <code class="language-plaintext highlighter-rouge">Consumer</code> 和 <code class="language-plaintext highlighter-rouge">Runnable</code> ，如果 <code class="language-plaintext highlighter-rouge">Optional</code> 不为空调用 <code class="language-plaintext highlighter-rouge">Consumer</code> 参数，为空则调用 <code class="language-plaintext highlighter-rouge">Runnable</code> 参数。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">ifPresentOrElse</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">,</span> <span class="nc">Runnable</span> <span class="n">emptyAction</span><span class="o">)</span>

<span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">objectOptional</span> <span class="o">=</span> <span class="nc">Optional</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
<span class="n">objectOptional</span><span class="o">.</span><span class="na">ifPresentOrElse</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Empty!!!"</span><span class="o">));</span><span class="c1">// Empty!!!</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">or()</code> 方法接受一个 <code class="language-plaintext highlighter-rouge">Supplier</code> 参数 ，如果 <code class="language-plaintext highlighter-rouge">Optional</code> 为空则返回 <code class="language-plaintext highlighter-rouge">Supplier</code> 参数指定的 <code class="language-plaintext highlighter-rouge">Optional</code> 值。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Optional</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">or</span><span class="o">(</span><span class="nc">Supplier</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Optional</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;&gt;</span> <span class="n">supplier</span><span class="o">)</span>

<span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">objectOptional</span> <span class="o">=</span> <span class="nc">Optional</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
<span class="n">objectOptional</span><span class="o">.</span><span class="na">or</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"java"</span><span class="o">)).</span><span class="na">ifPresent</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span><span class="c1">//java</span>
</code></pre></div></div>

<h2 id="进程-api">进程 API</h2>

<p>Java 9 增加了 <code class="language-plaintext highlighter-rouge">java.lang.ProcessHandle</code> 接口来实现对原生进程进行管理，尤其适合于管理长时间运行的进程。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取当前正在运行的 JVM 的进程</span>
<span class="nc">ProcessHandle</span> <span class="n">currentProcess</span> <span class="o">=</span> <span class="nc">ProcessHandle</span><span class="o">.</span><span class="na">current</span><span class="o">();</span>
<span class="c1">// 输出进程的 id</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">currentProcess</span><span class="o">.</span><span class="na">pid</span><span class="o">());</span>
<span class="c1">// 输出进程的信息</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">currentProcess</span><span class="o">.</span><span class="na">info</span><span class="o">());</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ProcessHandle</code> 接口概览：</p>

<p><img src="https://oss.javaguide.cn/java-guide-blog/image-20210816104614414.png" alt="" /></p>

<h2 id="响应式流--reactive-streams-">响应式流 （ Reactive Streams ）</h2>

<p>在 Java 9 中的 <code class="language-plaintext highlighter-rouge">java.util.concurrent.Flow</code> 类中新增了反应式流规范的核心接口 。</p>

<p><code class="language-plaintext highlighter-rouge">Flow</code> 中包含了 <code class="language-plaintext highlighter-rouge">Flow.Publisher</code>、<code class="language-plaintext highlighter-rouge">Flow.Subscriber</code>、<code class="language-plaintext highlighter-rouge">Flow.Subscription</code> 和 <code class="language-plaintext highlighter-rouge">Flow.Processor</code> 等 4 个核心接口。Java 9 还提供了<code class="language-plaintext highlighter-rouge">SubmissionPublisher</code> 作为<code class="language-plaintext highlighter-rouge">Flow.Publisher</code> 的一个实现。</p>

<p>关于 Java 9 响应式流更详细的解读，推荐你看 <a href="https://www.cnblogs.com/IcanFixIt/p/7245377.html">Java 9 揭秘（17. Reactive Streams ）- 林本托</a> 这篇文章。</p>

<h2 id="变量句柄">变量句柄</h2>

<p>变量句柄是一个变量或一组变量的引用，包括静态域，非静态域，数组元素和堆外数据结构中的组成部分等。</p>

<p>变量句柄的含义类似于已有的方法句柄 <code class="language-plaintext highlighter-rouge">MethodHandle</code> ，由 Java 类 <code class="language-plaintext highlighter-rouge">java.lang.invoke.VarHandle</code> 来表示，可以使用类 <code class="language-plaintext highlighter-rouge">java.lang.invoke.MethodHandles.Lookup</code> 中的静态工厂方法来创建 <code class="language-plaintext highlighter-rouge">VarHandle</code> 对象。</p>

<p><code class="language-plaintext highlighter-rouge">VarHandle</code> 的出现替代了 <code class="language-plaintext highlighter-rouge">java.util.concurrent.atomic</code> 和 <code class="language-plaintext highlighter-rouge">sun.misc.Unsafe</code> 的部分操作。并且提供了一系列标准的内存屏障操作，用于更加细粒度的控制内存排序。在安全性、可用性、性能上都要优于现有的 API。</p>

<h2 id="其它">其它</h2>

<ul>
  <li><strong>平台日志 API 改进</strong>：Java 9 允许为 JDK 和应用配置同样的日志实现。新增了 <code class="language-plaintext highlighter-rouge">System.LoggerFinder</code> 用来管理 JDK 使 用的日志记录器实现。JVM 在运行时只有一个系统范围的 <code class="language-plaintext highlighter-rouge">LoggerFinder</code> 实例。我们可以通过添加自己的 <code class="language-plaintext highlighter-rouge">System.LoggerFinder</code> 实现来让 JDK 和应用使用 SLF4J 等其他日志记录框架。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">CompletableFuture</code>类增强</strong>：新增了几个新的方法（<code class="language-plaintext highlighter-rouge">completeAsync</code> ，<code class="language-plaintext highlighter-rouge">orTimeout</code> 等）。</li>
  <li><strong>Nashorn 引擎的增强</strong>：Nashorn 是从 Java8 开始引入的 JavaScript 引擎，Java9 对 Nashorn 做了些增强，实现了一些 ES6 的新特性（Java 11 中已经被弃用）。</li>
  <li><strong>I/O 流的新特性</strong>：增加了新的方法来读取和复制 <code class="language-plaintext highlighter-rouge">InputStream</code> 中包含的数据。</li>
  <li><strong>改进应用的安全性能</strong>：Java 9 新增了 4 个 SHA- 3 哈希算法，SHA3-224、SHA3-256、SHA3-384 和 SHA3-512。</li>
  <li><strong>改进方法句柄（Method Handle）</strong>：方法句柄从 Java7 开始引入，Java9 在类<code class="language-plaintext highlighter-rouge">java.lang.invoke.MethodHandles</code> 中新增了更多的静态方法来创建不同类型的方法句柄。</li>
  <li>……</li>
</ul>

<h2 id="参考">参考</h2>

<ul>
  <li>Java version history：<a href="https://en.wikipedia.org/wiki/Java_version_history">https://en.wikipedia.org/wiki/Java_version_history</a></li>
  <li>Release Notes for JDK 9 and JDK 9 Update Releases : <a href="https://www.oracle.com/java/technologies/javase/9-all-relnotes.html">https://www.oracle.com/java/technologies/javase/9-all-relnotes.html</a></li>
  <li>《深入剖析 Java 新特性》-极客时间 - JShell：怎么快速验证简单的小问题？</li>
  <li>New Features in Java 9: <a href="https://www.baeldung.com/new-java-9">https://www.baeldung.com/new-java-9</a></li>
  <li>Java – Try with Resources：<a href="https://www.baeldung.com/java-try-with-resources">https://www.baeldung.com/java-try-with-resources</a></li>
</ul>

<!-- @include: @article-footer.snippet.md -->
