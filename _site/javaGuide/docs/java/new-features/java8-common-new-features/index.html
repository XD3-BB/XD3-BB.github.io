<blockquote>
  <p>本文来自<a href="https://github.com/cowbi">cowbi</a>的投稿~</p>
</blockquote>

<!-- markdownlint-disable MD024 -->

<p>Oracle 于 2014 发布了 Java8（jdk1.8），诸多原因使它成为目前市场上使用最多的 jdk 版本。虽然发布距今已将近 7 年，但很多程序员对其新特性还是不够了解，尤其是用惯了 Java8 之前版本的老程序员，比如我。</p>

<p>为了不脱离队伍太远，还是有必要对这些新特性做一些总结梳理。它较 jdk.7 有很多变化或者说是优化，比如 interface 里可以有静态方法，并且可以有方法体，这一点就颠覆了之前的认知；<code class="language-plaintext highlighter-rouge">java.util.HashMap</code> 数据结构里增加了红黑树；还有众所周知的 Lambda 表达式等等。本文不能把所有的新特性都给大家一一分享，只列出比较常用的新特性给大家做详细讲解。更多相关内容请看<a href="https://www.oracle.com/java/technologies/javase/8-whats-new.html">官网关于 Java8 的新特性的介绍</a>。</p>

<h2 id="interface">Interface</h2>

<p>interface 的设计初衷是面向抽象，提高扩展性。这也留有一点遗憾，Interface 修改的时候，实现它的类也必须跟着改。</p>

<p>为了解决接口的修改与现有的实现不兼容的问题。新 interface 的方法可以用<code class="language-plaintext highlighter-rouge">default</code> 或 <code class="language-plaintext highlighter-rouge">static</code>修饰，这样就可以有方法体，实现类也不必重写此方法。</p>

<p>一个 interface 中可以有多个方法被它们修饰，这 2 个修饰符的区别主要也是普通方法和静态方法的区别。</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">default</code>修饰的方法，是普通实例方法，可以用<code class="language-plaintext highlighter-rouge">this</code>调用，可以被子类继承、重写。</li>
  <li><code class="language-plaintext highlighter-rouge">static</code>修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用<code class="language-plaintext highlighter-rouge">Interface</code>调用。</li>
</ol>

<p>我们来看一个实际的例子。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">InterfaceNew</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sm</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"interface提供的方式实现"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sm2</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"interface提供的方式实现"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">default</span> <span class="kt">void</span> <span class="nf">def</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"interface default方法"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">default</span> <span class="kt">void</span> <span class="nf">def2</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"interface default2方法"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//须要实现类重写</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">InterfaceNew1</span> <span class="o">{</span>
    <span class="k">default</span> <span class="kt">void</span> <span class="nf">def</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"InterfaceNew1 default方法"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>如果有一个类既实现了 <code class="language-plaintext highlighter-rouge">InterfaceNew</code> 接口又实现了 <code class="language-plaintext highlighter-rouge">InterfaceNew1</code>接口，它们都有<code class="language-plaintext highlighter-rouge">def()</code>，并且 <code class="language-plaintext highlighter-rouge">InterfaceNew</code> 接口和 <code class="language-plaintext highlighter-rouge">InterfaceNew1</code>接口没有继承关系的话，这时就必须重写<code class="language-plaintext highlighter-rouge">def()</code>。不然的话，编译的时候就会报错。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">InterfaceNewImpl</span> <span class="kd">implements</span> <span class="nc">InterfaceNew</span> <span class="o">,</span> <span class="nc">InterfaceNew1</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">InterfaceNewImpl</span> <span class="n">interfaceNew</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InterfaceNewImpl</span><span class="o">();</span>
        <span class="n">interfaceNew</span><span class="o">.</span><span class="na">def</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">def</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">InterfaceNew1</span><span class="o">.</span><span class="na">super</span><span class="o">.</span><span class="na">def</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">f</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>在 Java 8 ，接口和抽象类有什么区别的？</strong></p>

<p>很多小伙伴认为：“既然 interface 也可以有自己的方法实现，似乎和 abstract class 没多大区别了。”</p>

<p>其实它们还是有区别的</p>

<ol>
  <li>
    <p>interface 和 class 的区别，好像是废话，主要有：</p>

    <ul>
      <li>接口多实现，类单继承</li>
      <li>接口的方法是 public abstract 修饰，变量是 public static final 修饰。 abstract class 可以用其他修饰符</li>
    </ul>
  </li>
  <li>
    <p>interface 的方法是更像是一个扩展插件。而 abstract class 的方法是要继承的。</p>
  </li>
</ol>

<p>开始我们也提到，interface 新增<code class="language-plaintext highlighter-rouge">default</code>和<code class="language-plaintext highlighter-rouge">static</code>修饰的方法，为了解决接口的修改与现有的实现不兼容的问题，并不是为了要替代<code class="language-plaintext highlighter-rouge">abstract class</code>。在使用上，该用 abstract class 的地方还是要用 abstract class，不要因为 interface 的新特性而将之替换。</p>

<p><strong>记住接口永远和类不一样。</strong></p>

<h2 id="functional-interface-函数式接口">functional interface 函数式接口</h2>

<p><strong>定义</strong>：也称 SAM 接口，即 Single Abstract Method interfaces，有且只有一个抽象方法，但可以有多个非抽象方法的接口。</p>

<p>在 java 8 中专门有一个包放函数式接口<code class="language-plaintext highlighter-rouge">java.util.function</code>，该包下的所有接口都有 <code class="language-plaintext highlighter-rouge">@FunctionalInterface</code> 注解，提供函数式编程。</p>

<p>在其他包中也有函数式接口，其中一些没有<code class="language-plaintext highlighter-rouge">@FunctionalInterface</code> 注解，但是只要符合函数式接口的定义就是函数式接口，与是否有</p>

<p><code class="language-plaintext highlighter-rouge">@FunctionalInterface</code>注解无关，注解只是在编译时起到强制规范定义的作用。其在 Lambda 表达式中有广泛的应用。</p>

<h2 id="lambda-表达式">Lambda 表达式</h2>

<p>接下来谈众所周知的 Lambda 表达式。它是推动 Java 8 发布的最重要新特性。是继泛型(<code class="language-plaintext highlighter-rouge">Generics</code>)和注解(<code class="language-plaintext highlighter-rouge">Annotation</code>)以来最大的变化。</p>

<p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。让 java 也能支持简单的<em>函数式编程</em>。</p>

<blockquote>
  <p>Lambda 表达式是一个匿名函数，java 8 允许把函数作为参数传递进方法中。</p>
</blockquote>

<h3 id="语法格式">语法格式</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="n">parameters</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">expression</span> <span class="n">或</span>
<span class="o">(</span><span class="n">parameters</span><span class="o">)</span> <span class="o">-&gt;{</span> <span class="n">statements</span><span class="o">;</span> <span class="o">}</span>
</code></pre></div></div>

<h3 id="lambda-实战">Lambda 实战</h3>

<p>我们用常用的实例来感受 Lambda 带来的便利</p>

<h4 id="替代匿名内部类">替代匿名内部类</h4>

<p>过去给方法传动态参数的唯一方法是使用内部类。比如</p>

<p><strong>1.<code class="language-plaintext highlighter-rouge">Runnable</code> 接口</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The runable now is using!"</span><span class="o">);</span>
            <span class="o">}</span>
<span class="o">}).</span><span class="na">start</span><span class="o">();</span>
<span class="c1">//用lambda</span>
<span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"It's a lambda function!"</span><span class="o">)).</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div>

<p><strong>2.<code class="language-plaintext highlighter-rouge">Comparator</code> 接口</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">strings</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>

<span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">strings</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">o1</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">o1</span> <span class="o">-</span> <span class="n">o2</span><span class="o">;}</span>
<span class="o">});</span>

<span class="c1">//Lambda</span>
<span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">strings</span><span class="o">,</span> <span class="o">(</span><span class="nc">Integer</span> <span class="n">o1</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">o2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">o1</span> <span class="o">-</span> <span class="n">o2</span><span class="o">);</span>
<span class="c1">//分解开</span>
<span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">comparator</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Integer</span> <span class="n">o1</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">o2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">o1</span> <span class="o">-</span> <span class="n">o2</span><span class="o">;</span>
<span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">strings</span><span class="o">,</span> <span class="n">comparator</span><span class="o">);</span>
</code></pre></div></div>

<p><strong>3.<code class="language-plaintext highlighter-rouge">Listener</code> 接口</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">JButton</span> <span class="n">button</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JButton</span><span class="o">();</span>
<span class="n">button</span><span class="o">.</span><span class="na">addItemListener</span><span class="o">(</span><span class="k">new</span> <span class="nc">ItemListener</span><span class="o">()</span> <span class="o">{</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">itemStateChanged</span><span class="o">(</span><span class="nc">ItemEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">e</span><span class="o">.</span><span class="na">getItem</span><span class="o">();</span>
<span class="o">}</span>
<span class="o">});</span>
<span class="c1">//lambda</span>
<span class="n">button</span><span class="o">.</span><span class="na">addItemListener</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">e</span><span class="o">.</span><span class="na">getItem</span><span class="o">());</span>
</code></pre></div></div>

<p><strong>4.自定义接口</strong></p>

<p>上面的 3 个例子是我们在开发过程中最常见的，从中也能体会到 Lambda 带来的便捷与清爽。它只保留实际用到的代码，把无用代码全部省略。那它对接口有没有要求呢？我们发现这些匿名内部类只重写了接口的一个方法，当然也只有一个方法须要重写。这就是我们上文提到的<strong>函数式接口</strong>，也就是说只要方法的参数是函数式接口都可以用 Lambda 表达式。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;{}</span>

<span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Runnable</span><span class="o">{}</span>
</code></pre></div></div>

<p>我们自定义一个函数式接口</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">LambdaInterface</span> <span class="o">{</span>
 <span class="kt">void</span> <span class="nf">f</span><span class="o">();</span>
<span class="o">}</span>
<span class="c1">//使用</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LambdaClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">forEg</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">lambdaInterfaceDemo</span><span class="o">(()-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"自定义函数式接口"</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="c1">//函数式接口参数</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">lambdaInterfaceDemo</span><span class="o">(</span><span class="nc">LambdaInterface</span> <span class="n">i</span><span class="o">){</span>
        <span class="n">i</span><span class="o">.</span><span class="na">f</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="集合迭代">集合迭代</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">lamndaFor</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">strings</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">);</span>
        <span class="c1">//传统foreach</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">strings</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//Lambda foreach</span>
        <span class="n">strings</span><span class="o">.</span><span class="na">forEach</span><span class="o">((</span><span class="n">s</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
        <span class="c1">//or</span>
        <span class="n">strings</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
     <span class="c1">//map</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">map</span><span class="o">.</span><span class="na">forEach</span><span class="o">((</span><span class="n">k</span><span class="o">,</span><span class="n">v</span><span class="o">)-&gt;</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">v</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="方法的引用">方法的引用</h4>

<p>Java 8 允许使用 <code class="language-plaintext highlighter-rouge">::</code> 关键字来传递方法或者构造函数引用，无论如何，表达式返回的类型必须是 functional-interface。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LambdaClassSuper</span> <span class="o">{</span>
    <span class="nc">LambdaInterface</span> <span class="nf">sf</span><span class="o">(){</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LambdaClass</span> <span class="kd">extends</span> <span class="nc">LambdaClassSuper</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">LambdaInterface</span> <span class="nf">staticF</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">LambdaInterface</span> <span class="nf">f</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">show</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//1.调用静态函数，返回类型必须是functional-interface</span>
        <span class="nc">LambdaInterface</span> <span class="n">t</span> <span class="o">=</span> <span class="nl">LambdaClass:</span><span class="o">:</span><span class="n">staticF</span><span class="o">;</span>

        <span class="c1">//2.实例方法调用</span>
        <span class="nc">LambdaClass</span> <span class="n">lambdaClass</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LambdaClass</span><span class="o">();</span>
        <span class="nc">LambdaInterface</span> <span class="n">lambdaInterface</span> <span class="o">=</span> <span class="nl">lambdaClass:</span><span class="o">:</span><span class="n">f</span><span class="o">;</span>

        <span class="c1">//3.超类上的方法调用</span>
        <span class="nc">LambdaInterface</span> <span class="n">superf</span> <span class="o">=</span> <span class="kd">super</span><span class="o">::</span><span class="n">sf</span><span class="o">;</span>

        <span class="c1">//4. 构造方法调用</span>
        <span class="nc">LambdaInterface</span> <span class="n">tt</span> <span class="o">=</span> <span class="nl">LambdaClassSuper:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="访问变量">访问变量</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">strings</span><span class="o">,</span> <span class="o">(</span><span class="nc">Integer</span> <span class="n">o1</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">o2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">o1</span> <span class="o">-</span> <span class="n">i</span><span class="o">);</span>
<span class="c1">//i =3;</span>
</code></pre></div></div>

<p>lambda 表达式可以引用外边变量，但是该变量默认拥有 final 属性，不能被修改，如果修改，编译时就报错。</p>

<h2 id="stream">Stream</h2>

<p>java 新增了 <code class="language-plaintext highlighter-rouge">java.util.stream</code> 包，它和之前的流大同小异。之前接触最多的是资源流，比如<code class="language-plaintext highlighter-rouge">java.io.FileInputStream</code>，通过流把文件从一个地方输入到另一个地方，它只是内容搬运工，对文件内容不做任何<em>CRUD</em>。</p>

<p><code class="language-plaintext highlighter-rouge">Stream</code>依然不存储数据，不同的是它可以检索(Retrieve)和逻辑处理集合数据、包括筛选、排序、统计、计数等。可以想象成是 Sql 语句。</p>

<p>它的源数据可以是 <code class="language-plaintext highlighter-rouge">Collection</code>、<code class="language-plaintext highlighter-rouge">Array</code> 等。由于它的方法参数都是函数式接口类型，所以一般和 Lambda 配合使用。</p>

<h3 id="流类型">流类型</h3>

<ol>
  <li>stream 串行流</li>
  <li>parallelStream 并行流，可多线程执行</li>
</ol>

<h3 id="常用方法">常用方法</h3>

<p>接下来我们看<code class="language-plaintext highlighter-rouge">java.util.stream.Stream</code>常用方法</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
* 返回一个串行流
*/</span>
<span class="k">default</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">stream</span><span class="o">()</span>

<span class="cm">/**
* 返回一个并行流
*/</span>
<span class="k">default</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">parallelStream</span><span class="o">()</span>

<span class="cm">/**
* 返回T的流
*/</span>
<span class="kd">public</span> <span class="kd">static</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">of</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span>

<span class="cm">/**
* 返回其元素是指定值的顺序流。
*/</span>
<span class="kd">public</span> <span class="kd">static</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">of</span><span class="o">(</span><span class="no">T</span><span class="o">...</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">values</span><span class="o">);</span>
<span class="o">}</span>


<span class="cm">/**
* 过滤，返回由与给定predicate匹配的该流的元素组成的流
*/</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="nc">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">);</span>

<span class="cm">/**
* 此流的所有元素是否与提供的predicate匹配。
*/</span>
<span class="kt">boolean</span> <span class="nf">allMatch</span><span class="o">(</span><span class="nc">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">)</span>

<span class="cm">/**
* 此流任意元素是否有与提供的predicate匹配。
*/</span>
<span class="kt">boolean</span> <span class="nf">anyMatch</span><span class="o">(</span><span class="nc">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">);</span>

<span class="cm">/**
* 返回一个 Stream的构建器。
*/</span>
<span class="kd">public</span> <span class="kd">static</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Builder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">builder</span><span class="o">();</span>

<span class="cm">/**
* 使用 Collector对此流的元素进行归纳
*/</span>
<span class="o">&lt;</span><span class="no">R</span><span class="o">,</span> <span class="no">A</span><span class="o">&gt;</span> <span class="no">R</span> <span class="nf">collect</span><span class="o">(</span><span class="nc">Collector</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,</span> <span class="no">A</span><span class="o">,</span> <span class="no">R</span><span class="o">&gt;</span> <span class="n">collector</span><span class="o">);</span>

<span class="cm">/**
 * 返回此流中的元素数。
*/</span>
<span class="kt">long</span> <span class="nf">count</span><span class="o">();</span>

<span class="cm">/**
* 返回由该流的不同元素（根据 Object.equals(Object) ）组成的流。
*/</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">distinct</span><span class="o">();</span>

<span class="cm">/**
 * 遍历
*/</span>
<span class="kt">void</span> <span class="nf">forEach</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">);</span>

<span class="cm">/**
* 用于获取指定数量的流，截短长度不能超过 maxSize 。
*/</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">limit</span><span class="o">(</span><span class="kt">long</span> <span class="n">maxSize</span><span class="o">);</span>

<span class="cm">/**
* 用于映射每个元素到对应的结果
*/</span>
<span class="o">&lt;</span><span class="no">R</span><span class="o">&gt;</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="no">R</span><span class="o">&gt;</span> <span class="nf">map</span><span class="o">(</span><span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">R</span><span class="o">&gt;</span> <span class="n">mapper</span><span class="o">);</span>

<span class="cm">/**
* 根据提供的 Comparator进行排序。
*/</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">sorted</span><span class="o">(</span><span class="nc">Comparator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">comparator</span><span class="o">);</span>

<span class="cm">/**
* 在丢弃流的第一个 n元素后，返回由该流的 n元素组成的流。
*/</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">skip</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">);</span>

<span class="cm">/**
* 返回一个包含此流的元素的数组。
*/</span>
<span class="nc">Object</span><span class="o">[]</span> <span class="nf">toArray</span><span class="o">();</span>

<span class="cm">/**
* 使用提供的 generator函数返回一个包含此流的元素的数组，以分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组。
*/</span>
<span class="o">&lt;</span><span class="no">A</span><span class="o">&gt;</span> <span class="no">A</span><span class="o">[]</span> <span class="nf">toArray</span><span class="o">(</span><span class="nc">IntFunction</span><span class="o">&lt;</span><span class="no">A</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">);</span>

<span class="cm">/**
* 合并流
*/</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">concat</span><span class="o">(</span><span class="nc">Stream</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">,</span> <span class="nc">Stream</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="实战">实战</h3>

<p>本文列出 <code class="language-plaintext highlighter-rouge">Stream</code> 具有代表性的方法之使用，更多的使用方法还是要看 Api。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">strings</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"abc"</span><span class="o">,</span> <span class="s">"def"</span><span class="o">,</span> <span class="s">"gkh"</span><span class="o">,</span> <span class="s">"abc"</span><span class="o">);</span>
    <span class="c1">//返回符合条件的stream</span>
    <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stringStream</span> <span class="o">=</span> <span class="n">strings</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="s">"abc"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="c1">//计算流符合条件的流的数量</span>
    <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="n">stringStream</span><span class="o">.</span><span class="na">count</span><span class="o">();</span>

    <span class="c1">//forEach遍历-&gt;打印元素</span>
    <span class="n">strings</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>

    <span class="c1">//limit 获取到1个元素的stream</span>
    <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">strings</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">limit</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="c1">//toArray 比如我们想看这个limitStream里面是什么，比如转换成String[],比如循环</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">limit</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="nc">String</span><span class="o">[]::</span><span class="k">new</span><span class="o">);</span>

    <span class="c1">//map 对每个元素进行操作返回新流</span>
    <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">strings</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"22"</span><span class="o">);</span>

    <span class="c1">//sorted 排序并打印</span>
    <span class="n">strings</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">sorted</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>

    <span class="c1">//Collectors collect 把abc放入容器中</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">strings</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">string</span> <span class="o">-&gt;</span> <span class="s">"abc"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">string</span><span class="o">)).</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
    <span class="c1">//把list转为string，各元素用，号隔开</span>
    <span class="nc">String</span> <span class="n">mergedString</span> <span class="o">=</span> <span class="n">strings</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">string</span> <span class="o">-&gt;</span> <span class="o">!</span><span class="n">string</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()).</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">joining</span><span class="o">(</span><span class="s">","</span><span class="o">));</span>

    <span class="c1">//对数组的统计，比如用</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">number</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">);</span>

    <span class="nc">IntSummaryStatistics</span> <span class="n">statistics</span> <span class="o">=</span> <span class="n">number</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">mapToInt</span><span class="o">((</span><span class="n">x</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">).</span><span class="na">summaryStatistics</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"列表中最大的数 : "</span><span class="o">+</span><span class="n">statistics</span><span class="o">.</span><span class="na">getMax</span><span class="o">());</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"列表中最小的数 : "</span><span class="o">+</span><span class="n">statistics</span><span class="o">.</span><span class="na">getMin</span><span class="o">());</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"平均数 : "</span><span class="o">+</span><span class="n">statistics</span><span class="o">.</span><span class="na">getAverage</span><span class="o">());</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"所有数之和 : "</span><span class="o">+</span><span class="n">statistics</span><span class="o">.</span><span class="na">getSum</span><span class="o">());</span>

    <span class="c1">//concat 合并流</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">strings2</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"xyz"</span><span class="o">,</span> <span class="s">"jqx"</span><span class="o">);</span>
    <span class="nc">Stream</span><span class="o">.</span><span class="na">concat</span><span class="o">(</span><span class="n">strings2</span><span class="o">.</span><span class="na">stream</span><span class="o">(),</span><span class="n">strings</span><span class="o">.</span><span class="na">stream</span><span class="o">()).</span><span class="na">count</span><span class="o">();</span>

    <span class="c1">//注意 一个Stream只能操作一次，不能断开，否则会报错。</span>
    <span class="nc">Stream</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">strings</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span>
    <span class="c1">//第一次使用</span>
    <span class="n">stream</span><span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="c1">//第二次使用</span>
    <span class="n">stream</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
    <span class="c1">//报错 java.lang.IllegalStateException: stream has already been operated upon or closed</span>

    <span class="c1">//但是可以这样, 连续使用</span>
    <span class="n">stream</span><span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="延迟执行">延迟执行</h3>

<p>在执行返回 <code class="language-plaintext highlighter-rouge">Stream</code> 的方法时，并不立刻执行，而是等返回一个非 <code class="language-plaintext highlighter-rouge">Stream</code> 的方法后才执行。因为拿到 <code class="language-plaintext highlighter-rouge">Stream</code> 并不能直接用，而是需要处理成一个常规类型。这里的 <code class="language-plaintext highlighter-rouge">Stream</code> 可以想象成是二进制流（2 个完全不一样的东东），拿到也看不懂。</p>

<p>我们下面分解一下 <code class="language-plaintext highlighter-rouge">filter</code> 方法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">laziness</span><span class="o">(){</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">strings</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"abc"</span><span class="o">,</span> <span class="s">"def"</span><span class="o">,</span> <span class="s">"gkh"</span><span class="o">,</span> <span class="s">"abc"</span><span class="o">);</span>
  <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">strings</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="k">new</span> <span class="nc">Predicate</span><span class="o">()</span> <span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">test</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Predicate.test 执行"</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
      <span class="o">});</span>

   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"count 执行"</span><span class="o">);</span>
   <span class="n">stream</span><span class="o">.</span><span class="na">count</span><span class="o">();</span>
<span class="o">}</span>
<span class="cm">/*-------执行结果--------*/</span>
<span class="n">count</span> <span class="n">执行</span>
<span class="nc">Predicate</span><span class="o">.</span><span class="na">test</span> <span class="n">执行</span>
<span class="nc">Predicate</span><span class="o">.</span><span class="na">test</span> <span class="n">执行</span>
<span class="nc">Predicate</span><span class="o">.</span><span class="na">test</span> <span class="n">执行</span>
<span class="nc">Predicate</span><span class="o">.</span><span class="na">test</span> <span class="n">执行</span>
</code></pre></div></div>

<p>按执行顺序应该是先打印 4 次「<code class="language-plaintext highlighter-rouge">Predicate.test</code> 执行」，再打印「<code class="language-plaintext highlighter-rouge">count</code> 执行」。实际结果恰恰相反。说明 filter 中的方法并没有立刻执行，而是等调用<code class="language-plaintext highlighter-rouge">count()</code>方法后才执行。</p>

<p>上面都是串行 <code class="language-plaintext highlighter-rouge">Stream</code> 的实例。并行 <code class="language-plaintext highlighter-rouge">parallelStream</code> 在使用方法上和串行一样。主要区别是 <code class="language-plaintext highlighter-rouge">parallelStream</code> 可多线程执行，是基于 ForkJoin 框架实现的，有时间大家可以了解一下 <code class="language-plaintext highlighter-rouge">ForkJoin</code> 框架和 <code class="language-plaintext highlighter-rouge">ForkJoinPool</code>。这里可以简单的理解它是通过线程池来实现的，这样就会涉及到线程安全，线程消耗等问题。下面我们通过代码来体验一下并行流的多线程执行。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">parallelStreamTest</span><span class="o">(){</span>
   <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">);</span>
   <span class="n">numbers</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">()</span> <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">num</span><span class="o">-&gt;</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">"&gt;&gt;"</span><span class="o">+</span><span class="n">num</span><span class="o">));</span>
<span class="o">}</span>
<span class="c1">//执行结果</span>
<span class="n">main</span><span class="o">&gt;&gt;</span><span class="mi">5</span>
<span class="nc">ForkJoinPool</span><span class="o">.</span><span class="na">commonPool</span><span class="o">-</span><span class="n">worker</span><span class="o">-</span><span class="mi">2</span><span class="o">&gt;&gt;</span><span class="mi">4</span>
<span class="nc">ForkJoinPool</span><span class="o">.</span><span class="na">commonPool</span><span class="o">-</span><span class="n">worker</span><span class="o">-</span><span class="mi">11</span><span class="o">&gt;&gt;</span><span class="mi">1</span>
<span class="nc">ForkJoinPool</span><span class="o">.</span><span class="na">commonPool</span><span class="o">-</span><span class="n">worker</span><span class="o">-</span><span class="mi">9</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
</code></pre></div></div>

<p>从结果中我们看到，for-each 用到的是多线程。</p>

<h3 id="小结">小结</h3>

<p>从源码和实例中我们可以总结出一些 stream 的特点</p>

<ol>
  <li>通过简单的链式编程，使得它可以方便地对遍历处理后的数据进行再处理。</li>
  <li>方法参数都是函数式接口类型</li>
  <li>一个 Stream 只能操作一次，操作完就关闭了，继续使用这个 stream 会报错。</li>
  <li>Stream 不保存数据，不改变数据源</li>
</ol>

<h2 id="optional">Optional</h2>

<p>在<a href="https://share.weiyun.com/ThuqEbD5">阿里巴巴开发手册关于 Optional 的介绍</a>中这样写到：</p>

<blockquote>
  <p>防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：</p>

  <p>1） 返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。</p>

  <p>反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。</p>

  <p>2） 数据库的查询结果可能为 null。</p>

  <p>3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。</p>

  <p>4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。</p>

  <p>5） 对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。</p>

  <p>6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。</p>

  <p>正例：使用 JDK8 的 Optional 类来防止 NPE 问题。</p>
</blockquote>

<p>他建议使用 <code class="language-plaintext highlighter-rouge">Optional</code> 解决 NPE（<code class="language-plaintext highlighter-rouge">java.lang.NullPointerException</code>）问题，它就是为 NPE 而生的，其中可以包含空值或非空值。下面我们通过源码逐步揭开 <code class="language-plaintext highlighter-rouge">Optional</code> 的红盖头。</p>

<p>假设有一个 <code class="language-plaintext highlighter-rouge">Zoo</code> 类，里面有个属性 <code class="language-plaintext highlighter-rouge">Dog</code>，需求要获取 <code class="language-plaintext highlighter-rouge">Dog</code> 的 <code class="language-plaintext highlighter-rouge">age</code>。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Zoo</span> <span class="o">{</span>
   <span class="kd">private</span> <span class="nc">Dog</span> <span class="n">dog</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="o">{</span>
   <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>传统解决 NPE 的办法如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Zoo</span> <span class="n">zoo</span> <span class="o">=</span> <span class="n">getZoo</span><span class="o">();</span>
<span class="k">if</span><span class="o">(</span><span class="n">zoo</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
   <span class="nc">Dog</span> <span class="n">dog</span> <span class="o">=</span> <span class="n">zoo</span><span class="o">.</span><span class="na">getDog</span><span class="o">();</span>
   <span class="k">if</span><span class="o">(</span><span class="n">dog</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
      <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="n">dog</span><span class="o">.</span><span class="na">getAge</span><span class="o">();</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">age</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>层层判断对象非空，有人说这种方式很丑陋不优雅，我并不这么认为。反而觉得很整洁，易读，易懂。你们觉得呢？</p>

<p><code class="language-plaintext highlighter-rouge">Optional</code> 是这样的实现的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Optional</span><span class="o">.</span><span class="na">ofNullable</span><span class="o">(</span><span class="n">zoo</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="n">o</span> <span class="o">-&gt;</span> <span class="n">o</span><span class="o">.</span><span class="na">getDog</span><span class="o">()).</span><span class="na">map</span><span class="o">(</span><span class="n">d</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="o">.</span><span class="na">getAge</span><span class="o">()).</span><span class="na">ifPresent</span><span class="o">(</span><span class="n">age</span> <span class="o">-&gt;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">age</span><span class="o">)</span>
<span class="o">);</span>
</code></pre></div></div>

<p>是不是简洁了很多呢？</p>

<h3 id="如何创建一个-optional">如何创建一个 Optional</h3>

<p>上例中<code class="language-plaintext highlighter-rouge">Optional.ofNullable</code>是其中一种创建 Optional 的方式。我们先看一下它的含义和其他创建 Optional 的源码方法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
* Common instance for {@code empty()}. 全局EMPTY对象
*/</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Optional</span><span class="o">&lt;?&gt;</span> <span class="no">EMPTY</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Optional</span><span class="o">&lt;&gt;();</span>

<span class="cm">/**
* Optional维护的值
*/</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>

<span class="cm">/**
* 如果value是null就返回EMPTY，否则就返回of(T)
*/</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Optional</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">ofNullable</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">return</span> <span class="n">value</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">empty</span><span class="o">()</span> <span class="o">:</span> <span class="n">of</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
<span class="cm">/**
* 返回 EMPTY 对象
*/</span>
<span class="kd">public</span> <span class="kd">static</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Optional</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">empty</span><span class="o">()</span> <span class="o">{</span>
   <span class="nc">Optional</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Optional</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;)</span> <span class="no">EMPTY</span><span class="o">;</span>
   <span class="k">return</span> <span class="n">t</span><span class="o">;</span>
<span class="o">}</span>
<span class="cm">/**
* 返回Optional对象
*/</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Optional</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">of</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">Optional</span><span class="o">&lt;&gt;(</span><span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
<span class="cm">/**
* 私有构造方法，给value赋值
*/</span>
<span class="kd">private</span> <span class="nf">Optional</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
<span class="cm">/**
* 所以如果of(T value) 的value是null，会抛出NullPointerException异常，这样貌似就没处理NPE问题
*/</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">requireNonNull</span><span class="o">(</span><span class="no">T</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
         <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
  <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ofNullable</code> 方法和<code class="language-plaintext highlighter-rouge">of</code>方法唯一区别就是当 value 为 null 时，<code class="language-plaintext highlighter-rouge">ofNullable</code> 返回的是<code class="language-plaintext highlighter-rouge">EMPTY</code>，of 会抛出 <code class="language-plaintext highlighter-rouge">NullPointerException</code> 异常。如果需要把 <code class="language-plaintext highlighter-rouge">NullPointerException</code> 暴漏出来就用 <code class="language-plaintext highlighter-rouge">of</code>，否则就用 <code class="language-plaintext highlighter-rouge">ofNullable</code>。</p>

<p><strong><code class="language-plaintext highlighter-rouge">map()</code> 和 <code class="language-plaintext highlighter-rouge">flatMap()</code> 有什么区别的？</strong></p>

<p><code class="language-plaintext highlighter-rouge">map</code> 和 <code class="language-plaintext highlighter-rouge">flatMap</code> 都是将一个函数应用于集合中的每个元素，但不同的是<code class="language-plaintext highlighter-rouge">map</code>返回一个新的集合，<code class="language-plaintext highlighter-rouge">flatMap</code>是将每个元素都映射为一个集合，最后再将这个集合展平。</p>

<p>在实际应用场景中，如果<code class="language-plaintext highlighter-rouge">map</code>返回的是数组，那么最后得到的是一个二维数组，使用<code class="language-plaintext highlighter-rouge">flatMap</code>就是为了将这个二维数组展平变成一个一维数组。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MapAndFlatMapExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">[]&gt;</span> <span class="n">listOfArrays</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
                <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="s">"apple"</span><span class="o">,</span> <span class="s">"banana"</span><span class="o">,</span> <span class="s">"cherry"</span><span class="o">},</span>
                <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="s">"orange"</span><span class="o">,</span> <span class="s">"grape"</span><span class="o">,</span> <span class="s">"pear"</span><span class="o">},</span>
                <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="s">"kiwi"</span><span class="o">,</span> <span class="s">"melon"</span><span class="o">,</span> <span class="s">"pineapple"</span><span class="o">}</span>
        <span class="o">);</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">[]&gt;</span> <span class="n">mapResult</span> <span class="o">=</span> <span class="n">listOfArrays</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">array</span> <span class="o">-&gt;</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">array</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">toUpperCase</span><span class="o">).</span><span class="na">toArray</span><span class="o">(</span><span class="nc">String</span><span class="o">[]::</span><span class="k">new</span><span class="o">))</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Using map:"</span><span class="o">);</span>
        <span class="n">mapResult</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">arrays</span><span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arrays</span><span class="o">)));</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">flatMapResult</span> <span class="o">=</span> <span class="n">listOfArrays</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="n">array</span> <span class="o">-&gt;</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">array</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">toUpperCase</span><span class="o">))</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Using flatMap:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">flatMapResult</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>运行结果:</p>

<pre><code class="language-plain">Using map:
[[APPLE, BANANA, CHERRY], [ORANGE, GRAPE, PEAR], [KIWI, MELON, PINEAPPLE]]

Using flatMap:
[APPLE, BANANA, CHERRY, ORANGE, GRAPE, PEAR, KIWI, MELON, PINEAPPLE]
</code></pre>

<p>最简单的理解就是<code class="language-plaintext highlighter-rouge">flatMap()</code>可以将<code class="language-plaintext highlighter-rouge">map()</code>的结果展开。</p>

<p>在<code class="language-plaintext highlighter-rouge">Optional</code>里面，当使用<code class="language-plaintext highlighter-rouge">map()</code>时，如果映射函数返回的是一个普通值，它会将这个值包装在一个新的<code class="language-plaintext highlighter-rouge">Optional</code>中。而使用<code class="language-plaintext highlighter-rouge">flatMap</code>时，如果映射函数返回的是一个<code class="language-plaintext highlighter-rouge">Optional</code>，它会将这个返回的<code class="language-plaintext highlighter-rouge">Optional</code>展平，不再包装成嵌套的<code class="language-plaintext highlighter-rouge">Optional</code>。</p>

<p>下面是一个对比的示例代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">userId</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// 使用flatMap的代码</span>
        <span class="nc">String</span> <span class="n">cityUsingFlatMap</span> <span class="o">=</span> <span class="n">getUserById</span><span class="o">(</span><span class="n">userId</span><span class="o">)</span>
                <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="nl">OptionalExample:</span><span class="o">:</span><span class="n">getAddressByUser</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Address:</span><span class="o">:</span><span class="n">getCity</span><span class="o">)</span>
                <span class="o">.</span><span class="na">orElse</span><span class="o">(</span><span class="s">"Unknown"</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"User's city using flatMap: "</span> <span class="o">+</span> <span class="n">cityUsingFlatMap</span><span class="o">);</span>

        <span class="c1">// 不使用flatMap的代码</span>
        <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Address</span><span class="o">&gt;&gt;</span> <span class="n">optionalAddress</span> <span class="o">=</span> <span class="n">getUserById</span><span class="o">(</span><span class="n">userId</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">OptionalExample:</span><span class="o">:</span><span class="n">getAddressByUser</span><span class="o">);</span>

        <span class="nc">String</span> <span class="n">cityWithoutFlatMap</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">optionalAddress</span><span class="o">.</span><span class="na">isPresent</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Address</span><span class="o">&gt;</span> <span class="n">addressOptional</span> <span class="o">=</span> <span class="n">optionalAddress</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">addressOptional</span><span class="o">.</span><span class="na">isPresent</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">Address</span> <span class="n">address</span> <span class="o">=</span> <span class="n">addressOptional</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
                <span class="n">cityWithoutFlatMap</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="na">getCity</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">cityWithoutFlatMap</span> <span class="o">=</span> <span class="s">"Unknown"</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">cityWithoutFlatMap</span> <span class="o">=</span> <span class="s">"Unknown"</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"User's city without flatMap: "</span> <span class="o">+</span> <span class="n">cityWithoutFlatMap</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>在<code class="language-plaintext highlighter-rouge">Stream</code>和<code class="language-plaintext highlighter-rouge">Optional</code>中正确使用<code class="language-plaintext highlighter-rouge">flatMap</code>可以减少很多不必要的代码。</p>

<h3 id="判断-value-是否为-null">判断 value 是否为 null</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
* value是否为null
*/</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPresent</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">value</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
<span class="cm">/**
* 如果value不为null执行consumer.accept
*/</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">ifPresent</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">consumer</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
    <span class="n">consumer</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="获取-value">获取 value</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
* Return the value if present, otherwise invoke {@code other} and return
* the result of that invocation.
* 如果value != null 返回value，否则返回other的执行结果
*/</span>
<span class="kd">public</span> <span class="no">T</span> <span class="nf">orElseGet</span><span class="o">(</span><span class="nc">Supplier</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">other</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">value</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">value</span> <span class="o">:</span> <span class="n">other</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
<span class="o">}</span>

<span class="cm">/**
* 如果value != null 返回value，否则返回T
*/</span>
<span class="kd">public</span> <span class="no">T</span> <span class="nf">orElse</span><span class="o">(</span><span class="no">T</span> <span class="n">other</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">value</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">value</span> <span class="o">:</span> <span class="n">other</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/**
* 如果value != null 返回value，否则抛出参数返回的异常
*/</span>
<span class="kd">public</span> <span class="o">&lt;</span><span class="no">X</span> <span class="kd">extends</span> <span class="nc">Throwable</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">orElseThrow</span><span class="o">(</span><span class="nc">Supplier</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">X</span><span class="o">&gt;</span> <span class="n">exceptionSupplier</span><span class="o">)</span> <span class="kd">throws</span> <span class="no">X</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="n">exceptionSupplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/**
* value为null抛出NoSuchElementException，不为空返回value。
*/</span>
<span class="kd">public</span> <span class="no">T</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchElementException</span><span class="o">(</span><span class="s">"No value present"</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="过滤值">过滤值</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
* 1. 如果是empty返回empty
* 2. predicate.test(value)==true 返回this，否则返回empty
*/</span>
<span class="kd">public</span> <span class="nc">Optional</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="nc">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">predicate</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">isPresent</span><span class="o">())</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="n">predicate</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="o">?</span> <span class="k">this</span> <span class="o">:</span> <span class="n">empty</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="小结-1">小结</h3>

<p>看完 <code class="language-plaintext highlighter-rouge">Optional</code> 源码，<code class="language-plaintext highlighter-rouge">Optional</code> 的方法真的非常简单，值得注意的是如果坚决不想看见 <code class="language-plaintext highlighter-rouge">NPE</code>，就不要用 <code class="language-plaintext highlighter-rouge">of()</code>、 <code class="language-plaintext highlighter-rouge">get()</code>、<code class="language-plaintext highlighter-rouge">flatMap(..)</code>。最后再综合用一下 <code class="language-plaintext highlighter-rouge">Optional</code> 的高频方法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Optional</span><span class="o">.</span><span class="na">ofNullable</span><span class="o">(</span><span class="n">zoo</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="n">o</span> <span class="o">-&gt;</span> <span class="n">o</span><span class="o">.</span><span class="na">getDog</span><span class="o">()).</span><span class="na">map</span><span class="o">(</span><span class="n">d</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="o">.</span><span class="na">getAge</span><span class="o">()).</span><span class="na">filter</span><span class="o">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">v</span><span class="o">==</span><span class="mi">1</span><span class="o">).</span><span class="na">orElse</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
</code></pre></div></div>

<h2 id="date-time-api">Date-Time API</h2>

<p>这是对<code class="language-plaintext highlighter-rouge">java.util.Date</code>强有力的补充，解决了 Date 类的大部分痛点：</p>

<ol>
  <li>非线程安全</li>
  <li>时区处理麻烦</li>
  <li>各种格式化、和时间计算繁琐</li>
  <li>设计有缺陷，Date 类同时包含日期和时间；还有一个 java.sql.Date，容易混淆。</li>
</ol>

<p>我们从常用的时间实例来对比 java.util.Date 和新 Date 有什么区别。用<code class="language-plaintext highlighter-rouge">java.util.Date</code>的代码该改改了。</p>

<h3 id="javatime-主要类">java.time 主要类</h3>

<p><code class="language-plaintext highlighter-rouge">java.util.Date</code> 既包含日期又包含时间，而 <code class="language-plaintext highlighter-rouge">java.time</code> 把它们进行了分离</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">class</span> <span class="c1">//日期+时间 format: yyyy-MM-ddTHH:mm:ss.SSS</span>
<span class="nc">LocalDate</span><span class="o">.</span><span class="na">class</span> <span class="c1">//日期 format: yyyy-MM-dd</span>
<span class="nc">LocalTime</span><span class="o">.</span><span class="na">class</span> <span class="c1">//时间 format: HH:mm:ss</span>
</code></pre></div></div>

<h3 id="格式化">格式化</h3>

<p><strong>Java 8 之前:</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">oldFormat</span><span class="o">(){</span>
    <span class="nc">Date</span> <span class="n">now</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="o">();</span>
    <span class="c1">//format yyyy-MM-dd</span>
    <span class="nc">SimpleDateFormat</span> <span class="n">sdf</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SimpleDateFormat</span><span class="o">(</span><span class="s">"yyyy-MM-dd"</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">date</span>  <span class="o">=</span> <span class="n">sdf</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">now</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"date format : %s"</span><span class="o">,</span> <span class="n">date</span><span class="o">));</span>

    <span class="c1">//format HH:mm:ss</span>
    <span class="nc">SimpleDateFormat</span> <span class="n">sdft</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SimpleDateFormat</span><span class="o">(</span><span class="s">"HH:mm:ss"</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">time</span> <span class="o">=</span> <span class="n">sdft</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">now</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"time format : %s"</span><span class="o">,</span> <span class="n">time</span><span class="o">));</span>

    <span class="c1">//format yyyy-MM-dd HH:mm:ss</span>
    <span class="nc">SimpleDateFormat</span> <span class="n">sdfdt</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SimpleDateFormat</span><span class="o">(</span><span class="s">"yyyy-MM-dd HH:mm:ss"</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">datetime</span> <span class="o">=</span> <span class="n">sdfdt</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">now</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"dateTime format : %s"</span><span class="o">,</span> <span class="n">datetime</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>Java 8 之后:</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">newFormat</span><span class="o">(){</span>
    <span class="c1">//format yyyy-MM-dd</span>
    <span class="nc">LocalDate</span> <span class="n">date</span> <span class="o">=</span> <span class="nc">LocalDate</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"date format : %s"</span><span class="o">,</span> <span class="n">date</span><span class="o">));</span>

    <span class="c1">//format HH:mm:ss</span>
    <span class="nc">LocalTime</span> <span class="n">time</span> <span class="o">=</span> <span class="nc">LocalTime</span><span class="o">.</span><span class="na">now</span><span class="o">().</span><span class="na">withNano</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"time format : %s"</span><span class="o">,</span> <span class="n">time</span><span class="o">));</span>

    <span class="c1">//format yyyy-MM-dd HH:mm:ss</span>
    <span class="nc">LocalDateTime</span> <span class="n">dateTime</span> <span class="o">=</span> <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
    <span class="nc">DateTimeFormatter</span> <span class="n">dateTimeFormatter</span> <span class="o">=</span> <span class="nc">DateTimeFormatter</span><span class="o">.</span><span class="na">ofPattern</span><span class="o">(</span><span class="s">"yyyy-MM-dd HH:mm:ss"</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">dateTimeStr</span> <span class="o">=</span> <span class="n">dateTime</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">dateTimeFormatter</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"dateTime format : %s"</span><span class="o">,</span> <span class="n">dateTimeStr</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="字符串转日期格式">字符串转日期格式</h3>

<p><strong>Java 8 之前:</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//已弃用</span>
<span class="nc">Date</span> <span class="n">date</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="o">(</span><span class="s">"2021-01-26"</span><span class="o">);</span>
<span class="c1">//替换为</span>
<span class="nc">SimpleDateFormat</span> <span class="n">sdf</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SimpleDateFormat</span><span class="o">(</span><span class="s">"yyyy-MM-dd"</span><span class="o">);</span>
<span class="nc">Date</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">sdf</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">"2021-01-26"</span><span class="o">);</span>
</code></pre></div></div>

<p><strong>Java 8 之后:</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">LocalDate</span> <span class="n">date</span> <span class="o">=</span> <span class="nc">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">2021</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">26</span><span class="o">);</span>
<span class="nc">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">"2021-01-26"</span><span class="o">);</span>

<span class="nc">LocalDateTime</span> <span class="n">dateTime</span> <span class="o">=</span> <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">2021</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">26</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">22</span><span class="o">);</span>
<span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">"2021-01-26 12:12:22"</span><span class="o">);</span>

<span class="nc">LocalTime</span> <span class="n">time</span> <span class="o">=</span> <span class="nc">LocalTime</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">12</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">22</span><span class="o">);</span>
<span class="nc">LocalTime</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">"12:12:22"</span><span class="o">);</span>
</code></pre></div></div>

<p><strong>Java 8 之前</strong> 转换都需要借助 <code class="language-plaintext highlighter-rouge">SimpleDateFormat</code> 类，而<strong>Java 8 之后</strong>只需要 <code class="language-plaintext highlighter-rouge">LocalDate</code>、<code class="language-plaintext highlighter-rouge">LocalTime</code>、<code class="language-plaintext highlighter-rouge">LocalDateTime</code>的 <code class="language-plaintext highlighter-rouge">of</code> 或 <code class="language-plaintext highlighter-rouge">parse</code> 方法。</p>

<h3 id="日期计算">日期计算</h3>

<p>下面仅以<strong>一周后日期</strong>为例，其他单位（年、月、日、1/2 日、时等等）大同小异。另外，这些单位都在 <em>java.time.temporal.ChronoUnit</em> 枚举中定义。</p>

<p><strong>Java 8 之前:</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterDay</span><span class="o">(){</span>
     <span class="c1">//一周后的日期</span>
     <span class="nc">SimpleDateFormat</span> <span class="n">formatDate</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SimpleDateFormat</span><span class="o">(</span><span class="s">"yyyy-MM-dd"</span><span class="o">);</span>
     <span class="nc">Calendar</span> <span class="n">ca</span> <span class="o">=</span> <span class="nc">Calendar</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
     <span class="n">ca</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Calendar</span><span class="o">.</span><span class="na">DATE</span><span class="o">,</span> <span class="mi">7</span><span class="o">);</span>
     <span class="nc">Date</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="na">getTime</span><span class="o">();</span>
     <span class="nc">String</span> <span class="n">after</span> <span class="o">=</span> <span class="n">formatDate</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"一周后日期："</span> <span class="o">+</span> <span class="n">after</span><span class="o">);</span>

   <span class="c1">//算两个日期间隔多少天，计算间隔多少年，多少月方法类似</span>
     <span class="nc">String</span> <span class="n">dates1</span> <span class="o">=</span> <span class="s">"2021-12-23"</span><span class="o">;</span>
   <span class="nc">String</span> <span class="n">dates2</span> <span class="o">=</span> <span class="s">"2021-02-26"</span><span class="o">;</span>
     <span class="nc">SimpleDateFormat</span> <span class="n">format</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SimpleDateFormat</span><span class="o">(</span><span class="s">"yyyy-MM-dd"</span><span class="o">);</span>
     <span class="nc">Date</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">format</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">dates1</span><span class="o">);</span>
     <span class="nc">Date</span> <span class="n">date2</span> <span class="o">=</span> <span class="n">format</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">dates2</span><span class="o">);</span>
     <span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="o">((</span><span class="n">date1</span><span class="o">.</span><span class="na">getTime</span><span class="o">()</span> <span class="o">-</span> <span class="n">date2</span><span class="o">.</span><span class="na">getTime</span><span class="o">())</span> <span class="o">/</span> <span class="o">(</span><span class="mi">1000</span> <span class="o">*</span> <span class="mi">3600</span> <span class="o">*</span> <span class="mi">24</span><span class="o">));</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dates1</span> <span class="o">+</span> <span class="s">"和"</span> <span class="o">+</span> <span class="n">dates2</span> <span class="o">+</span> <span class="s">"相差"</span> <span class="o">+</span> <span class="n">day</span> <span class="o">+</span> <span class="s">"天"</span><span class="o">);</span>
     <span class="c1">//结果：2021-02-26和2021-12-23相差300天</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>Java 8 之后:</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">pushWeek</span><span class="o">(){</span>
     <span class="c1">//一周后的日期</span>
     <span class="nc">LocalDate</span> <span class="n">localDate</span> <span class="o">=</span> <span class="nc">LocalDate</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
     <span class="c1">//方法1</span>
     <span class="nc">LocalDate</span> <span class="n">after</span> <span class="o">=</span> <span class="n">localDate</span><span class="o">.</span><span class="na">plus</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">ChronoUnit</span><span class="o">.</span><span class="na">WEEKS</span><span class="o">);</span>
     <span class="c1">//方法2</span>
     <span class="nc">LocalDate</span> <span class="n">after2</span> <span class="o">=</span> <span class="n">localDate</span><span class="o">.</span><span class="na">plusWeeks</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"一周后日期："</span> <span class="o">+</span> <span class="n">after</span><span class="o">);</span>

     <span class="c1">//算两个日期间隔多少天，计算间隔多少年，多少月</span>
     <span class="nc">LocalDate</span> <span class="n">date1</span> <span class="o">=</span> <span class="nc">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">"2021-02-26"</span><span class="o">);</span>
     <span class="nc">LocalDate</span> <span class="n">date2</span> <span class="o">=</span> <span class="nc">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">"2021-12-23"</span><span class="o">);</span>
     <span class="nc">Period</span> <span class="n">period</span> <span class="o">=</span> <span class="nc">Period</span><span class="o">.</span><span class="na">between</span><span class="o">(</span><span class="n">date1</span><span class="o">,</span> <span class="n">date2</span><span class="o">);</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"date1 到 date2 相隔："</span>
                <span class="o">+</span> <span class="n">period</span><span class="o">.</span><span class="na">getYears</span><span class="o">()</span> <span class="o">+</span> <span class="s">"年"</span>
                <span class="o">+</span> <span class="n">period</span><span class="o">.</span><span class="na">getMonths</span><span class="o">()</span> <span class="o">+</span> <span class="s">"月"</span>
                <span class="o">+</span> <span class="n">period</span><span class="o">.</span><span class="na">getDays</span><span class="o">()</span> <span class="o">+</span> <span class="s">"天"</span><span class="o">);</span>
   <span class="c1">//打印结果是 “date1 到 date2 相隔：0年9月27天”</span>
     <span class="c1">//这里period.getDays()得到的天是抛去年月以外的天数，并不是总天数</span>
     <span class="c1">//如果要获取纯粹的总天数应该用下面的方法</span>
     <span class="kt">long</span> <span class="n">day</span> <span class="o">=</span> <span class="n">date2</span><span class="o">.</span><span class="na">toEpochDay</span><span class="o">()</span> <span class="o">-</span> <span class="n">date1</span><span class="o">.</span><span class="na">toEpochDay</span><span class="o">();</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">date1</span> <span class="o">+</span> <span class="s">"和"</span> <span class="o">+</span> <span class="n">date2</span> <span class="o">+</span> <span class="s">"相差"</span> <span class="o">+</span> <span class="n">day</span> <span class="o">+</span> <span class="s">"天"</span><span class="o">);</span>
     <span class="c1">//打印结果：2021-02-26和2021-12-23相差300天</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="获取指定日期">获取指定日期</h3>

<p>除了日期计算繁琐，获取特定一个日期也很麻烦，比如获取本月最后一天，第一天。</p>

<p><strong>Java 8 之前:</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">getDay</span><span class="o">()</span> <span class="o">{</span>

        <span class="nc">SimpleDateFormat</span> <span class="n">format</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SimpleDateFormat</span><span class="o">(</span><span class="s">"yyyy-MM-dd"</span><span class="o">);</span>
        <span class="c1">//获取当前月第一天：</span>
        <span class="nc">Calendar</span> <span class="n">c</span> <span class="o">=</span> <span class="nc">Calendar</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
        <span class="n">c</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="nc">Calendar</span><span class="o">.</span><span class="na">DAY_OF_MONTH</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">first</span> <span class="o">=</span> <span class="n">format</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">getTime</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"first day:"</span> <span class="o">+</span> <span class="n">first</span><span class="o">);</span>

        <span class="c1">//获取当前月最后一天</span>
        <span class="nc">Calendar</span> <span class="n">ca</span> <span class="o">=</span> <span class="nc">Calendar</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
        <span class="n">ca</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="nc">Calendar</span><span class="o">.</span><span class="na">DAY_OF_MONTH</span><span class="o">,</span> <span class="n">ca</span><span class="o">.</span><span class="na">getActualMaximum</span><span class="o">(</span><span class="nc">Calendar</span><span class="o">.</span><span class="na">DAY_OF_MONTH</span><span class="o">));</span>
        <span class="nc">String</span> <span class="n">last</span> <span class="o">=</span> <span class="n">format</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">ca</span><span class="o">.</span><span class="na">getTime</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"last day:"</span> <span class="o">+</span> <span class="n">last</span><span class="o">);</span>

        <span class="c1">//当年最后一天</span>
        <span class="nc">Calendar</span> <span class="n">currCal</span> <span class="o">=</span> <span class="nc">Calendar</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
        <span class="nc">Calendar</span> <span class="n">calendar</span> <span class="o">=</span> <span class="nc">Calendar</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
        <span class="n">calendar</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
        <span class="n">calendar</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="nc">Calendar</span><span class="o">.</span><span class="na">YEAR</span><span class="o">,</span> <span class="n">currCal</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="nc">Calendar</span><span class="o">.</span><span class="na">YEAR</span><span class="o">));</span>
        <span class="n">calendar</span><span class="o">.</span><span class="na">roll</span><span class="o">(</span><span class="nc">Calendar</span><span class="o">.</span><span class="na">DAY_OF_YEAR</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">Date</span> <span class="n">time</span> <span class="o">=</span> <span class="n">calendar</span><span class="o">.</span><span class="na">getTime</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"last day:"</span> <span class="o">+</span> <span class="n">format</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">time</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>Java 8 之后:</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">getDayNew</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">LocalDate</span> <span class="n">today</span> <span class="o">=</span> <span class="nc">LocalDate</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
    <span class="c1">//获取当前月第一天：</span>
    <span class="nc">LocalDate</span> <span class="n">firstDayOfThisMonth</span> <span class="o">=</span> <span class="n">today</span><span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="nc">TemporalAdjusters</span><span class="o">.</span><span class="na">firstDayOfMonth</span><span class="o">());</span>
    <span class="c1">// 取本月最后一天</span>
    <span class="nc">LocalDate</span> <span class="n">lastDayOfThisMonth</span> <span class="o">=</span> <span class="n">today</span><span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="nc">TemporalAdjusters</span><span class="o">.</span><span class="na">lastDayOfMonth</span><span class="o">());</span>
    <span class="c1">//取下一天：</span>
    <span class="nc">LocalDate</span> <span class="n">nextDay</span> <span class="o">=</span> <span class="n">lastDayOfThisMonth</span><span class="o">.</span><span class="na">plusDays</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="c1">//当年最后一天</span>
    <span class="nc">LocalDate</span> <span class="n">lastday</span> <span class="o">=</span> <span class="n">today</span><span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="nc">TemporalAdjusters</span><span class="o">.</span><span class="na">lastDayOfYear</span><span class="o">());</span>
    <span class="c1">//2021年最后一个周日，如果用Calendar是不得烦死。</span>
    <span class="nc">LocalDate</span> <span class="n">lastMondayOf2021</span> <span class="o">=</span> <span class="nc">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">"2021-12-31"</span><span class="o">).</span><span class="na">with</span><span class="o">(</span><span class="nc">TemporalAdjusters</span><span class="o">.</span><span class="na">lastInMonth</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">SUNDAY</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">java.time.temporal.TemporalAdjusters</code> 里面还有很多便捷的算法，这里就不带大家看 Api 了，都很简单，看了秒懂。</p>

<h3 id="jdbc-和-java8">JDBC 和 java8</h3>

<p>现在 jdbc 时间类型和 java8 时间类型对应关系是</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Date</code> —&gt; <code class="language-plaintext highlighter-rouge">LocalDate</code></li>
  <li><code class="language-plaintext highlighter-rouge">Time</code> —&gt; <code class="language-plaintext highlighter-rouge">LocalTime</code></li>
  <li><code class="language-plaintext highlighter-rouge">Timestamp</code> —&gt; <code class="language-plaintext highlighter-rouge">LocalDateTime</code></li>
</ol>

<p>而之前统统对应 <code class="language-plaintext highlighter-rouge">Date</code>，也只有 <code class="language-plaintext highlighter-rouge">Date</code>。</p>

<h3 id="时区">时区</h3>

<blockquote>
  <p>时区：正式的时区划分为每隔经度 15° 划分一个时区，全球共 24 个时区，每个时区相差 1 小时。但为了行政上的方便，常将 1 个国家或 1 个省份划在一起，比如我国幅员宽广，大概横跨 5 个时区，实际上只用东八时区的标准时即北京时间为准。</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">java.util.Date</code> 对象实质上存的是 1970 年 1 月 1 日 0 点（ GMT）至 Date 对象所表示时刻所经过的毫秒数。也就是说不管在哪个时区 new Date，它记录的毫秒数都一样，和时区无关。但在使用上应该把它转换成当地时间，这就涉及到了时间的国际化。<code class="language-plaintext highlighter-rouge">java.util.Date</code> 本身并不支持国际化，需要借助 <code class="language-plaintext highlighter-rouge">TimeZone</code>。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//北京时间：Wed Jan 27 14:05:29 CST 2021</span>
<span class="nc">Date</span> <span class="n">date</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="o">();</span>

<span class="nc">SimpleDateFormat</span> <span class="n">bjSdf</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SimpleDateFormat</span><span class="o">(</span><span class="s">"yyyy-MM-dd HH:mm:ss"</span><span class="o">);</span>
<span class="c1">//北京时区</span>
<span class="n">bjSdf</span><span class="o">.</span><span class="na">setTimeZone</span><span class="o">(</span><span class="nc">TimeZone</span><span class="o">.</span><span class="na">getTimeZone</span><span class="o">(</span><span class="s">"Asia/Shanghai"</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"毫秒数:"</span> <span class="o">+</span> <span class="n">date</span><span class="o">.</span><span class="na">getTime</span><span class="o">()</span> <span class="o">+</span> <span class="s">", 北京时间:"</span> <span class="o">+</span> <span class="n">bjSdf</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">date</span><span class="o">));</span>

<span class="c1">//东京时区</span>
<span class="nc">SimpleDateFormat</span> <span class="n">tokyoSdf</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SimpleDateFormat</span><span class="o">(</span><span class="s">"yyyy-MM-dd HH:mm:ss"</span><span class="o">);</span>
<span class="n">tokyoSdf</span><span class="o">.</span><span class="na">setTimeZone</span><span class="o">(</span><span class="nc">TimeZone</span><span class="o">.</span><span class="na">getTimeZone</span><span class="o">(</span><span class="s">"Asia/Tokyo"</span><span class="o">));</span>  <span class="c1">// 设置东京时区</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"毫秒数:"</span> <span class="o">+</span> <span class="n">date</span><span class="o">.</span><span class="na">getTime</span><span class="o">()</span> <span class="o">+</span> <span class="s">", 东京时间:"</span> <span class="o">+</span> <span class="n">tokyoSdf</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">date</span><span class="o">));</span>

<span class="c1">//如果直接print会自动转成当前时区的时间</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">date</span><span class="o">);</span>
<span class="c1">//Wed Jan 27 14:05:29 CST 2021</span>
</code></pre></div></div>

<p>在新特性中引入了 <code class="language-plaintext highlighter-rouge">java.time.ZonedDateTime</code> 来表示带时区的时间。它可以看成是 <code class="language-plaintext highlighter-rouge">LocalDateTime + ZoneId</code>。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//当前时区时间</span>
<span class="nc">ZonedDateTime</span> <span class="n">zonedDateTime</span> <span class="o">=</span> <span class="nc">ZonedDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"当前时区时间: "</span> <span class="o">+</span> <span class="n">zonedDateTime</span><span class="o">);</span>

<span class="c1">//东京时间</span>
<span class="nc">ZoneId</span> <span class="n">zoneId</span> <span class="o">=</span> <span class="nc">ZoneId</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="nc">ZoneId</span><span class="o">.</span><span class="na">SHORT_IDS</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"JST"</span><span class="o">));</span>
<span class="nc">ZonedDateTime</span> <span class="n">tokyoTime</span> <span class="o">=</span> <span class="n">zonedDateTime</span><span class="o">.</span><span class="na">withZoneSameInstant</span><span class="o">(</span><span class="n">zoneId</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"东京时间: "</span> <span class="o">+</span> <span class="n">tokyoTime</span><span class="o">);</span>

<span class="c1">// ZonedDateTime 转 LocalDateTime</span>
<span class="nc">LocalDateTime</span> <span class="n">localDateTime</span> <span class="o">=</span> <span class="n">tokyoTime</span><span class="o">.</span><span class="na">toLocalDateTime</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"东京时间转当地时间: "</span> <span class="o">+</span> <span class="n">localDateTime</span><span class="o">);</span>

<span class="c1">//LocalDateTime 转 ZonedDateTime</span>
<span class="nc">ZonedDateTime</span> <span class="n">localZoned</span> <span class="o">=</span> <span class="n">localDateTime</span><span class="o">.</span><span class="na">atZone</span><span class="o">(</span><span class="nc">ZoneId</span><span class="o">.</span><span class="na">systemDefault</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"本地时区时间: "</span> <span class="o">+</span> <span class="n">localZoned</span><span class="o">);</span>

<span class="c1">//打印结果</span>
<span class="nl">当前时区时间:</span> <span class="mi">2021</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mi">27</span><span class="nl">T14:</span><span class="mi">43</span><span class="o">:</span><span class="mf">58.735</span><span class="o">+</span><span class="mi">08</span><span class="o">:</span><span class="mo">00</span><span class="o">[</span><span class="nc">Asia</span><span class="o">/</span><span class="nc">Shanghai</span><span class="o">]</span>
<span class="nl">东京时间:</span> <span class="mi">2021</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mi">27</span><span class="nl">T15:</span><span class="mi">43</span><span class="o">:</span><span class="mf">58.735</span><span class="o">+</span><span class="mi">09</span><span class="o">:</span><span class="mo">00</span><span class="o">[</span><span class="nc">Asia</span><span class="o">/</span><span class="nc">Tokyo</span><span class="o">]</span>
<span class="nl">东京时间转当地时间:</span> <span class="mi">2021</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mi">27</span><span class="nl">T15:</span><span class="mi">43</span><span class="o">:</span><span class="mf">58.735</span>
<span class="nl">当地时区时间:</span> <span class="mi">2021</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mi">27</span><span class="nl">T15:</span><span class="mi">53</span><span class="o">:</span><span class="mf">35.618</span><span class="o">+</span><span class="mi">08</span><span class="o">:</span><span class="mo">00</span><span class="o">[</span><span class="nc">Asia</span><span class="o">/</span><span class="nc">Shanghai</span><span class="o">]</span>
</code></pre></div></div>

<h3 id="小结-2">小结</h3>

<p>通过上面比较新老 <code class="language-plaintext highlighter-rouge">Date</code> 的不同，当然只列出部分功能上的区别，更多功能还得自己去挖掘。总之 date-time-api 给日期操作带来了福利。在日常工作中遇到 date 类型的操作，第一考虑的是 date-time-api，实在解决不了再考虑老的 Date。</p>

<h2 id="总结">总结</h2>

<p>我们梳理总结的 java 8 新特性有</p>

<ul>
  <li>Interface &amp; functional Interface</li>
  <li>Lambda</li>
  <li>Stream</li>
  <li>Optional</li>
  <li>Date time-api</li>
</ul>

<p>这些都是开发当中比较常用的特性。梳理下来发现它们真香，而我却没有更早的应用。总觉得学习 java 8 新特性比较麻烦，一直使用老的实现方式。其实这些新特性几天就可以掌握，一但掌握，效率会有很大的提高。其实我们涨工资也是涨的学习的钱，不学习终究会被淘汰，35 岁危机会提前来临。</p>

<!-- @include: @article-footer.snippet.md -->
