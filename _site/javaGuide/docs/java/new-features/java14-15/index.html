<h2 id="java14">Java14</h2>

<h3 id="空指针异常精准提示">空指针异常精准提示</h3>

<p>通过 JVM 参数中添加<code class="language-plaintext highlighter-rouge">-XX:+ShowCodeDetailsInExceptionMessages</code>，可以在空指针异常中获取更为详细的调用信息，更快的定位和解决问题。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="o">.</span><span class="na">b</span><span class="o">.</span><span class="na">c</span><span class="o">.</span><span class="na">i</span> <span class="o">=</span> <span class="mi">99</span><span class="o">;</span> <span class="c1">// 假设这段代码会发生空指针</span>
</code></pre></div></div>

<p>Java 14 之前：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">"main"</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">NullPointerException</span>
    <span class="n">at</span> <span class="nc">NullPointerExample</span><span class="o">.</span><span class="na">main</span><span class="o">(</span><span class="nc">NullPointerExample</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">5</span><span class="o">)</span>
</code></pre></div></div>

<p>Java 14 之后：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// 增加参数后提示的异常中很明确的告知了哪里为空导致</span>
<span class="nc">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">"main"</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">NullPointerException</span><span class="o">:</span>
        <span class="nc">Cannot</span> <span class="n">read</span> <span class="n">field</span> <span class="sc">'c'</span> <span class="n">because</span> <span class="err">'</span><span class="n">a</span><span class="o">.</span><span class="na">b</span><span class="err">'</span> <span class="n">is</span> <span class="kc">null</span><span class="o">.</span>
    <span class="n">at</span> <span class="nc">Prog</span><span class="o">.</span><span class="na">main</span><span class="o">(</span><span class="nc">Prog</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">5</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="switch-的增强转正">switch 的增强(转正)</h3>

<p>Java12 引入的 switch（预览特性）在 Java14 变为正式版本，不需要增加参数来启用，直接在 JDK14 中就能使用。</p>

<p>Java12 为 switch 表达式引入了类似 lambda 语法条件匹配成功后的执行块，不需要多写 break ，Java13 提供了 <code class="language-plaintext highlighter-rouge">yield</code> 来在 block 中返回值。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="k">switch</span> <span class="o">(</span><span class="n">day</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">case</span> <span class="s">"M"</span><span class="o">,</span> <span class="s">"W"</span><span class="o">,</span> <span class="s">"F"</span> <span class="o">-&gt;</span> <span class="s">"MWF"</span><span class="o">;</span>
            <span class="k">case</span> <span class="s">"T"</span><span class="o">,</span> <span class="s">"TH"</span><span class="o">,</span> <span class="s">"S"</span> <span class="o">-&gt;</span> <span class="s">"TTS"</span><span class="o">;</span>
            <span class="k">default</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">day</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
                    <span class="n">yield</span> <span class="s">"Please insert a valid day."</span><span class="o">;</span>
                <span class="k">else</span>
                    <span class="n">yield</span> <span class="s">"Looks like a Sunday."</span><span class="o">;</span>
            <span class="o">}</span>

        <span class="o">};</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="预览新特性">预览新特性</h3>

<h4 id="record-关键字">record 关键字</h4>

<p><code class="language-plaintext highlighter-rouge">record</code> 关键字可以简化 <strong>数据类</strong>（一个 Java 类一旦实例化就不能再修改）的定义方式，使用 <code class="language-plaintext highlighter-rouge">record</code> 代替 <code class="language-plaintext highlighter-rouge">class</code> 定义的类，只需要声明属性，就可以在获得属性的访问方法，以及 <code class="language-plaintext highlighter-rouge">toString()</code>，<code class="language-plaintext highlighter-rouge">hashCode()</code>, <code class="language-plaintext highlighter-rouge">equals()</code>方法。</p>

<p>类似于使用 <code class="language-plaintext highlighter-rouge">class</code> 定义类，同时使用了 lombok 插件，并打上了<code class="language-plaintext highlighter-rouge">@Getter,@ToString,@EqualsAndHashCode</code>注解。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 这个类具有两个特征
 * 1. 所有成员属性都是final
 * 2. 全部方法由构造方法，和两个成员属性访问器组成（共三个）
 * 那么这种类就很适合使用record来声明
 */</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="nc">Rectangle</span> <span class="kd">implements</span> <span class="nc">Shape</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="kt">double</span> <span class="n">length</span><span class="o">;</span>
    <span class="kd">final</span> <span class="kt">double</span> <span class="n">width</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Rectangle</span><span class="o">(</span><span class="kt">double</span> <span class="n">length</span><span class="o">,</span> <span class="kt">double</span> <span class="n">width</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">length</span> <span class="o">=</span> <span class="n">length</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">width</span> <span class="o">=</span> <span class="n">width</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">double</span> <span class="nf">length</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">length</span><span class="o">;</span> <span class="o">}</span>
    <span class="kt">double</span> <span class="nf">width</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">width</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/**
 * 1. 使用record声明的类会自动拥有上面类中的三个方法
 * 2. 在这基础上还附赠了equals()，hashCode()方法以及toString()方法
 * 3. toString方法中包括所有成员属性的字符串表示形式及其名称
 */</span>
<span class="n">record</span> <span class="nf">Rectangle</span><span class="o">(</span><span class="kt">float</span> <span class="n">length</span><span class="o">,</span> <span class="kt">float</span> <span class="n">width</span><span class="o">)</span> <span class="o">{</span> <span class="o">}</span>
</code></pre></div></div>

<h4 id="文本块">文本块</h4>

<p>Java14 中，文本块依然是预览特性，不过，其引入了两个新的转义字符：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">\</code> : 表示行尾，不引入换行符</li>
  <li><code class="language-plaintext highlighter-rouge">\s</code>：表示单个空格</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"凡心所向，素履所往，生如逆旅，一苇以航。"</span><span class="o">;</span>

<span class="nc">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="sh">"""
        凡心所向，素履所往， \
        生如逆旅，一苇以航。"""</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str2</span><span class="o">);</span><span class="c1">// 凡心所向，素履所往， 生如逆旅，一苇以航。</span>
<span class="nc">String</span> <span class="n">text</span> <span class="o">=</span> <span class="sh">"""
        java
        c++\sphp
        """</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>
<span class="c1">//输出：</span>
<span class="n">java</span>
<span class="n">c</span><span class="o">++</span> <span class="n">php</span>
</code></pre></div></div>

<h4 id="instanceof-增强">instanceof 增强</h4>

<p>依然是<strong>预览特性</strong> ，<a href="./java12-13.md">Java 12 新特性</a>中介绍过。</p>

<h3 id="其他">其他</h3>

<ul>
  <li>从 Java11 引入的 ZGC 作为继 G1 过后的下一代 GC 算法，从支持 Linux 平台到 Java14 开始支持 MacOS 和 Windows（个人感觉是终于可以在日常开发工具中先体验下 ZGC 的效果了，虽然其实 G1 也够用）</li>
  <li>移除了 CMS(Concurrent Mark Sweep) 垃圾收集器（功成而退）</li>
  <li>新增了 jpackage 工具，标配将应用打成 jar 包外，还支持不同平台的特性包，比如 linux 下的<code class="language-plaintext highlighter-rouge">deb</code>和<code class="language-plaintext highlighter-rouge">rpm</code>，window 平台下的<code class="language-plaintext highlighter-rouge">msi</code>和<code class="language-plaintext highlighter-rouge">exe</code></li>
</ul>

<h2 id="java15">Java15</h2>

<h3 id="charsequence">CharSequence</h3>

<p><code class="language-plaintext highlighter-rouge">CharSequence</code> 接口添加了一个默认方法 <code class="language-plaintext highlighter-rouge">isEmpty()</code> 来判断字符序列为空，如果是则返回 true。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">CharSequence</span> <span class="o">{</span>
  <span class="k">default</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="treemap">TreeMap</h3>

<p><code class="language-plaintext highlighter-rouge">TreeMap</code> 新引入了下面这些方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">putIfAbsent()</code></li>
  <li><code class="language-plaintext highlighter-rouge">computeIfAbsent()</code></li>
  <li><code class="language-plaintext highlighter-rouge">computeIfPresent()</code></li>
  <li><code class="language-plaintext highlighter-rouge">compute()</code></li>
  <li><code class="language-plaintext highlighter-rouge">merge()</code></li>
</ul>

<h3 id="zgc转正">ZGC(转正)</h3>

<p>Java11 的时候 ，ZGC 还在试验阶段。</p>

<p>当时，ZGC 的出现让众多 Java 开发者看到了垃圾回收器的另外一种可能，因此备受关注。</p>

<p>经过多个版本的迭代，不断的完善和修复问题，ZGC 在 Java 15 已经可以正式使用了！</p>

<p>不过，默认的垃圾回收器依然是 G1。你可以通过下面的参数启动 ZGC：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java <span class="nt">-XX</span>:+UseZGC className
</code></pre></div></div>

<h3 id="eddsa数字签名算法">EdDSA(数字签名算法)</h3>

<p>新加入了一个安全性和性能都更强的基于 Edwards-Curve Digital Signature Algorithm （EdDSA）实现的数字签名算法。</p>

<p>虽然其性能优于现有的 ECDSA 实现，不过，它并不会完全取代 JDK 中现有的椭圆曲线数字签名算法( ECDSA)。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">KeyPairGenerator</span> <span class="n">kpg</span> <span class="o">=</span> <span class="nc">KeyPairGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"Ed25519"</span><span class="o">);</span>
<span class="nc">KeyPair</span> <span class="n">kp</span> <span class="o">=</span> <span class="n">kpg</span><span class="o">.</span><span class="na">generateKeyPair</span><span class="o">();</span>

<span class="kt">byte</span><span class="o">[]</span> <span class="n">msg</span> <span class="o">=</span> <span class="s">"test_string"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>

<span class="nc">Signature</span> <span class="n">sig</span> <span class="o">=</span> <span class="nc">Signature</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"Ed25519"</span><span class="o">);</span>
<span class="n">sig</span><span class="o">.</span><span class="na">initSign</span><span class="o">(</span><span class="n">kp</span><span class="o">.</span><span class="na">getPrivate</span><span class="o">());</span>
<span class="n">sig</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="na">sign</span><span class="o">();</span>

<span class="nc">String</span> <span class="n">encodedString</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">getEncoder</span><span class="o">().</span><span class="na">encodeToString</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">encodedString</span><span class="o">);</span>
</code></pre></div></div>

<p>输出：</p>

<pre><code class="language-plain">0Hc0lxxASZNvS52WsvnncJOH/mlFhnA8Tc6D/k5DtAX5BSsNVjtPF4R4+yMWXVjrvB2mxVXmChIbki6goFBgAg==
</code></pre>

<h3 id="文本块转正">文本块(转正)</h3>

<p>在 Java 15 ，文本块是正式的功能特性了。</p>

<h3 id="隐藏类hidden-classes">隐藏类(Hidden Classes)</h3>

<p>隐藏类是为框架（frameworks）所设计的，隐藏类不能直接被其他类的字节码使用，只能在运行时生成类并通过反射间接使用它们。</p>

<h3 id="预览新特性-1">预览新特性</h3>

<h4 id="密封类">密封类</h4>

<p><strong>密封类（Sealed Classes）</strong> 是 Java 15 中的一个预览新特性。</p>

<p>没有密封类之前，在 Java 中如果想让一个类不能被继承和修改，我们可以使用<code class="language-plaintext highlighter-rouge">final</code> 关键字对类进行修饰。不过，这种方式不太灵活，直接把一个类的继承和修改渠道给堵死了。</p>

<p>密封类可以对继承或者实现它们的类进行限制，这样这个类就只能被指定的类继承。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 抽象类 Person 只允许 Employee 和 Manager 继承。</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="n">sealed</span> <span class="kd">class</span> <span class="nc">Person</span>
    <span class="n">permits</span> <span class="nc">Employee</span><span class="o">,</span> <span class="nc">Manager</span> <span class="o">{</span>

    <span class="c1">//...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>另外，任何扩展密封类的类本身都必须声明为 <code class="language-plaintext highlighter-rouge">sealed</code>、<code class="language-plaintext highlighter-rouge">non-sealed</code> 或 <code class="language-plaintext highlighter-rouge">final</code>。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Employee</span> <span class="kd">extends</span> <span class="nc">Person</span> <span class="o">{</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="n">non</span><span class="o">-</span><span class="n">sealed</span> <span class="kd">class</span> <span class="nc">Manager</span> <span class="kd">extends</span> <span class="nc">Person</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="https://oss.javaguide.cn/javaguide/image-20210820153955587.png" alt="" /></p>

<p>如果允许扩展的子类和封闭类在同一个源代码文件里，封闭类可以不使用 permits 语句，Java 编译器将检索源文件，在编译期为封闭类添加上许可的子类。</p>

<h4 id="instanceof-模式匹配">instanceof 模式匹配</h4>

<p>Java 15 并没有对此特性进行调整，继续预览特性，主要用于接受更多的使用反馈。</p>

<p>在未来的 Java 版本中，Java 的目标是继续完善 <code class="language-plaintext highlighter-rouge">instanceof</code> 模式匹配新特性。</p>

<h3 id="其他-1">其他</h3>

<ul>
  <li><strong>Nashorn JavaScript 引擎彻底移除</strong>：Nashorn 从 Java8 开始引入的 JavaScript 引擎，Java9 对 Nashorn 做了些增强，实现了一些 ES6 的新特性。在 Java 11 中就已经被弃用，到了 Java 15 就彻底被删除了。</li>
  <li><strong>DatagramSocket API 重构</strong></li>
  <li><strong>禁用和废弃偏向锁（Biased Locking）</strong>：偏向锁的引入增加了 JVM 的复杂性大于其带来的性能提升。不过，你仍然可以使用 <code class="language-plaintext highlighter-rouge">-XX:+UseBiasedLocking</code> 启用偏向锁定，但它会提示这是一个已弃用的 API。</li>
  <li>……</li>
</ul>

<!-- @include: @article-footer.snippet.md -->
