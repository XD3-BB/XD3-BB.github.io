<!-- @include: @small-advertisement.snippet.md -->

<!-- markdownlint-disable MD024 -->

<h2 id="集合概述">集合概述</h2>

<h3 id="java-集合概览">Java 集合概览</h3>

<p>Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 <code class="language-plaintext highlighter-rouge">Collection</code>接口，主要用于存放单一元素；另一个是 <code class="language-plaintext highlighter-rouge">Map</code> 接口，主要用于存放键值对。对于<code class="language-plaintext highlighter-rouge">Collection</code> 接口，下面又有三个主要的子接口：<code class="language-plaintext highlighter-rouge">List</code>、<code class="language-plaintext highlighter-rouge">Set</code> 、 <code class="language-plaintext highlighter-rouge">Queue</code>。</p>

<p>Java 集合框架如下图所示：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/java-collection-hierarchy.png" alt="Java 集合框架概览" /></p>

<p>注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了<code class="language-plaintext highlighter-rouge">AbstractList</code>, <code class="language-plaintext highlighter-rouge">NavigableSet</code>等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。</p>

<h3 id="说说-list-set-queue-map-四者的区别">说说 List, Set, Queue, Map 四者的区别？</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li>
  <li><code class="language-plaintext highlighter-rouge">Set</code>(注重独一无二的性质): 存储的元素不可重复的。</li>
  <li><code class="language-plaintext highlighter-rouge">Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>
  <li><code class="language-plaintext highlighter-rouge">Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>

<h3 id="集合框架底层数据结构总结">集合框架底层数据结构总结</h3>

<p>先来看一下 <code class="language-plaintext highlighter-rouge">Collection</code> 接口下面的集合。</p>

<h4 id="list">List</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ArrayList</code>：<code class="language-plaintext highlighter-rouge">Object[]</code> 数组。详细可以查看：<a href="./arraylist-source-code.md">ArrayList 源码分析</a>。</li>
  <li><code class="language-plaintext highlighter-rouge">Vector</code>：<code class="language-plaintext highlighter-rouge">Object[]</code> 数组。</li>
  <li><code class="language-plaintext highlighter-rouge">LinkedList</code>：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)。详细可以查看：<a href="./linkedlist-source-code.md">LinkedList 源码分析</a>。</li>
</ul>

<h4 id="set">Set</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">HashSet</code>(无序，唯一): 基于 <code class="language-plaintext highlighter-rouge">HashMap</code> 实现的，底层采用 <code class="language-plaintext highlighter-rouge">HashMap</code> 来保存元素。</li>
  <li><code class="language-plaintext highlighter-rouge">LinkedHashSet</code>: <code class="language-plaintext highlighter-rouge">LinkedHashSet</code> 是 <code class="language-plaintext highlighter-rouge">HashSet</code> 的子类，并且其内部是通过 <code class="language-plaintext highlighter-rouge">LinkedHashMap</code> 来实现的。</li>
  <li><code class="language-plaintext highlighter-rouge">TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)。</li>
</ul>

<h4 id="queue">Queue</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">PriorityQueue</code>: <code class="language-plaintext highlighter-rouge">Object[]</code> 数组来实现小顶堆。详细可以查看：<a href="./priorityqueue-source-code.md">PriorityQueue 源码分析</a>。</li>
  <li><code class="language-plaintext highlighter-rouge">DelayQueue</code>:<code class="language-plaintext highlighter-rouge">PriorityQueue</code>。详细可以查看：<a href="./delayqueue-source-code.md">DelayQueue 源码分析</a>。</li>
  <li><code class="language-plaintext highlighter-rouge">ArrayDeque</code>: 可扩容动态双向数组。</li>
</ul>

<p>再来看看 <code class="language-plaintext highlighter-rouge">Map</code> 接口下面的集合。</p>

<h4 id="map">Map</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">HashMap</code>：JDK1.8 之前 <code class="language-plaintext highlighter-rouge">HashMap</code> 由数组+链表组成的，数组是 <code class="language-plaintext highlighter-rouge">HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。详细可以查看：<a href="./hashmap-source-code.md">HashMap 源码分析</a>。</li>
  <li><code class="language-plaintext highlighter-rouge">LinkedHashMap</code>：<code class="language-plaintext highlighter-rouge">LinkedHashMap</code> 继承自 <code class="language-plaintext highlighter-rouge">HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code class="language-plaintext highlighter-rouge">LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="./linkedhashmap-source-code.md">LinkedHashMap 源码分析</a></li>
  <li><code class="language-plaintext highlighter-rouge">Hashtable</code>：数组+链表组成的，数组是 <code class="language-plaintext highlighter-rouge">Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的。</li>
  <li><code class="language-plaintext highlighter-rouge">TreeMap</code>：红黑树（自平衡的排序二叉树）。</li>
</ul>

<h3 id="如何选用集合">如何选用集合?</h3>

<p>我们主要根据集合的特点来选择合适的集合。比如：</p>

<ul>
  <li>我们需要根据键值获取到元素值时就选用 <code class="language-plaintext highlighter-rouge">Map</code> 接口下的集合，需要排序时选择 <code class="language-plaintext highlighter-rouge">TreeMap</code>,不需要排序时就选择 <code class="language-plaintext highlighter-rouge">HashMap</code>,需要保证线程安全就选用 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code>。</li>
  <li>我们只需要存放元素值时，就选择实现<code class="language-plaintext highlighter-rouge">Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code class="language-plaintext highlighter-rouge">Set</code> 接口的集合比如 <code class="language-plaintext highlighter-rouge">TreeSet</code> 或 <code class="language-plaintext highlighter-rouge">HashSet</code>，不需要就选择实现 <code class="language-plaintext highlighter-rouge">List</code> 接口的比如 <code class="language-plaintext highlighter-rouge">ArrayList</code> 或 <code class="language-plaintext highlighter-rouge">LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</li>
</ul>

<h3 id="为什么要使用集合">为什么要使用集合？</h3>

<p>当我们需要存储一组类型相同的数据时，数组是最常用且最基本的容器之一。但是，使用数组存储对象存在一些不足之处，因为在实际开发中，存储的数据类型多种多样且数量不确定。这时，Java 集合就派上用场了。与数组相比，Java 集合提供了更灵活、更有效的方法来存储多个数据对象。Java 集合框架中的各种集合类和接口可以存储不同类型和数量的对象，同时还具有多样化的操作方式。相较于数组，Java 集合的优势在于它们的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。</p>

<h2 id="list-1">List</h2>

<h3 id="arraylist-和-array数组的区别">ArrayList 和 Array（数组）的区别？</h3>

<p><code class="language-plaintext highlighter-rouge">ArrayList</code> 内部基于动态数组实现，比 <code class="language-plaintext highlighter-rouge">Array</code>（静态数组） 使用起来更加灵活：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code class="language-plaintext highlighter-rouge">Array</code> 被创建之后就不能改变它的长度了。</li>
  <li><code class="language-plaintext highlighter-rouge">ArrayList</code> 允许你使用泛型来确保类型安全，<code class="language-plaintext highlighter-rouge">Array</code> 则不可以。</li>
  <li><code class="language-plaintext highlighter-rouge">ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code class="language-plaintext highlighter-rouge">Array</code> 可以直接存储基本类型数据，也可以存储对象。</li>
  <li><code class="language-plaintext highlighter-rouge">ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code class="language-plaintext highlighter-rouge">add()</code>、<code class="language-plaintext highlighter-rouge">remove()</code>等。<code class="language-plaintext highlighter-rouge">Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li>
  <li><code class="language-plaintext highlighter-rouge">ArrayList</code>创建时不需要指定大小，而<code class="language-plaintext highlighter-rouge">Array</code>创建时必须指定大小。</li>
</ul>

<p>下面是二者使用的简单对比：</p>

<p><code class="language-plaintext highlighter-rouge">Array</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// 初始化一个 String 类型的数组</span>
 <span class="nc">String</span><span class="o">[]</span> <span class="n">stringArr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="s">"hello"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">,</span> <span class="s">"!"</span><span class="o">};</span>
 <span class="c1">// 修改数组元素的值</span>
 <span class="n">stringArr</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="s">"goodbye"</span><span class="o">;</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">stringArr</span><span class="o">));</span><span class="c1">// [goodbye, world, !]</span>
 <span class="c1">// 删除数组中的元素，需要手动移动后面的元素</span>
 <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stringArr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
     <span class="n">stringArr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">stringArr</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
 <span class="o">}</span>
 <span class="n">stringArr</span><span class="o">[</span><span class="n">stringArr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">stringArr</span><span class="o">));</span><span class="c1">// [world, !, null]</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ArrayList</code> ：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 初始化一个 String 类型的 ArrayList</span>
 <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stringList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"hello"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">,</span> <span class="s">"!"</span><span class="o">));</span>
<span class="c1">// 添加元素到 ArrayList 中</span>
 <span class="n">stringList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"goodbye"</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">stringList</span><span class="o">);</span><span class="c1">// [hello, world, !, goodbye]</span>
 <span class="c1">// 修改 ArrayList 中的元素</span>
 <span class="n">stringList</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">"hi"</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">stringList</span><span class="o">);</span><span class="c1">// [hi, world, !, goodbye]</span>
 <span class="c1">// 删除 ArrayList 中的元素</span>
 <span class="n">stringList</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">stringList</span><span class="o">);</span> <span class="c1">// [world, !, goodbye]</span>
</code></pre></div></div>

<h3 id="arraylist-和-vector-的区别了解即可">ArrayList 和 Vector 的区别?（了解即可）</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ArrayList</code> 是 <code class="language-plaintext highlighter-rouge">List</code> 的主要实现类，底层使用 <code class="language-plaintext highlighter-rouge">Object[]</code>存储，适用于频繁的查找工作，线程不安全 。</li>
  <li><code class="language-plaintext highlighter-rouge">Vector</code> 是 <code class="language-plaintext highlighter-rouge">List</code> 的古老实现类，底层使用<code class="language-plaintext highlighter-rouge">Object[]</code> 存储，线程安全。</li>
</ul>

<h3 id="vector-和-stack-的区别了解即可">Vector 和 Stack 的区别?（了解即可）</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Vector</code> 和 <code class="language-plaintext highlighter-rouge">Stack</code> 两者都是线程安全的，都是使用 <code class="language-plaintext highlighter-rouge">synchronized</code> 关键字进行同步处理。</li>
  <li><code class="language-plaintext highlighter-rouge">Stack</code> 继承自 <code class="language-plaintext highlighter-rouge">Vector</code>，是一个后进先出的栈，而 <code class="language-plaintext highlighter-rouge">Vector</code> 是一个列表。</li>
</ul>

<p>随着 Java 并发编程的发展，<code class="language-plaintext highlighter-rouge">Vector</code> 和 <code class="language-plaintext highlighter-rouge">Stack</code> 已经被淘汰，推荐使用并发集合类（例如 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code>、<code class="language-plaintext highlighter-rouge">CopyOnWriteArrayList</code> 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。</p>

<h3 id="arraylist-可以添加-null-值吗">ArrayList 可以添加 null 值吗？</h3>

<p><code class="language-plaintext highlighter-rouge">ArrayList</code> 中可以存储任何类型的对象，包括 <code class="language-plaintext highlighter-rouge">null</code> 值。不过，不建议向<code class="language-plaintext highlighter-rouge">ArrayList</code> 中添加 <code class="language-plaintext highlighter-rouge">null</code> 值， <code class="language-plaintext highlighter-rouge">null</code> 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。</p>

<p>示例代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">listOfStrings</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="n">listOfStrings</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
<span class="n">listOfStrings</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"java"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">listOfStrings</span><span class="o">);</span>
</code></pre></div></div>

<p>输出：</p>

<pre><code class="language-plain">[null, java]
</code></pre>

<h3 id="arraylist-插入和删除元素的时间复杂度">ArrayList 插入和删除元素的时间复杂度？</h3>

<p>对于插入：</p>

<ul>
  <li>头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。</li>
  <li>尾部插入：当 <code class="language-plaintext highlighter-rouge">ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li>
  <li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n/2 个元素，因此时间复杂度为 O(n)。</li>
</ul>

<p>对于删除：</p>

<ul>
  <li>头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。</li>
  <li>尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</li>
  <li>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。</li>
</ul>

<p>这里简单列举一个例子：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ArrayList的底层数组大小为10，此时存储了7个元素</span>
<span class="o">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="mi">3</span> <span class="o">|</span> <span class="mi">4</span> <span class="o">|</span> <span class="mi">5</span> <span class="o">|</span> <span class="mi">6</span> <span class="o">|</span> <span class="mi">7</span> <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>
<span class="o">+---+---+---+---+---+---+---+---+---+---+</span>
  <span class="mi">0</span>   <span class="mi">1</span>   <span class="mi">2</span>   <span class="mi">3</span>   <span class="mi">4</span>   <span class="mi">5</span>   <span class="mi">6</span>   <span class="mi">7</span>   <span class="mi">8</span>   <span class="mi">9</span>
<span class="c1">// 在索引为1的位置插入一个元素8，该元素后面的所有元素都要向右移动一位</span>
<span class="o">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">8</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="mi">3</span> <span class="o">|</span> <span class="mi">4</span> <span class="o">|</span> <span class="mi">5</span> <span class="o">|</span> <span class="mi">6</span> <span class="o">|</span> <span class="mi">7</span> <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>
<span class="o">+---+---+---+---+---+---+---+---+---+---+</span>
  <span class="mi">0</span>   <span class="mi">1</span>   <span class="mi">2</span>   <span class="mi">3</span>   <span class="mi">4</span>   <span class="mi">5</span>   <span class="mi">6</span>   <span class="mi">7</span>   <span class="mi">8</span>   <span class="mi">9</span>
<span class="c1">// 删除索引为1的位置的元素，该元素后面的所有元素都要向左移动一位</span>
<span class="o">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="mi">3</span> <span class="o">|</span> <span class="mi">4</span> <span class="o">|</span> <span class="mi">5</span> <span class="o">|</span> <span class="mi">6</span> <span class="o">|</span> <span class="mi">7</span> <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>
<span class="o">+---+---+---+---+---+---+---+---+---+---+</span>
  <span class="mi">0</span>   <span class="mi">1</span>   <span class="mi">2</span>   <span class="mi">3</span>   <span class="mi">4</span>   <span class="mi">5</span>   <span class="mi">6</span>   <span class="mi">7</span>   <span class="mi">8</span>   <span class="mi">9</span>
</code></pre></div></div>

<h3 id="linkedlist-插入和删除元素的时间复杂度">LinkedList 插入和删除元素的时间复杂度？</h3>

<ul>
  <li>头部插入/删除：只需要修改头结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。</li>
  <li>尾部插入/删除：只需要修改尾结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。</li>
  <li>指定位置插入/删除：需要先移动到指定位置，再修改指定节点的指针完成插入/删除，不过由于有头尾指针，可以从较近的指针出发，因此需要遍历平均 n/4 个元素，时间复杂度为 O(n)。</li>
</ul>

<p>这里简单列举一个例子：假如我们要删除节点 9 的话，需要先遍历链表找到该节点。然后，再执行相应节点指针指向的更改，具体的源码可以参考：<a href="./linkedlist-source-code.md">LinkedList 源码分析</a> 。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/linkedlist-unlink.jpg" alt="unlink 方法逻辑" /></p>

<h3 id="linkedlist-为什么不能实现-randomaccess-接口">LinkedList 为什么不能实现 RandomAccess 接口？</h3>

<p><code class="language-plaintext highlighter-rouge">RandomAccess</code> 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 <code class="language-plaintext highlighter-rouge">LinkedList</code> 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 <code class="language-plaintext highlighter-rouge">RandomAccess</code> 接口。</p>

<h3 id="arraylist-与-linkedlist-区别">ArrayList 与 LinkedList 区别?</h3>

<ul>
  <li><strong>是否保证线程安全：</strong> <code class="language-plaintext highlighter-rouge">ArrayList</code> 和 <code class="language-plaintext highlighter-rouge">LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>
  <li><strong>底层数据结构：</strong> <code class="language-plaintext highlighter-rouge">ArrayList</code> 底层使用的是 <strong><code class="language-plaintext highlighter-rouge">Object</code> 数组</strong>；<code class="language-plaintext highlighter-rouge">LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>
  <li><strong>插入和删除是否受元素位置的影响：</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code class="language-plaintext highlighter-rouge">add(E e)</code>方法的时候， <code class="language-plaintext highlighter-rouge">ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code class="language-plaintext highlighter-rouge">add(int index, E element)</code>），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li>
      <li><code class="language-plaintext highlighter-rouge">LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（<code class="language-plaintext highlighter-rouge">add(E e)</code>、<code class="language-plaintext highlighter-rouge">addFirst(E e)</code>、<code class="language-plaintext highlighter-rouge">addLast(E e)</code>、<code class="language-plaintext highlighter-rouge">removeFirst()</code>、 <code class="language-plaintext highlighter-rouge">removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code class="language-plaintext highlighter-rouge">i</code> 插入和删除元素的话（<code class="language-plaintext highlighter-rouge">add(int index, E element)</code>，<code class="language-plaintext highlighter-rouge">remove(Object o)</code>,<code class="language-plaintext highlighter-rouge">remove(int index)</code>）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。</li>
    </ul>
  </li>
  <li><strong>是否支持快速随机访问：</strong> <code class="language-plaintext highlighter-rouge">LinkedList</code> 不支持高效的随机元素访问，而 <code class="language-plaintext highlighter-rouge">ArrayList</code>（实现了 <code class="language-plaintext highlighter-rouge">RandomAccess</code> 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code class="language-plaintext highlighter-rouge">get(int index)</code>方法)。</li>
  <li><strong>内存空间占用：</strong> <code class="language-plaintext highlighter-rouge">ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ul>

<p>我们在项目中一般是不会使用到 <code class="language-plaintext highlighter-rouge">LinkedList</code> 的，需要用到 <code class="language-plaintext highlighter-rouge">LinkedList</code> 的场景几乎都可以使用 <code class="language-plaintext highlighter-rouge">ArrayList</code> 来代替，并且，性能通常会更好！就连 <code class="language-plaintext highlighter-rouge">LinkedList</code> 的作者约书亚 · 布洛克（Josh Bloch）自己都说从来不会使用 <code class="language-plaintext highlighter-rouge">LinkedList</code> 。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/redisimage-20220412110853807.png" alt="" /></p>

<p>另外，不要下意识地认为 <code class="language-plaintext highlighter-rouge">LinkedList</code> 作为链表就最适合元素增删的场景。我在上面也说了，<code class="language-plaintext highlighter-rouge">LinkedList</code> 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的平均时间复杂度都是 O(n) 。</p>

<h4 id="补充内容-双向链表和双向循环链表">补充内容: 双向链表和双向循环链表</h4>

<p><strong>双向链表：</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/bidirectional-linkedlist.png" alt="双向链表" /></p>

<p><strong>双向循环链表：</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/bidirectional-circular-linkedlist.png" alt="双向循环链表" /></p>

<h4 id="补充内容randomaccess-接口">补充内容:RandomAccess 接口</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">RandomAccess</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<p>查看源码我们发现实际上 <code class="language-plaintext highlighter-rouge">RandomAccess</code> 接口中什么都没有定义。所以，在我看来 <code class="language-plaintext highlighter-rouge">RandomAccess</code> 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p>

<p>在 <code class="language-plaintext highlighter-rouge">binarySearch()</code> 方法中，它要判断传入的 list 是否 <code class="language-plaintext highlighter-rouge">RandomAccess</code> 的实例，如果是，调用<code class="language-plaintext highlighter-rouge">indexedBinarySearch()</code>方法，如果不是，那么调用<code class="language-plaintext highlighter-rouge">iteratorBinarySearch()</code>方法</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span>
    <span class="kt">int</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="no">T</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">list</span> <span class="k">instanceof</span> <span class="nc">RandomAccess</span> <span class="o">||</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()&lt;</span><span class="no">BINARYSEARCH_THRESHOLD</span><span class="o">)</span>
            <span class="k">return</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">indexedBinarySearch</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">iteratorBinarySearch</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ArrayList</code> 实现了 <code class="language-plaintext highlighter-rouge">RandomAccess</code> 接口， 而 <code class="language-plaintext highlighter-rouge">LinkedList</code> 没有实现。为什么呢？我觉得还是和底层数据结构有关！<code class="language-plaintext highlighter-rouge">ArrayList</code> 底层是数组，而 <code class="language-plaintext highlighter-rouge">LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。<code class="language-plaintext highlighter-rouge">ArrayList</code> 实现了 <code class="language-plaintext highlighter-rouge">RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code class="language-plaintext highlighter-rouge">RandomAccess</code> 接口只是标识，并不是说 <code class="language-plaintext highlighter-rouge">ArrayList</code> 实现 <code class="language-plaintext highlighter-rouge">RandomAccess</code> 接口才具有快速随机访问功能的！</p>

<h3 id="说一说-arraylist-的扩容机制吧">说一说 ArrayList 的扩容机制吧</h3>

<p>详见笔主的这篇文章: <a href="https://javaguide.cn/java/collection/arraylist-source-code.html#_3-1-%E5%85%88%E4%BB%8E-arraylist-%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%B4%E8%B5%B7">ArrayList 扩容机制分析</a>。</p>

<h2 id="set-1">Set</h2>

<h3 id="comparable-和-comparator-的区别">Comparable 和 Comparator 的区别</h3>

<p><code class="language-plaintext highlighter-rouge">Comparable</code> 接口和 <code class="language-plaintext highlighter-rouge">Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Comparable</code> 接口实际上是出自<code class="language-plaintext highlighter-rouge">java.lang</code>包 它有一个 <code class="language-plaintext highlighter-rouge">compareTo(Object obj)</code>方法用来排序</li>
  <li><code class="language-plaintext highlighter-rouge">Comparator</code>接口实际上是出自 <code class="language-plaintext highlighter-rouge">java.util</code> 包它有一个<code class="language-plaintext highlighter-rouge">compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>

<p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code class="language-plaintext highlighter-rouge">compareTo()</code>方法或<code class="language-plaintext highlighter-rouge">compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 <code class="language-plaintext highlighter-rouge">song</code> 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code class="language-plaintext highlighter-rouge">compareTo()</code>方法和使用自制的<code class="language-plaintext highlighter-rouge">Comparator</code>方法或者以两个 <code class="language-plaintext highlighter-rouge">Comparator</code> 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code class="language-plaintext highlighter-rouge">Collections.sort()</code>.</p>

<h4 id="comparator-定制排序">Comparator 定制排序</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">arrayList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
<span class="n">arrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
<span class="n">arrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
<span class="n">arrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
<span class="n">arrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(-</span><span class="mi">5</span><span class="o">);</span>
<span class="n">arrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">7</span><span class="o">);</span>
<span class="n">arrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
<span class="n">arrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(-</span><span class="mi">9</span><span class="o">);</span>
<span class="n">arrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(-</span><span class="mi">7</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"原始数组:"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arrayList</span><span class="o">);</span>
<span class="c1">// void reverse(List list)：反转</span>
<span class="nc">Collections</span><span class="o">.</span><span class="na">reverse</span><span class="o">(</span><span class="n">arrayList</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Collections.reverse(arrayList):"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arrayList</span><span class="o">);</span>

<span class="c1">// void sort(List list),按自然排序的升序排序</span>
<span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arrayList</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Collections.sort(arrayList):"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arrayList</span><span class="o">);</span>
<span class="c1">// 定制排序的用法</span>
<span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arrayList</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">o1</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">o2</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">o1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"定制排序后："</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arrayList</span><span class="o">);</span>
</code></pre></div></div>

<p>Output:</p>

<pre><code class="language-plain">原始数组:
[-1, 3, 3, -5, 7, 4, -9, -7]
Collections.reverse(arrayList):
[-7, -9, 4, 7, -5, 3, 3, -1]
Collections.sort(arrayList):
[-9, -7, -5, -1, 3, 3, 4, 7]
定制排序后：
[7, 4, 3, 3, -1, -5, -7, -9]
</code></pre>

<h4 id="重写-compareto-方法实现按年龄来排序">重写 compareTo 方法实现按年龄来排序</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span>
<span class="c1">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span>
<span class="c1">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span>
<span class="kd">public</span>  <span class="kd">class</span> <span class="nc">Person</span> <span class="kd">implements</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * T重写compareTo方法实现按年龄来排序
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="nc">Person</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">&gt;</span> <span class="n">o</span><span class="o">.</span><span class="na">getAge</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">&lt;</span> <span class="n">o</span><span class="o">.</span><span class="na">getAge</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">TreeMap</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">pdata</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;();</span>
        <span class="n">pdata</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"张三"</span><span class="o">,</span> <span class="mi">30</span><span class="o">),</span> <span class="s">"zhangsan"</span><span class="o">);</span>
        <span class="n">pdata</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"李四"</span><span class="o">,</span> <span class="mi">20</span><span class="o">),</span> <span class="s">"lisi"</span><span class="o">);</span>
        <span class="n">pdata</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"王五"</span><span class="o">,</span> <span class="mi">10</span><span class="o">),</span> <span class="s">"wangwu"</span><span class="o">);</span>
        <span class="n">pdata</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"小红"</span><span class="o">,</span> <span class="mi">5</span><span class="o">),</span> <span class="s">"xiaohong"</span><span class="o">);</span>
        <span class="c1">// 得到key的值的同时得到key所对应的值</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">.</span><span class="na">keySet</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Person</span> <span class="n">key</span> <span class="o">:</span> <span class="n">keys</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">getAge</span><span class="o">()</span> <span class="o">+</span> <span class="s">"-"</span> <span class="o">+</span> <span class="n">key</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>

        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>Output：</p>

<pre><code class="language-plain">5-小红
10-王五
20-李四
30-张三
</code></pre>

<h3 id="无序性和不可重复性的含义是什么">无序性和不可重复性的含义是什么</h3>

<ul>
  <li>无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</li>
  <li>不可重复性是指添加的元素按照 <code class="language-plaintext highlighter-rouge">equals()</code> 判断时 ，返回 false，需要同时重写 <code class="language-plaintext highlighter-rouge">equals()</code> 方法和 <code class="language-plaintext highlighter-rouge">hashCode()</code> 方法。</li>
</ul>

<h3 id="比较-hashsetlinkedhashset-和-treeset-三者的异同">比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">HashSet</code>、<code class="language-plaintext highlighter-rouge">LinkedHashSet</code> 和 <code class="language-plaintext highlighter-rouge">TreeSet</code> 都是 <code class="language-plaintext highlighter-rouge">Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
  <li><code class="language-plaintext highlighter-rouge">HashSet</code>、<code class="language-plaintext highlighter-rouge">LinkedHashSet</code> 和 <code class="language-plaintext highlighter-rouge">TreeSet</code> 的主要区别在于底层数据结构不同。<code class="language-plaintext highlighter-rouge">HashSet</code> 的底层数据结构是哈希表（基于 <code class="language-plaintext highlighter-rouge">HashMap</code> 实现）。<code class="language-plaintext highlighter-rouge">LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code class="language-plaintext highlighter-rouge">TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
  <li>底层数据结构不同又导致这三者的应用场景不同。<code class="language-plaintext highlighter-rouge">HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code class="language-plaintext highlighter-rouge">LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code class="language-plaintext highlighter-rouge">TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>
</ul>

<h2 id="queue-1">Queue</h2>

<h3 id="queue-与-deque-的区别">Queue 与 Deque 的区别</h3>

<p><code class="language-plaintext highlighter-rouge">Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>

<p><code class="language-plaintext highlighter-rouge">Queue</code> 扩展了 <code class="language-plaintext highlighter-rouge">Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>

<table>
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">Queue</code> 接口</th>
      <th>抛出异常</th>
      <th>返回特殊值</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>插入队尾</td>
      <td>add(E e)</td>
      <td>offer(E e)</td>
    </tr>
    <tr>
      <td>删除队首</td>
      <td>remove()</td>
      <td>poll()</td>
    </tr>
    <tr>
      <td>查询队首元素</td>
      <td>element()</td>
      <td>peek()</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p>

<p><code class="language-plaintext highlighter-rouge">Deque</code> 扩展了 <code class="language-plaintext highlighter-rouge">Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>

<table>
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">Deque</code> 接口</th>
      <th>抛出异常</th>
      <th>返回特殊值</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>插入队首</td>
      <td>addFirst(E e)</td>
      <td>offerFirst(E e)</td>
    </tr>
    <tr>
      <td>插入队尾</td>
      <td>addLast(E e)</td>
      <td>offerLast(E e)</td>
    </tr>
    <tr>
      <td>删除队首</td>
      <td>removeFirst()</td>
      <td>pollFirst()</td>
    </tr>
    <tr>
      <td>删除队尾</td>
      <td>removeLast()</td>
      <td>pollLast()</td>
    </tr>
    <tr>
      <td>查询队首元素</td>
      <td>getFirst()</td>
      <td>peekFirst()</td>
    </tr>
    <tr>
      <td>查询队尾元素</td>
      <td>getLast()</td>
      <td>peekLast()</td>
    </tr>
  </tbody>
</table>

<p>事实上，<code class="language-plaintext highlighter-rouge">Deque</code> 还提供有 <code class="language-plaintext highlighter-rouge">push()</code> 和 <code class="language-plaintext highlighter-rouge">pop()</code> 等其他方法，可用于模拟栈。</p>

<h3 id="arraydeque-与-linkedlist-的区别">ArrayDeque 与 LinkedList 的区别</h3>

<p><code class="language-plaintext highlighter-rouge">ArrayDeque</code> 和 <code class="language-plaintext highlighter-rouge">LinkedList</code> 都实现了 <code class="language-plaintext highlighter-rouge">Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code class="language-plaintext highlighter-rouge">LinkedList</code> 则通过链表来实现。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ArrayDeque</code> 不支持存储 <code class="language-plaintext highlighter-rouge">NULL</code> 数据，但 <code class="language-plaintext highlighter-rouge">LinkedList</code> 支持。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code class="language-plaintext highlighter-rouge">LinkedList</code> 早在 JDK1.2 时就已经存在。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code class="language-plaintext highlighter-rouge">LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</p>
  </li>
</ul>

<p>从性能的角度上，选用 <code class="language-plaintext highlighter-rouge">ArrayDeque</code> 来实现队列要比 <code class="language-plaintext highlighter-rouge">LinkedList</code> 更好。此外，<code class="language-plaintext highlighter-rouge">ArrayDeque</code> 也可以用于实现栈。</p>

<h3 id="说一说-priorityqueue">说一说 PriorityQueue</h3>

<p><code class="language-plaintext highlighter-rouge">PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code class="language-plaintext highlighter-rouge">Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>

<p>这里列举其相关的一些要点：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>
  <li><code class="language-plaintext highlighter-rouge">PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>
  <li><code class="language-plaintext highlighter-rouge">PriorityQueue</code> 是非线程安全的，且不支持存储 <code class="language-plaintext highlighter-rouge">NULL</code> 和 <code class="language-plaintext highlighter-rouge">non-comparable</code> 的对象。</li>
  <li><code class="language-plaintext highlighter-rouge">PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code class="language-plaintext highlighter-rouge">Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。</p>

<h3 id="什么是-blockingqueue">什么是 BlockingQueue？</h3>

<p><code class="language-plaintext highlighter-rouge">BlockingQueue</code> （阻塞队列）是一个接口，继承自 <code class="language-plaintext highlighter-rouge">Queue</code>。<code class="language-plaintext highlighter-rouge">BlockingQueue</code>阻塞的原因是其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">BlockingQueue</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">BlockingQueue</code> 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/blocking-queue.png" alt="BlockingQueue" /></p>

<h3 id="blockingqueue-的实现类有哪些">BlockingQueue 的实现类有哪些？</h3>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/blocking-queue-hierarchy.png" alt="BlockingQueue 的实现类" /></p>

<p>Java 中常用的阻塞队列实现类有以下几种：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">ArrayBlockingQueue</code>：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。</li>
  <li><code class="language-plaintext highlighter-rouge">LinkedBlockingQueue</code>：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为<code class="language-plaintext highlighter-rouge">Integer.MAX_VALUE</code>。和<code class="language-plaintext highlighter-rouge">ArrayBlockingQueue</code>不同的是， 它仅支持非公平的锁访问机制。</li>
  <li><code class="language-plaintext highlighter-rouge">PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。元素必须实现<code class="language-plaintext highlighter-rouge">Comparable</code>接口或者在构造函数中传入<code class="language-plaintext highlighter-rouge">Comparator</code>对象，并且不能插入 null 元素。</li>
  <li><code class="language-plaintext highlighter-rouge">SynchronousQueue</code>：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，<code class="language-plaintext highlighter-rouge">SynchronousQueue</code>通常用于线程之间的直接传递数据。</li>
  <li><code class="language-plaintext highlighter-rouge">DelayQueue</code>：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</li>
  <li>……</li>
</ol>

<p>日常开发中，这些队列使用的其实都不多，了解即可。</p>

<h3 id="arrayblockingqueue-和-linkedblockingqueue-有什么区别">ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？</h3>

<p><code class="language-plaintext highlighter-rouge">ArrayBlockingQueue</code> 和 <code class="language-plaintext highlighter-rouge">LinkedBlockingQueue</code> 是 Java 并发包中常用的两种阻塞队列实现，它们都是线程安全的。不过，不过它们之间也存在下面这些区别：</p>

<ul>
  <li>底层实现：<code class="language-plaintext highlighter-rouge">ArrayBlockingQueue</code> 基于数组实现，而 <code class="language-plaintext highlighter-rouge">LinkedBlockingQueue</code> 基于链表实现。</li>
  <li>是否有界：<code class="language-plaintext highlighter-rouge">ArrayBlockingQueue</code> 是有界队列，必须在创建时指定容量大小。<code class="language-plaintext highlighter-rouge">LinkedBlockingQueue</code> 创建时可以不指定容量大小，默认是<code class="language-plaintext highlighter-rouge">Integer.MAX_VALUE</code>，也就是无界的。但也可以指定队列大小，从而成为有界的。</li>
  <li>锁是否分离： <code class="language-plaintext highlighter-rouge">ArrayBlockingQueue</code>中的锁是没有分离的，即生产和消费用的是同一个锁；<code class="language-plaintext highlighter-rouge">LinkedBlockingQueue</code>中的锁是分离的，即生产用的是<code class="language-plaintext highlighter-rouge">putLock</code>，消费是<code class="language-plaintext highlighter-rouge">takeLock</code>，这样可以防止生产者和消费者线程之间的锁争夺。</li>
  <li>内存占用：<code class="language-plaintext highlighter-rouge">ArrayBlockingQueue</code> 需要提前分配数组内存，而 <code class="language-plaintext highlighter-rouge">LinkedBlockingQueue</code> 则是动态分配链表节点内存。这意味着，<code class="language-plaintext highlighter-rouge">ArrayBlockingQueue</code> 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而<code class="language-plaintext highlighter-rouge">LinkedBlockingQueue</code> 则是根据元素的增加而逐渐占用内存空间。</li>
</ul>

<!-- @include: @article-footer.snippet.md -->
