<blockquote>
  <p>本文来自公众号：末读代码的投稿，原文地址：<a href="https://mp.weixin.qq.com/s/AHWzboztt53ZfFZmsSnMSw">https://mp.weixin.qq.com/s/AHWzboztt53ZfFZmsSnMSw</a> 。</p>
</blockquote>

<p>上一篇文章介绍了 HashMap 源码，反响不错，也有很多同学发表了自己的观点，这次又来了，这次是 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 了，作为线程安全的 HashMap ，它的使用频率也是很高。那么它的存储结构和实现原理是怎么样的呢？</p>

<h2 id="1-concurrenthashmap-17">1. ConcurrentHashMap 1.7</h2>

<h3 id="1-存储结构">1. 存储结构</h3>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/java7_concurrenthashmap.png" alt="Java 7 ConcurrentHashMap 存储结构" /></p>

<p>Java 7 中 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 的存储结构如上图，<code class="language-plaintext highlighter-rouge">ConcurrnetHashMap</code> 由很多个 <code class="language-plaintext highlighter-rouge">Segment</code> 组合，而每一个 <code class="language-plaintext highlighter-rouge">Segment</code> 是一个类似于 <code class="language-plaintext highlighter-rouge">HashMap</code> 的结构，所以每一个 <code class="language-plaintext highlighter-rouge">HashMap</code> 的内部可以进行扩容。但是 <code class="language-plaintext highlighter-rouge">Segment</code> 的个数一旦<strong>初始化就不能改变</strong>，默认 <code class="language-plaintext highlighter-rouge">Segment</code> 的个数是 16 个，你也可以认为 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 默认支持最多 16 个线程并发。</p>

<h3 id="2-初始化">2. 初始化</h3>

<p>通过 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 的无参构造探寻 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 的初始化流程。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cm">/**
     * Creates a new, empty map with a default initial capacity (16),
     * load factor (0.75) and concurrencyLevel (16).
     */</span>
    <span class="kd">public</span> <span class="nf">ConcurrentHashMap</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="no">DEFAULT_INITIAL_CAPACITY</span><span class="o">,</span> <span class="no">DEFAULT_LOAD_FACTOR</span><span class="o">,</span> <span class="no">DEFAULT_CONCURRENCY_LEVEL</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>无参构造中调用了有参构造，传入了三个参数的默认值，他们的值是。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cm">/**
     * 默认初始化容量
     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">DEFAULT_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="mi">16</span><span class="o">;</span>

    <span class="cm">/**
     * 默认负载因子
     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">float</span> <span class="no">DEFAULT_LOAD_FACTOR</span> <span class="o">=</span> <span class="mf">0.75f</span><span class="o">;</span>

    <span class="cm">/**
     * 默认并发级别
     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">DEFAULT_CONCURRENCY_LEVEL</span> <span class="o">=</span> <span class="mi">16</span><span class="o">;</span>
</code></pre></div></div>

<p>接着看下这个有参构造函数的内部实现逻辑。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nf">ConcurrentHashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">,</span><span class="kt">float</span> <span class="n">loadFactor</span><span class="o">,</span> <span class="kt">int</span> <span class="n">concurrencyLevel</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 参数校验</span>
    <span class="k">if</span> <span class="o">(!(</span><span class="n">loadFactor</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">||</span> <span class="n">initialCapacity</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">concurrencyLevel</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
    <span class="c1">// 校验并发级别大小，大于 1&lt;&lt;16，重置为 65536</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">concurrencyLevel</span> <span class="o">&gt;</span> <span class="no">MAX_SEGMENTS</span><span class="o">)</span>
        <span class="n">concurrencyLevel</span> <span class="o">=</span> <span class="no">MAX_SEGMENTS</span><span class="o">;</span>
    <span class="c1">// Find power-of-two sizes best matching arguments</span>
    <span class="c1">// 2的多少次方</span>
    <span class="kt">int</span> <span class="n">sshift</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">ssize</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="c1">// 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">ssize</span> <span class="o">&lt;</span> <span class="n">concurrencyLevel</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">++</span><span class="n">sshift</span><span class="o">;</span>
        <span class="n">ssize</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 记录段偏移量</span>
    <span class="k">this</span><span class="o">.</span><span class="na">segmentShift</span> <span class="o">=</span> <span class="mi">32</span> <span class="o">-</span> <span class="n">sshift</span><span class="o">;</span>
    <span class="c1">// 记录段掩码</span>
    <span class="k">this</span><span class="o">.</span><span class="na">segmentMask</span> <span class="o">=</span> <span class="n">ssize</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="c1">// 设置容量</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&gt;</span> <span class="no">MAXIMUM_CAPACITY</span><span class="o">)</span>
        <span class="n">initialCapacity</span> <span class="o">=</span> <span class="no">MAXIMUM_CAPACITY</span><span class="o">;</span>
    <span class="c1">// c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">initialCapacity</span> <span class="o">/</span> <span class="n">ssize</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">ssize</span> <span class="o">&lt;</span> <span class="n">initialCapacity</span><span class="o">)</span>
        <span class="o">++</span><span class="n">c</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">cap</span> <span class="o">=</span> <span class="no">MIN_SEGMENT_TABLE_CAPACITY</span><span class="o">;</span>
    <span class="c1">//Segment 中的类似于 HashMap 的容量至少是2或者2的倍数</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">cap</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">)</span>
        <span class="n">cap</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="c1">// create segments and segments[0]</span>
    <span class="c1">// 创建 Segment 数组，设置 segments[0]</span>
    <span class="nc">Segment</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">s0</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Segment</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;(</span><span class="n">loadFactor</span><span class="o">,</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">cap</span> <span class="o">*</span> <span class="n">loadFactor</span><span class="o">),</span>
                         <span class="o">(</span><span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="nc">HashEntry</span><span class="o">[</span><span class="n">cap</span><span class="o">]);</span>
    <span class="nc">Segment</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">ss</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Segment</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="nc">Segment</span><span class="o">[</span><span class="n">ssize</span><span class="o">];</span>
    <span class="no">UNSAFE</span><span class="o">.</span><span class="na">putOrderedObject</span><span class="o">(</span><span class="n">ss</span><span class="o">,</span> <span class="no">SBASE</span><span class="o">,</span> <span class="n">s0</span><span class="o">);</span> <span class="c1">// ordered write of segments[0]</span>
    <span class="k">this</span><span class="o">.</span><span class="na">segments</span> <span class="o">=</span> <span class="n">ss</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>总结一下在 Java 7 中 ConcurrentHashMap 的初始化逻辑。</p>

<ol>
  <li>必要参数校验。</li>
  <li>校验并发级别 <code class="language-plaintext highlighter-rouge">concurrencyLevel</code> 大小，如果大于最大值，重置为最大值。无参构造<strong>默认值是 16.</strong></li>
  <li>寻找并发级别 <code class="language-plaintext highlighter-rouge">concurrencyLevel</code> 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</li>
  <li>记录 <code class="language-plaintext highlighter-rouge">segmentShift</code> 偏移量，这个值为【容量 = 2 的 N 次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>.</li>
  <li>记录 <code class="language-plaintext highlighter-rouge">segmentMask</code>，默认是 ssize - 1 = 16 -1 = 15.</li>
  <li><strong>初始化 <code class="language-plaintext highlighter-rouge">segments[0]</code></strong>，<strong>默认大小为 2</strong>，<strong>负载因子 0.75</strong>，<strong>扩容阀值是 2*0.75=1.5</strong>，插入第二个值时才会进行扩容。</li>
</ol>

<h3 id="3-put">3. put</h3>

<p>接着上面的初始化参数继续查看 put 方法源码。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Maps the specified key to the specified value in this table.
 * Neither the key nor the value can be null.
 *
 * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;/tt&gt; method
 * with a key that is equal to the original key.
 *
 * @param key key with which the specified value is to be associated
 * @param value value to be associated with the specified key
 * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or
 *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;
 * @throws NullPointerException if the specified key or value is null
 */</span>
<span class="kd">public</span> <span class="no">V</span> <span class="nf">put</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Segment</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="c1">// hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算</span>
    <span class="c1">// 其实也就是把高4位与segmentMask（1111）做与运算</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">(</span><span class="n">hash</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">segmentShift</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">segmentMask</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Segment</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="no">UNSAFE</span><span class="o">.</span><span class="na">getObject</span>          <span class="c1">// nonvolatile; recheck</span>
         <span class="o">(</span><span class="n">segments</span><span class="o">,</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="no">SSHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="no">SBASE</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">//  in ensureSegment</span>
        <span class="c1">// 如果查找到的 Segment 为空，初始化</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">ensureSegment</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**
 * Returns the segment for the given index, creating it and
 * recording in segment table (via CAS) if not already present.
 *
 * @param k the index
 * @return the segment
 */</span>
<span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
<span class="kd">private</span> <span class="nc">Segment</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">ensureSegment</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="nc">Segment</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">ss</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">segments</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">u</span> <span class="o">=</span> <span class="o">(</span><span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="no">SSHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="no">SBASE</span><span class="o">;</span> <span class="c1">// raw offset</span>
    <span class="nc">Segment</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">seg</span><span class="o">;</span>
    <span class="c1">// 判断 u 位置的 Segment 是否为null</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">seg</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Segment</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="no">UNSAFE</span><span class="o">.</span><span class="na">getObjectVolatile</span><span class="o">(</span><span class="n">ss</span><span class="o">,</span> <span class="n">u</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Segment</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">proto</span> <span class="o">=</span> <span class="n">ss</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// use segment 0 as prototype</span>
        <span class="c1">// 获取0号 segment 里的 HashEntry&lt;K,V&gt; 初始化长度</span>
        <span class="kt">int</span> <span class="n">cap</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="na">table</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的</span>
        <span class="kt">float</span> <span class="n">lf</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="na">loadFactor</span><span class="o">;</span>
        <span class="c1">// 计算扩容阀值</span>
        <span class="kt">int</span> <span class="n">threshold</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">cap</span> <span class="o">*</span> <span class="n">lf</span><span class="o">);</span>
        <span class="c1">// 创建一个 cap 容量的 HashEntry 数组</span>
        <span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="o">(</span><span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="nc">HashEntry</span><span class="o">[</span><span class="n">cap</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">seg</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Segment</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="no">UNSAFE</span><span class="o">.</span><span class="na">getObjectVolatile</span><span class="o">(</span><span class="n">ss</span><span class="o">,</span> <span class="n">u</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// recheck</span>
            <span class="c1">// 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作</span>
            <span class="nc">Segment</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Segment</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;(</span><span class="n">lf</span><span class="o">,</span> <span class="n">threshold</span><span class="o">,</span> <span class="n">tab</span><span class="o">);</span>
            <span class="c1">// 自旋检查 u 位置的 Segment 是否为null</span>
            <span class="k">while</span> <span class="o">((</span><span class="n">seg</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Segment</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="no">UNSAFE</span><span class="o">.</span><span class="na">getObjectVolatile</span><span class="o">(</span><span class="n">ss</span><span class="o">,</span> <span class="n">u</span><span class="o">))</span>
                   <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 使用CAS 赋值，只会成功一次</span>
                <span class="k">if</span> <span class="o">(</span><span class="no">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="n">ss</span><span class="o">,</span> <span class="n">u</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">seg</span> <span class="o">=</span> <span class="n">s</span><span class="o">))</span>
                    <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">seg</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>上面的源码分析了 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 在 put 一个数据时的处理流程，下面梳理下具体流程。</p>

<ol>
  <li>
    <p>计算要 put 的 key 的位置，获取指定位置的 <code class="language-plaintext highlighter-rouge">Segment</code>。</p>
  </li>
  <li>
    <p>如果指定位置的 <code class="language-plaintext highlighter-rouge">Segment</code> 为空，则初始化这个 <code class="language-plaintext highlighter-rouge">Segment</code>.</p>

    <p><strong>初始化 Segment 流程：</strong></p>

    <ol>
      <li>检查计算得到的位置的 <code class="language-plaintext highlighter-rouge">Segment</code> 是否为 null.</li>
      <li>为 null 继续初始化，使用 <code class="language-plaintext highlighter-rouge">Segment[0]</code> 的容量和负载因子创建一个 <code class="language-plaintext highlighter-rouge">HashEntry</code> 数组。</li>
      <li>再次检查计算得到的指定位置的 <code class="language-plaintext highlighter-rouge">Segment</code> 是否为 null.</li>
      <li>使用创建的 <code class="language-plaintext highlighter-rouge">HashEntry</code> 数组初始化这个 Segment.</li>
      <li>自旋判断计算得到的指定位置的 <code class="language-plaintext highlighter-rouge">Segment</code> 是否为 null，使用 CAS 在这个位置赋值为 <code class="language-plaintext highlighter-rouge">Segment</code>.</li>
    </ol>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Segment.put</code> 插入 key,value 值。</p>
  </li>
</ol>

<p>上面探究了获取 <code class="language-plaintext highlighter-rouge">Segment</code> 段和初始化 <code class="language-plaintext highlighter-rouge">Segment</code> 段的操作。最后一行的 <code class="language-plaintext highlighter-rouge">Segment</code> 的 put 方法还没有查看，继续分析。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="no">V</span> <span class="nf">put</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">onlyIfAbsent</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span>
    <span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">tryLock</span><span class="o">()</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">scanAndLockForPut</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
    <span class="no">V</span> <span class="n">oldValue</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
        <span class="c1">// 计算要put的数据位置</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">;</span>
        <span class="c1">// CAS 获取 index 坐标的值</span>
        <span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">first</span> <span class="o">=</span> <span class="n">entryAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">index</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">first</span><span class="o">;;)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span>
                <span class="no">K</span> <span class="n">k</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span>
                    <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">)))</span> <span class="o">{</span>
                    <span class="n">oldValue</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">onlyIfAbsent</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
                        <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">node</span><span class="o">.</span><span class="na">setNext</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
                <span class="k">else</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">first</span><span class="o">);</span>
                <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="c1">// 容量大于扩容阀值，小于最大容量，进行扩容</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="o">&amp;&amp;</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="no">MAXIMUM_CAPACITY</span><span class="o">)</span>
                    <span class="n">rehash</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
                <span class="k">else</span>
                    <span class="c1">// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span>
                    <span class="n">setEntryAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">index</span><span class="o">,</span> <span class="n">node</span><span class="o">);</span>
                <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
                <span class="n">oldValue</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">unlock</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>由于 <code class="language-plaintext highlighter-rouge">Segment</code> 继承了 <code class="language-plaintext highlighter-rouge">ReentrantLock</code>，所以 <code class="language-plaintext highlighter-rouge">Segment</code> 内部可以很方便的获取锁，put 流程就用到了这个功能。</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">tryLock()</code> 获取锁，获取不到使用 <strong><code class="language-plaintext highlighter-rouge">scanAndLockForPut</code></strong> 方法继续获取。</p>
  </li>
  <li>
    <p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 <code class="language-plaintext highlighter-rouge">HashEntry</code> 。</p>
  </li>
  <li>
    <p>遍历 put 新元素，为什么要遍历？因为这里获取的 <code class="language-plaintext highlighter-rouge">HashEntry</code> 可能是一个空元素，也可能是链表已存在，所以要区别对待。</p>

    <p>如果这个位置上的 <strong><code class="language-plaintext highlighter-rouge">HashEntry</code> 不存在</strong>：</p>

    <ol>
      <li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li>
      <li>直接头插法插入。</li>
    </ol>

    <p>如果这个位置上的 <strong><code class="language-plaintext highlighter-rouge">HashEntry</code> 存在</strong>：</p>

    <ol>
      <li>判断链表当前元素 key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值</li>
      <li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。
        <ol>
          <li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li>
          <li>直接链表头插法插入。</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>
    <p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null.</p>
  </li>
</ol>

<p>这里面的第一步中的 <code class="language-plaintext highlighter-rouge">scanAndLockForPut</code> 操作这里没有介绍，这个方法做的操作就是不断的自旋 <code class="language-plaintext highlighter-rouge">tryLock()</code> 获取锁。当自旋次数大于指定次数时，使用 <code class="language-plaintext highlighter-rouge">lock()</code> 阻塞获取锁。在自旋时顺表获取下 hash 位置的 <code class="language-plaintext highlighter-rouge">HashEntry</code>。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">scanAndLockForPut</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">first</span> <span class="o">=</span> <span class="n">entryForHash</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
    <span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
    <span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">retries</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// negative while locating node</span>
    <span class="c1">// 自旋获取锁</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">tryLock</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">;</span> <span class="c1">// to recheck first below</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">retries</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">// speculatively create node</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
                <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">))</span>
                <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(++</span><span class="n">retries</span> <span class="o">&gt;</span> <span class="no">MAX_SCAN_RETRIES</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 自旋达到指定次数后，阻塞等到只到获取到锁</span>
            <span class="n">lock</span><span class="o">();</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">retries</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
                 <span class="o">(</span><span class="n">f</span> <span class="o">=</span> <span class="n">entryForHash</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">hash</span><span class="o">))</span> <span class="o">!=</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">first</span> <span class="o">=</span> <span class="n">f</span><span class="o">;</span> <span class="c1">// re-traverse if entry changed</span>
            <span class="n">retries</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
<span class="o">}</span>

</code></pre></div></div>

<h3 id="4-扩容-rehash">4. 扩容 rehash</h3>

<p><code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 <code class="language-plaintext highlighter-rouge">index+ oldSize</code>，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">rehash</span><span class="o">(</span><span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">oldTable</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
    <span class="c1">// 老容量</span>
    <span class="kt">int</span> <span class="n">oldCapacity</span> <span class="o">=</span> <span class="n">oldTable</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="c1">// 新容量，扩大两倍</span>
    <span class="kt">int</span> <span class="n">newCapacity</span> <span class="o">=</span> <span class="n">oldCapacity</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">;</span>
    <span class="c1">// 新的扩容阀值</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">newCapacity</span> <span class="o">*</span> <span class="n">loadFactor</span><span class="o">);</span>
    <span class="c1">// 创建新的数组</span>
    <span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">newTable</span> <span class="o">=</span> <span class="o">(</span><span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="nc">HashEntry</span><span class="o">[</span><span class="n">newCapacity</span><span class="o">];</span>
    <span class="c1">// 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span>
    <span class="kt">int</span> <span class="n">sizeMask</span> <span class="o">=</span> <span class="n">newCapacity</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oldCapacity</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="c1">// 遍历老数组</span>
        <span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">oldTable</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="c1">// 计算新的位置，新的位置只可能是不变或者是老的位置+老的容量。</span>
            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="n">sizeMask</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>   <span class="c1">//  Single node on list</span>
                <span class="c1">// 如果当前位置还不是链表，只是一个元素，直接赋值</span>
                <span class="n">newTable</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
            <span class="k">else</span> <span class="o">{</span> <span class="c1">// Reuse consecutive sequence at same slot</span>
                <span class="c1">// 如果是链表了</span>
                <span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">lastRun</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                <span class="kt">int</span> <span class="n">lastIdx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">;</span>
                <span class="c1">// 新的位置只可能是不变或者是老的位置+老的容量。</span>
                <span class="c1">// 遍历结束后，lastRun 后面的元素位置都是相同的</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">last</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span> <span class="n">last</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">last</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="n">sizeMask</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">!=</span> <span class="n">lastIdx</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">lastIdx</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
                        <span class="n">lastRun</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="c1">// ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span>
                <span class="n">newTable</span><span class="o">[</span><span class="n">lastIdx</span><span class="o">]</span> <span class="o">=</span> <span class="n">lastRun</span><span class="o">;</span>
                <span class="c1">// Clone remaining nodes</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">lastRun</span><span class="o">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 遍历剩余元素，头插法到指定 k 位置。</span>
                    <span class="no">V</span> <span class="n">v</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
                    <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">hash</span><span class="o">;</span>
                    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">h</span> <span class="o">&amp;</span> <span class="n">sizeMask</span><span class="o">;</span>
                    <span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">newTable</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
                    <span class="n">newTable</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;(</span><span class="n">h</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 头插法插入新的节点</span>
    <span class="kt">int</span> <span class="n">nodeIndex</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="n">sizeMask</span><span class="o">;</span> <span class="c1">// add the new node</span>
    <span class="n">node</span><span class="o">.</span><span class="na">setNext</span><span class="o">(</span><span class="n">newTable</span><span class="o">[</span><span class="n">nodeIndex</span><span class="o">]);</span>
    <span class="n">newTable</span><span class="o">[</span><span class="n">nodeIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">newTable</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>有些同学可能会对最后的两个 for 循环有疑惑，这里第一个 for 是为了寻找这样一个节点，这个节点后面的所有 next 节点的新位置都是相同的。然后把这个作为一个链表赋值到新位置。第二个 for 循环是为了把剩余的元素通过头插法插入到指定位置链表。这样实现的原因可能是基于概率统计，有深入研究的同学可以发表下意见。</p>

<h3 id="5-get">5. get</h3>

<p>到这里就很简单了，get 方法只需要两步即可。</p>

<ol>
  <li>计算得到 key 的存放位置。</li>
  <li>遍历指定位置查找相同 key 的 value 值。</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="no">V</span> <span class="nf">get</span><span class="o">(</span><span class="nc">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Segment</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">;</span> <span class="c1">// manually integrate access methods to reduce overhead</span>
    <span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="kt">long</span> <span class="n">u</span> <span class="o">=</span> <span class="o">(((</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">segmentShift</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">segmentMask</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="no">SSHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="no">SBASE</span><span class="o">;</span>
    <span class="c1">// 计算得到 key 的存放位置</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Segment</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="no">UNSAFE</span><span class="o">.</span><span class="na">getObjectVolatile</span><span class="o">(</span><span class="n">segments</span><span class="o">,</span> <span class="n">u</span><span class="o">))</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
        <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="nc">HashEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span> <span class="no">UNSAFE</span><span class="o">.</span><span class="na">getObjectVolatile</span>
                 <span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="o">((</span><span class="kt">long</span><span class="o">)(((</span><span class="n">tab</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">h</span><span class="o">))</span> <span class="o">&lt;&lt;</span> <span class="no">TSHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="no">TBASE</span><span class="o">);</span>
             <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 如果是链表，遍历查找到相同 key 的 value。</span>
            <span class="no">K</span> <span class="n">k</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">)))</span>
                <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="2-concurrenthashmap-18">2. ConcurrentHashMap 1.8</h2>

<h3 id="1-存储结构-1">1. 存储结构</h3>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）" /></p>

<p>可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p>

<h3 id="2-初始化-inittable">2. 初始化 initTable</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Initializes table, using the size recorded in sizeCtl.
 */</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="nf">initTable</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span> <span class="kt">int</span> <span class="n">sc</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//　如果 sizeCtl &lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">sc</span> <span class="o">=</span> <span class="n">sizeCtl</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="c1">// 让出 CPU 使用权</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span> <span class="c1">// lost initialization race; just spin</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="no">U</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="no">SIZECTL</span><span class="o">,</span> <span class="n">sc</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">sc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">sc</span> <span class="o">:</span> <span class="no">DEFAULT_CAPACITY</span><span class="o">;</span>
                    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
                    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">nt</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="nc">Node</span><span class="o">&lt;?,?&gt;[</span><span class="n">n</span><span class="o">];</span>
                    <span class="n">table</span> <span class="o">=</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">nt</span><span class="o">;</span>
                    <span class="n">sc</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">2</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="n">sizeCtl</span> <span class="o">=</span> <span class="n">sc</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">tab</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>从源码中可以发现 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code class="language-plaintext highlighter-rouge">sizeCtl</code> （sizeControl 的缩写），它的值决定着当前的初始化状态。</p>

<ol>
  <li>-1 说明正在初始化，其他线程需要自旋等待</li>
  <li>-N 说明 table 正在进行扩容，高 16 位表示扩容的标识戳，低 16 位减 1 为正在进行扩容的线程数</li>
  <li>0 表示 table 初始化大小，如果 table 没有初始化</li>
  <li>&gt;0 表示 table 扩容的阈值，如果 table 已经初始化。</li>
</ol>

<h3 id="3-put-1">3. put</h3>

<p>直接过一遍 put 源码。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="no">V</span> <span class="nf">put</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">putVal</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/** Implementation for put and putIfAbsent */</span>
<span class="kd">final</span> <span class="no">V</span> <span class="nf">putVal</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">onlyIfAbsent</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// key 和 value 不能为空</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NullPointerException</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">spread</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
    <span class="kt">int</span> <span class="n">binCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;;)</span> <span class="o">{</span>
        <span class="c1">// f = 目标位置元素</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">;</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">fh</span><span class="o">;</span><span class="c1">// fh 后面存放目标位置的元素 hash 值</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tab</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="c1">// 数组桶为空，初始化数组桶（自旋+CAS)</span>
            <span class="n">tab</span> <span class="o">=</span> <span class="n">initTable</span><span class="o">();</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">f</span> <span class="o">=</span> <span class="n">tabAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">casTabAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span><span class="k">new</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">)))</span>
                <span class="k">break</span><span class="o">;</span>  <span class="c1">// no lock when adding to empty bin</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">fh</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">hash</span><span class="o">)</span> <span class="o">==</span> <span class="no">MOVED</span><span class="o">)</span>
            <span class="n">tab</span> <span class="o">=</span> <span class="n">helpTransfer</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">f</span><span class="o">);</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="no">V</span> <span class="n">oldVal</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="c1">// 使用 synchronized 加锁加入节点</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">tabAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 说明是链表</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">fh</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">binCount</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                        <span class="c1">// 循环加入新的或者覆盖节点</span>
                        <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">f</span><span class="o">;;</span> <span class="o">++</span><span class="n">binCount</span><span class="o">)</span> <span class="o">{</span>
                            <span class="no">K</span> <span class="n">ek</span><span class="o">;</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                                <span class="o">((</span><span class="n">ek</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span>
                                 <span class="o">(</span><span class="n">ek</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">ek</span><span class="o">))))</span> <span class="o">{</span>
                                <span class="n">oldVal</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
                                <span class="k">if</span> <span class="o">(!</span><span class="n">onlyIfAbsent</span><span class="o">)</span>
                                    <span class="n">e</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
                                <span class="k">break</span><span class="o">;</span>
                            <span class="o">}</span>
                            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                                <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span>
                                                          <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
                                <span class="k">break</span><span class="o">;</span>
                            <span class="o">}</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">f</span> <span class="k">instanceof</span> <span class="nc">TreeBin</span><span class="o">)</span> <span class="o">{</span>
                        <span class="c1">// 红黑树</span>
                        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span>
                        <span class="n">binCount</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
                        <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="o">((</span><span class="nc">TreeBin</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">f</span><span class="o">).</span><span class="na">putTreeVal</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span>
                                                       <span class="n">value</span><span class="o">))</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">oldVal</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
                            <span class="k">if</span> <span class="o">(!</span><span class="n">onlyIfAbsent</span><span class="o">)</span>
                                <span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="no">TREEIFY_THRESHOLD</span><span class="o">)</span>
                    <span class="n">treeifyBin</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">oldVal</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="k">return</span> <span class="n">oldVal</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">addCount</span><span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="n">binCount</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ol>
  <li>
    <p>根据 key 计算出 hashcode 。</p>
  </li>
  <li>
    <p>判断是否需要进行初始化。</p>
  </li>
  <li>
    <p>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p>
  </li>
  <li>
    <p>如果当前位置的 <code class="language-plaintext highlighter-rouge">hashcode == MOVED == -1</code>,则需要进行扩容。</p>
  </li>
  <li>
    <p>如果都不满足，则利用 synchronized 锁写入数据。</p>
  </li>
  <li>
    <p>如果数量大于 <code class="language-plaintext highlighter-rouge">TREEIFY_THRESHOLD</code> 则要执行树化方法，在 <code class="language-plaintext highlighter-rouge">treeifyBin</code> 中会首先判断当前数组长度 ≥64 时才会将链表转换为红黑树。</p>
  </li>
</ol>

<h3 id="4-get">4. get</h3>

<p>get 流程比较简单，直接过一遍源码。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="no">V</span> <span class="nf">get</span><span class="o">(</span><span class="nc">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">,</span> <span class="n">p</span><span class="o">;</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">eh</span><span class="o">;</span> <span class="no">K</span> <span class="n">ek</span><span class="o">;</span>
    <span class="c1">// key 所在的 hash 位置</span>
    <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">spread</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
        <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">tabAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">h</span><span class="o">))</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 如果指定位置元素存在，头结点hash值相同</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">eh</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">hash</span><span class="o">)</span> <span class="o">==</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">ek</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">ek</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">ek</span><span class="o">)))</span>
                <span class="c1">// key hash 值相等，key值相同，直接返回元素 value</span>
                <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">eh</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="c1">// 头结点hash值小于0，说明正在扩容或者是红黑树，find查找</span>
            <span class="k">return</span> <span class="o">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">key</span><span class="o">))</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">:</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 是链表，遍历查找</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">h</span> <span class="o">&amp;&amp;</span>
                <span class="o">((</span><span class="n">ek</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">ek</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">ek</span><span class="o">))))</span>
                <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>总结一下 get 过程：</p>

<ol>
  <li>根据 hash 值计算位置。</li>
  <li>查找到指定位置，如果头节点就是要找的，直接返回它的 value.</li>
  <li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。</li>
  <li>如果是链表，遍历查找之。</li>
</ol>

<p>总结：</p>

<p>总的来说 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 在 Java8 中相对于 Java7 来说变化还是挺大的，</p>

<h2 id="3-总结">3. 总结</h2>

<p>Java7 中 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 <code class="language-plaintext highlighter-rouge">Segment</code> 都是一个类似 <code class="language-plaintext highlighter-rouge">HashMap</code> 数组的结构，它可以扩容，它的冲突会转化为链表。但是 <code class="language-plaintext highlighter-rouge">Segment</code> 的个数一但初始化就不能改变。</p>

<p>Java8 中的 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 使用的 <code class="language-plaintext highlighter-rouge">Synchronized</code> 锁加 CAS 的机制。结构也由 Java7 中的 <strong><code class="language-plaintext highlighter-rouge">Segment</code> 数组 + <code class="language-plaintext highlighter-rouge">HashEntry</code> 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p>

<p>有些同学可能对 <code class="language-plaintext highlighter-rouge">Synchronized</code> 的性能存在疑问，其实 <code class="language-plaintext highlighter-rouge">Synchronized</code> 锁自从引入锁升级策略后，性能不再是问题，有兴趣的同学可以自己了解下 <code class="language-plaintext highlighter-rouge">Synchronized</code> 的<strong>锁升级</strong>。</p>

<!-- @include: @article-footer.snippet.md -->
