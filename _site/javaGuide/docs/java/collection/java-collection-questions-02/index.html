<!-- @include: @article-header.snippet.md -->

<h2 id="map重要">Map（重要）</h2>

<h3 id="hashmap-和-hashtable-的区别">HashMap 和 Hashtable 的区别</h3>

<ul>
  <li><strong>线程是否安全：</strong> <code class="language-plaintext highlighter-rouge">HashMap</code> 是非线程安全的，<code class="language-plaintext highlighter-rouge">Hashtable</code> 是线程安全的,因为 <code class="language-plaintext highlighter-rouge">Hashtable</code> 内部的方法基本都经过<code class="language-plaintext highlighter-rouge">synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 吧！）；</li>
  <li><strong>效率：</strong> 因为线程安全的问题，<code class="language-plaintext highlighter-rouge">HashMap</code> 要比 <code class="language-plaintext highlighter-rouge">Hashtable</code> 效率高一点。另外，<code class="language-plaintext highlighter-rouge">Hashtable</code> 基本被淘汰，不要在代码中使用它；</li>
  <li><strong>对 Null key 和 Null value 的支持：</strong> <code class="language-plaintext highlighter-rouge">HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code class="language-plaintext highlighter-rouge">NullPointerException</code>。</li>
  <li><strong>初始容量大小和每次扩充容量大小的不同：</strong> ① 创建时如果不指定容量初始值，<code class="language-plaintext highlighter-rouge">Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code class="language-plaintext highlighter-rouge">HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 <code class="language-plaintext highlighter-rouge">Hashtable</code> 会直接使用你给定的大小，而 <code class="language-plaintext highlighter-rouge">HashMap</code> 会将其扩充为 2 的幂次方大小（<code class="language-plaintext highlighter-rouge">HashMap</code> 中的<code class="language-plaintext highlighter-rouge">tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code class="language-plaintext highlighter-rouge">HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li>
  <li><strong>底层数据结构：</strong> JDK1.8 以后的 <code class="language-plaintext highlighter-rouge">HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。<code class="language-plaintext highlighter-rouge">Hashtable</code> 没有这样的机制。</li>
  <li><strong>哈希函数的实现</strong>：<code class="language-plaintext highlighter-rouge">HashMap</code> 对哈希值进行了高位和低位的混合扰动处理以减少冲突，而 <code class="language-plaintext highlighter-rouge">Hashtable</code> 直接使用键的 <code class="language-plaintext highlighter-rouge">hashCode()</code> 值。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">HashMap</code> 中带有初始容量的构造函数：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">,</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Illegal initial capacity: "</span> <span class="o">+</span>
                                               <span class="n">initialCapacity</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&gt;</span> <span class="no">MAXIMUM_CAPACITY</span><span class="o">)</span>
            <span class="n">initialCapacity</span> <span class="o">=</span> <span class="no">MAXIMUM_CAPACITY</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">loadFactor</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nc">Float</span><span class="o">.</span><span class="na">isNaN</span><span class="o">(</span><span class="n">loadFactor</span><span class="o">))</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Illegal load factor: "</span> <span class="o">+</span>
                                               <span class="n">loadFactor</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">loadFactor</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">threshold</span> <span class="o">=</span> <span class="n">tableSizeFor</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">);</span>
    <span class="o">}</span>
     <span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">,</span> <span class="no">DEFAULT_LOAD_FACTOR</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>下面这个方法保证了 <code class="language-plaintext highlighter-rouge">HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Returns a power of two size for the given target capacity.
 */</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">tableSizeFor</span><span class="o">(</span><span class="kt">int</span> <span class="n">cap</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">cap</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">2</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">4</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">8</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">16</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="no">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">?</span> <span class="no">MAXIMUM_CAPACITY</span> <span class="o">:</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="hashmap-和-hashset-区别">HashMap 和 HashSet 区别</h3>

<p>如果你看过 <code class="language-plaintext highlighter-rouge">HashSet</code> 源码的话就应该知道：<code class="language-plaintext highlighter-rouge">HashSet</code> 底层就是基于 <code class="language-plaintext highlighter-rouge">HashMap</code> 实现的。（<code class="language-plaintext highlighter-rouge">HashSet</code> 的源码非常非常少，因为除了 <code class="language-plaintext highlighter-rouge">clone()</code>、<code class="language-plaintext highlighter-rouge">writeObject()</code>、<code class="language-plaintext highlighter-rouge">readObject()</code>是 <code class="language-plaintext highlighter-rouge">HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code class="language-plaintext highlighter-rouge">HashMap</code> 中的方法。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><code class="language-plaintext highlighter-rouge">HashMap</code></th>
      <th style="text-align: center"><code class="language-plaintext highlighter-rouge">HashSet</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">实现了 <code class="language-plaintext highlighter-rouge">Map</code> 接口</td>
      <td style="text-align: center">实现 <code class="language-plaintext highlighter-rouge">Set</code> 接口</td>
    </tr>
    <tr>
      <td style="text-align: center">存储键值对</td>
      <td style="text-align: center">仅存储对象</td>
    </tr>
    <tr>
      <td style="text-align: center">调用 <code class="language-plaintext highlighter-rouge">put()</code>向 map 中添加元素</td>
      <td style="text-align: center">调用 <code class="language-plaintext highlighter-rouge">add()</code>方法向 <code class="language-plaintext highlighter-rouge">Set</code> 中添加元素</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">HashMap</code> 使用键（Key）计算 <code class="language-plaintext highlighter-rouge">hashcode</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">HashSet</code> 使用成员对象来计算 <code class="language-plaintext highlighter-rouge">hashcode</code> 值，对于两个对象来说 <code class="language-plaintext highlighter-rouge">hashcode</code> 可能相同，所以<code class="language-plaintext highlighter-rouge">equals()</code>方法用来判断对象的相等性</td>
    </tr>
  </tbody>
</table>

<h3 id="hashmap-和-treemap-区别">HashMap 和 TreeMap 区别</h3>

<p><code class="language-plaintext highlighter-rouge">TreeMap</code> 和<code class="language-plaintext highlighter-rouge">HashMap</code> 都继承自<code class="language-plaintext highlighter-rouge">AbstractMap</code> ，但是需要注意的是<code class="language-plaintext highlighter-rouge">TreeMap</code>它还实现了<code class="language-plaintext highlighter-rouge">NavigableMap</code>接口和<code class="language-plaintext highlighter-rouge">SortedMap</code> 接口。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/treemap_hierarchy.png" alt="TreeMap 继承关系图" /></p>

<p>实现 <code class="language-plaintext highlighter-rouge">NavigableMap</code> 接口让 <code class="language-plaintext highlighter-rouge">TreeMap</code> 有了对集合内元素的搜索的能力。</p>

<p><code class="language-plaintext highlighter-rouge">NavigableMap</code> 接口提供了丰富的方法来探索和操作键值对:</p>

<ol>
  <li><strong>定向搜索</strong>: <code class="language-plaintext highlighter-rouge">ceilingEntry()</code>, <code class="language-plaintext highlighter-rouge">floorEntry()</code>, <code class="language-plaintext highlighter-rouge">higherEntry()</code>和 <code class="language-plaintext highlighter-rouge">lowerEntry()</code> 等方法可以用于定位大于等于、小于等于、严格大于、严格小于给定键的最接近的键值对。</li>
  <li><strong>子集操作</strong>: <code class="language-plaintext highlighter-rouge">subMap()</code>, <code class="language-plaintext highlighter-rouge">headMap()</code>和 <code class="language-plaintext highlighter-rouge">tailMap()</code> 方法可以高效地创建原集合的子集视图，而无需复制整个集合。</li>
  <li><strong>逆序视图</strong>:<code class="language-plaintext highlighter-rouge">descendingMap()</code> 方法返回一个逆序的 <code class="language-plaintext highlighter-rouge">NavigableMap</code> 视图，使得可以反向迭代整个 <code class="language-plaintext highlighter-rouge">TreeMap</code>。</li>
  <li><strong>边界操作</strong>: <code class="language-plaintext highlighter-rouge">firstEntry()</code>, <code class="language-plaintext highlighter-rouge">lastEntry()</code>, <code class="language-plaintext highlighter-rouge">pollFirstEntry()</code>和 <code class="language-plaintext highlighter-rouge">pollLastEntry()</code> 等方法可以方便地访问和移除元素。</li>
</ol>

<p>这些方法都是基于红黑树数据结构的属性实现的，红黑树保持平衡状态，从而保证了搜索操作的时间复杂度为 O(log n)，这让 <code class="language-plaintext highlighter-rouge">TreeMap</code> 成为了处理有序集合搜索问题的强大工具。</p>

<p>实现<code class="language-plaintext highlighter-rouge">SortedMap</code>接口让 <code class="language-plaintext highlighter-rouge">TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @author shuang.kou
 * @createTime 2020年06月15日 17:02:00
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Integer</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">TreeMap</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">treeMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Person</span> <span class="n">person1</span><span class="o">,</span> <span class="nc">Person</span> <span class="n">person2</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">person1</span><span class="o">.</span><span class="na">getAge</span><span class="o">()</span> <span class="o">-</span> <span class="n">person2</span><span class="o">.</span><span class="na">getAge</span><span class="o">();</span>
                <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">treeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="mi">3</span><span class="o">),</span> <span class="s">"person1"</span><span class="o">);</span>
        <span class="n">treeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="mi">18</span><span class="o">),</span> <span class="s">"person2"</span><span class="o">);</span>
        <span class="n">treeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="mi">35</span><span class="o">),</span> <span class="s">"person3"</span><span class="o">);</span>
        <span class="n">treeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="mi">16</span><span class="o">),</span> <span class="s">"person4"</span><span class="o">);</span>
        <span class="n">treeMap</span><span class="o">.</span><span class="na">entrySet</span><span class="o">().</span><span class="na">stream</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">personStringEntry</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">personStringEntry</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
        <span class="o">});</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>输出:</p>

<pre><code class="language-plain">person1
person4
person2
person3
</code></pre>

<p>可以看出，<code class="language-plaintext highlighter-rouge">TreeMap</code> 中的元素已经是按照 <code class="language-plaintext highlighter-rouge">Person</code> 的 age 字段的升序来排列了。</p>

<p>上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 Lambda 表达式实现的方式：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TreeMap</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">treeMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">&lt;&gt;((</span><span class="n">person1</span><span class="o">,</span> <span class="n">person2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">person1</span><span class="o">.</span><span class="na">getAge</span><span class="o">()</span> <span class="o">-</span> <span class="n">person2</span><span class="o">.</span><span class="na">getAge</span><span class="o">();</span>
  <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">});</span>
</code></pre></div></div>

<p><strong>综上，相比于<code class="language-plaintext highlighter-rouge">HashMap</code>来说， <code class="language-plaintext highlighter-rouge">TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p>

<h3 id="hashset-如何检查重复">HashSet 如何检查重复?</h3>

<p>以下内容摘自我的 Java 启蒙书《Head first java》第二版：</p>

<blockquote>
  <p>当你把对象加入<code class="language-plaintext highlighter-rouge">HashSet</code>时，<code class="language-plaintext highlighter-rouge">HashSet</code> 会先计算对象的<code class="language-plaintext highlighter-rouge">hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code class="language-plaintext highlighter-rouge">hashcode</code> 值作比较，如果没有相符的 <code class="language-plaintext highlighter-rouge">hashcode</code>，<code class="language-plaintext highlighter-rouge">HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code class="language-plaintext highlighter-rouge">hashcode</code> 值的对象，这时会调用<code class="language-plaintext highlighter-rouge">equals()</code>方法来检查 <code class="language-plaintext highlighter-rouge">hashcode</code> 相等的对象是否真的相同。如果两者相同，<code class="language-plaintext highlighter-rouge">HashSet</code> 就不会让加入操作成功。</p>
</blockquote>

<p>在 JDK1.8 中，<code class="language-plaintext highlighter-rouge">HashSet</code>的<code class="language-plaintext highlighter-rouge">add()</code>方法只是简单的调用了<code class="language-plaintext highlighter-rouge">HashMap</code>的<code class="language-plaintext highlighter-rouge">put()</code>方法，并且判断了一下返回值以确保是否有重复元素。直接看一下<code class="language-plaintext highlighter-rouge">HashSet</code>中的源码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Returns: true if this set did not already contain the specified element</span>
<span class="c1">// 返回值：当 set 中没有包含 add 的元素时返回真</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">PRESENT</span><span class="o">)==</span><span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>而在<code class="language-plaintext highlighter-rouge">HashMap</code>的<code class="language-plaintext highlighter-rouge">putVal()</code>方法中也能看到如下说明：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Returns : previous value, or null if none</span>
<span class="c1">// 返回值：如果插入位置没有元素返回null，否则返回上一个元素</span>
<span class="kd">final</span> <span class="no">V</span> <span class="nf">putVal</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">onlyIfAbsent</span><span class="o">,</span>
                   <span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>
<span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>也就是说，在 JDK1.8 中，实际上无论<code class="language-plaintext highlighter-rouge">HashSet</code>中是否已经存在了某元素，<code class="language-plaintext highlighter-rouge">HashSet</code>都会直接插入，只是会在<code class="language-plaintext highlighter-rouge">add()</code>方法的返回值处告诉我们插入前是否存在相同元素。</p>

<h3 id="hashmap-的底层实现">HashMap 的底层实现</h3>

<h4 id="jdk18-之前">JDK1.8 之前</h4>

<p>JDK1.8 之前 <code class="language-plaintext highlighter-rouge">HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code class="language-plaintext highlighter-rouge">hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code class="language-plaintext highlighter-rouge">(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>

<p><code class="language-plaintext highlighter-rouge">HashMap</code> 中的扰动函数（<code class="language-plaintext highlighter-rouge">hash</code> 方法）是用来优化哈希值的分布。通过对原始的 <code class="language-plaintext highlighter-rouge">hashCode()</code> 进行额外处理，扰动函数可以减小由于糟糕的 <code class="language-plaintext highlighter-rouge">hashCode()</code> 实现导致的碰撞，从而提高数据的分布均匀性。</p>

<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>

<p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="nc">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">h</span><span class="o">;</span>
      <span class="c1">// key.hashCode()：返回散列值也就是hashcode</span>
      <span class="c1">// ^：按位异或</span>
      <span class="c1">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span>
      <span class="k">return</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">())</span> <span class="o">^</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">16</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="kt">int</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// This function ensures that hashCodes that differ only by</span>
    <span class="c1">// constant multiples at each bit position have a bounded</span>
    <span class="c1">// number of collisions (approximately 8 at default load factor).</span>

    <span class="n">h</span> <span class="o">^=</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">20</span><span class="o">)</span> <span class="o">^</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">12</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">h</span> <span class="o">^</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">7</span><span class="o">)</span> <span class="o">^</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">4</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>

<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/jdk1.7_hashmap.png" alt="jdk1.8 之前的内部结构-HashMap" /></p>

<h4 id="jdk18-之后">JDK1.8 之后</h4>

<p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/jdk1.8_hashmap.png" alt="jdk1.8之后的内部结构-HashMap" /></p>

<blockquote>
  <p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>
</blockquote>

<p>我们来结合源码分析一下 <code class="language-plaintext highlighter-rouge">HashMap</code> 链表到红黑树的转换。</p>

<p><strong>1、 <code class="language-plaintext highlighter-rouge">putVal</code> 方法中执行链表转红黑树的判断逻辑。</strong></p>

<p>链表的长度大于 8 的时候，就执行 <code class="language-plaintext highlighter-rouge">treeifyBin</code> （转换红黑树）的逻辑。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 遍历链表</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">binCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">;</span> <span class="o">++</span><span class="n">binCount</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 遍历到链表最后一个节点</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="c1">// 如果链表元素个数大于TREEIFY_THRESHOLD（8）</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="no">TREEIFY_THRESHOLD</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">// -1 for 1st</span>
            <span class="c1">// 红黑树转换（并不会直接转换成红黑树）</span>
            <span class="n">treeifyBin</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
        <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>2、<code class="language-plaintext highlighter-rouge">treeifyBin</code> 方法中判断是否真的转换为红黑树。</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kt">void</span> <span class="nf">treeifyBin</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">index</span><span class="o">;</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
    <span class="c1">// 判断当前数组的长度是否小于 64</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tab</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">&lt;</span> <span class="no">MIN_TREEIFY_CAPACITY</span><span class="o">)</span>
        <span class="c1">// 如果当前数组的长度小于 64，那么会选择先进行数组扩容</span>
        <span class="n">resize</span><span class="o">();</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">index</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 否则才将列表转换为红黑树</span>

        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">hd</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">tl</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">do</span> <span class="o">{</span>
            <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">replacementTreeNode</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tl</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">hd</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">p</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">tl</span><span class="o">;</span>
                <span class="n">tl</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">tl</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">hd</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">hd</span><span class="o">.</span><span class="na">treeify</span><span class="o">(</span><span class="n">tab</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树。</p>

<h3 id="hashmap-的长度为什么是-2-的幂次方">HashMap 的长度为什么是 2 的幂次方</h3>

<p>为了让 <code class="language-plaintext highlighter-rouge">HashMap</code> 存取高效并减少碰撞，我们需要确保数据尽量均匀分布。哈希值在 Java 中通常使用 <code class="language-plaintext highlighter-rouge">int</code> 表示，其范围是 <code class="language-plaintext highlighter-rouge">-2147483648 ~ 2147483647</code>前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但是，问题是一个 40 亿长度的数组，内存是放不下的。所以，这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。</p>

<p><strong>这个算法应该如何设计呢？</strong></p>

<p>我们首先可能会想到采用 % 取余的操作来实现。但是，重点来了：“<strong>取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作</strong>（也就是说 <code class="language-plaintext highlighter-rouge">hash%length==hash&amp;(length-1)</code> 的前提是 length 是 2 的 n 次方）。” 并且，<strong>采用二进制位操作 &amp; 相对于 % 能够提高运算效率</strong>。</p>

<p>除了上面所说的位运算比取余效率高之外，我觉得更重要的一个原因是：<strong>长度是 2 的幂次方，可以让 <code class="language-plaintext highlighter-rouge">HashMap</code> 在扩容的时候更均匀</strong>。例如:</p>

<ul>
  <li>length = 8 时，length - 1 = 7 的二进制位<code class="language-plaintext highlighter-rouge">0111</code></li>
  <li>length = 16 时，length - 1 = 15 的二进制位<code class="language-plaintext highlighter-rouge">1111</code></li>
</ul>

<p>这时候原本存在 <code class="language-plaintext highlighter-rouge">HashMap</code> 中的元素计算新的数组位置时 <code class="language-plaintext highlighter-rouge">hash&amp;(length-1)</code>，取决 hash 的第四个二进制位（从右数），会出现两种情况：</p>

<ol>
  <li>第四个二进制位为 0，数组位置不变，也就是说当前元素在新数组和旧数组的位置相同。</li>
  <li>第四个二进制位为 1，数组位置在新数组扩容之后的那一部分。</li>
</ol>

<p>这里列举一个例子：</p>

<pre><code class="language-plain">假设有一个元素的哈希值为 10101100

旧数组元素位置计算：
hash        = 10101100
length - 1  = 00000111
&amp; -----------------
index       = 00000100  (4)

新数组元素位置计算：
hash        = 10101100
length - 1  = 00001111
&amp; -----------------
index       = 00001100  (12)

看第四位（从右数）：
1.高位为 0：位置不变。
2.高位为 1：移动到新位置（原索引位置+原容量）。
</code></pre>

<p>⚠️注意：这里列举的场景看的是第四个二进制位，更准确点来说看的是高位（从右数），例如 <code class="language-plaintext highlighter-rouge">length = 32</code> 时，<code class="language-plaintext highlighter-rouge">length - 1 = 31</code>，二进制为 <code class="language-plaintext highlighter-rouge">11111</code>，这里看的就是第五个二进制位。</p>

<p>也就是说扩容之后，在旧数组元素 hash 值比较均匀（至于 hash 值均不均匀，取决于前面讲的对象的 <code class="language-plaintext highlighter-rouge">hashcode()</code> 方法和扰动函数）的情况下，新数组元素也会被分配的比较均匀，最好的情况是会有一半在新数组的前半部分，一半在新数组后半部分。</p>

<p>这样也使得扩容机制变得简单和高效，扩容后只需检查哈希值高位的变化来决定元素的新位置，要么位置不变（高位为 0），要么就是移动到新位置（高位为 1，原索引位置+原容量）。</p>

<p>最后，简单总结一下 <code class="language-plaintext highlighter-rouge">HashMap</code> 的长度是 2 的幂次方的原因：</p>

<ol>
  <li>位运算效率更高：位运算(&amp;)比取余运算(%)更高效。当长度为 2 的幂次方时，<code class="language-plaintext highlighter-rouge">hash % length</code> 等价于 <code class="language-plaintext highlighter-rouge">hash &amp; (length - 1)</code>。</li>
  <li>可以更好地保证哈希值的均匀分布：扩容之后，在旧数组元素 hash 值比较均匀的情况下，新数组元素也会被分配的比较均匀，最好的情况是会有一半在新数组的前半部分，一半在新数组后半部分。</li>
  <li>扩容机制变得简单和高效：扩容后只需检查哈希值高位的变化来决定元素的新位置，要么位置不变（高位为 0），要么就是移动到新位置（高位为 1，原索引位置+原容量）。</li>
</ol>

<h3 id="hashmap-多线程操作导致死循环问题">HashMap 多线程操作导致死循环问题</h3>

<p>JDK1.7 及之前版本的 <code class="language-plaintext highlighter-rouge">HashMap</code> 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</p>

<p>为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 <code class="language-plaintext highlighter-rouge">HashMap</code>，因为多线程下使用 <code class="language-plaintext highlighter-rouge">HashMap</code> 还是会存在数据覆盖的问题。并发环境下，推荐使用 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 。</p>

<p>一般面试中这样介绍就差不多，不需要记各种细节，个人觉得也没必要记。如果想要详细了解 <code class="language-plaintext highlighter-rouge">HashMap</code> 扩容导致死循环问题，可以看看耗子叔的这篇文章：<a href="https://coolshell.cn/articles/9606.html">Java HashMap 的死循环</a>。</p>

<h3 id="hashmap-为什么线程不安全">HashMap 为什么线程不安全？</h3>

<p>JDK1.7 及之前版本，在多线程环境下，<code class="language-plaintext highlighter-rouge">HashMap</code> 扩容时会造成死循环和数据丢失的问题。</p>

<p>数据丢失这个在 JDK1.7 和 JDK 1.8 中都存在，这里以 JDK 1.8 为例进行介绍。</p>

<p>JDK 1.8 后，在 <code class="language-plaintext highlighter-rouge">HashMap</code> 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 <code class="language-plaintext highlighter-rouge">HashMap</code> 的 <code class="language-plaintext highlighter-rouge">put</code> 操作会导致线程不安全，具体来说会有数据覆盖的风险。</p>

<p>举个例子：</p>

<ul>
  <li>两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。</li>
  <li>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。</li>
  <li>随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="no">V</span> <span class="nf">put</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">putVal</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">final</span> <span class="no">V</span> <span class="nf">putVal</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">onlyIfAbsent</span><span class="o">,</span>
                   <span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// ...</span>
    <span class="c1">// 判断是否出现 hash 碰撞</span>
    <span class="c1">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="c1">// 桶中已经存在元素（处理hash冲突）</span>
    <span class="k">else</span> <span class="o">{</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>还有一种情况是这两个线程同时 <code class="language-plaintext highlighter-rouge">put</code> 操作导致 <code class="language-plaintext highlighter-rouge">size</code> 的值不正确，进而导致数据覆盖的问题：</p>

<ol>
  <li>线程 1 执行 <code class="language-plaintext highlighter-rouge">if(++size &gt; threshold)</code> 判断时，假设获得 <code class="language-plaintext highlighter-rouge">size</code> 的值为 10，由于时间片耗尽挂起。</li>
  <li>线程 2 也执行 <code class="language-plaintext highlighter-rouge">if(++size &gt; threshold)</code> 判断，获得 <code class="language-plaintext highlighter-rouge">size</code> 的值也为 10，并将元素插入到该桶位中，并将 <code class="language-plaintext highlighter-rouge">size</code> 的值更新为 11。</li>
  <li>随后，线程 1 获得时间片，它也将元素放入桶位中，并将 size 的值更新为 11。</li>
  <li>线程 1、2 都执行了一次 <code class="language-plaintext highlighter-rouge">put</code> 操作，但是 <code class="language-plaintext highlighter-rouge">size</code> 的值只增加了 1，也就导致实际上只有一个元素被添加到了 <code class="language-plaintext highlighter-rouge">HashMap</code> 中。</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="no">V</span> <span class="nf">put</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">putVal</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">final</span> <span class="no">V</span> <span class="nf">putVal</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">onlyIfAbsent</span><span class="o">,</span>
                   <span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// ...</span>
    <span class="c1">// 实际大小大于阈值则扩容</span>
    <span class="k">if</span> <span class="o">(++</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
        <span class="n">resize</span><span class="o">();</span>
    <span class="c1">// 插入后回调</span>
    <span class="n">afterNodeInsertion</span><span class="o">(</span><span class="n">evict</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="hashmap-常见的遍历方式">HashMap 常见的遍历方式?</h3>

<p><a href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw">HashMap 的 7 种遍历方式与性能分析！</a></p>

<p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/1411">issue#1411</a>）</strong>：</p>

<p>这篇文章对于 parallelStream 遍历方式的性能分析有误，先说结论：<strong>存在阻塞时 parallelStream 性能最高, 非阻塞时 parallelStream 性能最低</strong> 。</p>

<p>当遍历不存在阻塞时, parallelStream 的性能是最低的：</p>

<pre><code class="language-plain">Benchmark               Mode  Cnt     Score      Error  Units
Test.entrySet           avgt    5   288.651 ±   10.536  ns/op
Test.keySet             avgt    5   584.594 ±   21.431  ns/op
Test.lambda             avgt    5   221.791 ±   10.198  ns/op
Test.parallelStream     avgt    5  6919.163 ± 1116.139  ns/op
</code></pre>

<p>加入阻塞代码<code class="language-plaintext highlighter-rouge">Thread.sleep(10)</code>后, parallelStream 的性能才是最高的:</p>

<pre><code class="language-plain">Benchmark               Mode  Cnt           Score          Error  Units
Test.entrySet           avgt    5  1554828440.000 ± 23657748.653  ns/op
Test.keySet             avgt    5  1550612500.000 ±  6474562.858  ns/op
Test.lambda             avgt    5  1551065180.000 ± 19164407.426  ns/op
Test.parallelStream     avgt    5   186345456.667 ±  3210435.590  ns/op
</code></pre>

<h3 id="concurrenthashmap-和-hashtable-的区别">ConcurrentHashMap 和 Hashtable 的区别</h3>

<p><code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 和 <code class="language-plaintext highlighter-rouge">Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>

<ul>
  <li><strong>底层数据结构：</strong> JDK1.7 的 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code class="language-plaintext highlighter-rouge">HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code class="language-plaintext highlighter-rouge">Hashtable</code> 和 JDK1.8 之前的 <code class="language-plaintext highlighter-rouge">HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
  <li><strong>实现线程安全的方式（重要）：</strong>
    <ul>
      <li>在 JDK1.7 的时候，<code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code class="language-plaintext highlighter-rouge">Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li>
      <li>到了 JDK1.8 的时候，<code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 已经摒弃了 <code class="language-plaintext highlighter-rouge">Segment</code> 的概念，而是直接用 <code class="language-plaintext highlighter-rouge">Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code class="language-plaintext highlighter-rouge">synchronized</code> 和 CAS 来操作。（JDK1.6 以后 <code class="language-plaintext highlighter-rouge">synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code class="language-plaintext highlighter-rouge">HashMap</code>，虽然在 JDK1.8 中还能看到 <code class="language-plaintext highlighter-rouge">Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>
      <li><strong><code class="language-plaintext highlighter-rouge">Hashtable</code>(同一把锁)</strong> :使用 <code class="language-plaintext highlighter-rouge">synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
    </ul>
  </li>
</ul>

<p>下面，我们再来看看两者底层数据结构的对比图。</p>

<p><strong>Hashtable</strong> :</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/jdk1.7_hashmap.png" alt="Hashtable 的内部结构" /></p>

<p style="text-align:right;font-size:13px;color:gray">https://www.cnblogs.com/chengxiao/p/6842045.html&gt;</p>

<p><strong>JDK1.7 的 ConcurrentHashMap</strong>：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/java7_concurrenthashmap.png" alt="Java7 ConcurrentHashMap 存储结构" /></p>

<p><code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 是由 <code class="language-plaintext highlighter-rouge">Segment</code> 数组结构和 <code class="language-plaintext highlighter-rouge">HashEntry</code> 数组结构组成。</p>

<p><code class="language-plaintext highlighter-rouge">Segment</code> 数组中的每个元素包含一个 <code class="language-plaintext highlighter-rouge">HashEntry</code> 数组，每个 <code class="language-plaintext highlighter-rouge">HashEntry</code> 数组属于链表结构。</p>

<p><strong>JDK1.8 的 ConcurrentHashMap</strong>：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构" /></p>

<p>JDK1.8 的 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 不再是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 <strong><code class="language-plaintext highlighter-rouge">TreeNode</code></strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p>

<p><code class="language-plaintext highlighter-rouge">TreeNode</code>是存储红黑树节点，被<code class="language-plaintext highlighter-rouge">TreeBin</code>包装。<code class="language-plaintext highlighter-rouge">TreeBin</code>通过<code class="language-plaintext highlighter-rouge">root</code>属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 中<code class="language-plaintext highlighter-rouge">TreeBin</code>通过<code class="language-plaintext highlighter-rouge">waiter</code>属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">TreeBin</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">root</span><span class="o">;</span>
        <span class="kd">volatile</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">first</span><span class="o">;</span>
        <span class="kd">volatile</span> <span class="nc">Thread</span> <span class="n">waiter</span><span class="o">;</span>
        <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">lockState</span><span class="o">;</span>
        <span class="c1">// values for lockState</span>
        <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">WRITER</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// set while holding write lock</span>
        <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">WAITER</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="c1">// set when waiting for write lock</span>
        <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">READER</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span> <span class="c1">// increment value for setting read lock</span>
<span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="concurrenthashmap-线程安全的具体实现方式底层具体实现">ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</h3>

<h4 id="jdk18-之前-1">JDK1.8 之前</h4>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/java7_concurrenthashmap.png" alt="Java7 ConcurrentHashMap 存储结构" /></p>

<p>首先将数据分为一段一段（这个“段”就是 <code class="language-plaintext highlighter-rouge">Segment</code>）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>

<p><strong><code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 是由 <code class="language-plaintext highlighter-rouge">Segment</code> 数组结构和 <code class="language-plaintext highlighter-rouge">HashEntry</code> 数组结构组成</strong>。</p>

<p><code class="language-plaintext highlighter-rouge">Segment</code> 继承了 <code class="language-plaintext highlighter-rouge">ReentrantLock</code>,所以 <code class="language-plaintext highlighter-rouge">Segment</code> 是一种可重入锁，扮演锁的角色。<code class="language-plaintext highlighter-rouge">HashEntry</code> 用于存储键值对数据。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">class</span> <span class="nc">Segment</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">ReentrantLock</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<p>一个 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 里包含一个 <code class="language-plaintext highlighter-rouge">Segment</code> 数组，<code class="language-plaintext highlighter-rouge">Segment</code> 的个数一旦<strong>初始化就不能改变</strong>。 <code class="language-plaintext highlighter-rouge">Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。</p>

<p><code class="language-plaintext highlighter-rouge">Segment</code> 的结构和 <code class="language-plaintext highlighter-rouge">HashMap</code> 类似，是一种数组和链表结构，一个 <code class="language-plaintext highlighter-rouge">Segment</code> 包含一个 <code class="language-plaintext highlighter-rouge">HashEntry</code> 数组，每个 <code class="language-plaintext highlighter-rouge">HashEntry</code> 是一个链表结构的元素，每个 <code class="language-plaintext highlighter-rouge">Segment</code> 守护着一个 <code class="language-plaintext highlighter-rouge">HashEntry</code> 数组里的元素，当对 <code class="language-plaintext highlighter-rouge">HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code class="language-plaintext highlighter-rouge">Segment</code> 的锁。也就是说，对同一 <code class="language-plaintext highlighter-rouge">Segment</code> 的并发写入会被阻塞，不同 <code class="language-plaintext highlighter-rouge">Segment</code> 的写入是可以并发执行的。</p>

<h4 id="jdk18-之后-1">JDK1.8 之后</h4>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构" /></p>

<p>Java 8 几乎完全重写了 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code>，代码量从原来 Java 7 中的 1000 多行，变成了现在的 6000 多行。</p>

<p><code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 取消了 <code class="language-plaintext highlighter-rouge">Segment</code> 分段锁，采用 <code class="language-plaintext highlighter-rouge">Node + CAS + synchronized</code> 来保证并发安全。数据结构跟 <code class="language-plaintext highlighter-rouge">HashMap</code> 1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。</p>

<p>Java 8 中，锁粒度更细，<code class="language-plaintext highlighter-rouge">synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</p>

<h3 id="jdk-17-和-jdk-18-的-concurrenthashmap-实现有什么不同">JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</h3>

<ul>
  <li><strong>线程安全实现方式</strong>：JDK 1.7 采用 <code class="language-plaintext highlighter-rouge">Segment</code> 分段锁来保证安全， <code class="language-plaintext highlighter-rouge">Segment</code> 是继承自 <code class="language-plaintext highlighter-rouge">ReentrantLock</code>。JDK1.8 放弃了 <code class="language-plaintext highlighter-rouge">Segment</code> 分段锁的设计，采用 <code class="language-plaintext highlighter-rouge">Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code class="language-plaintext highlighter-rouge">synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li>
  <li><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</li>
  <li><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li>
</ul>

<h3 id="concurrenthashmap-为什么-key-和-value-不能为-null">ConcurrentHashMap 为什么 key 和 value 不能为 null？</h3>

<p><code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 的 key 和 value 不能为 null 主要是为了避免二义性。null 是一个特殊的值，表示没有对象或没有引用。如果你用 null 作为键，那么你就无法区分这个键是否存在于 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 中，还是根本没有这个键。同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储在 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 中的，还是因为找不到对应的键而返回的。</p>

<p>拿 get 方法取值来说，返回的结果为 null 存在两种情况：</p>

<ul>
  <li>值没有在集合中 ；</li>
  <li>值本身就是 null。</li>
</ul>

<p>这也就是二义性的由来。</p>

<p>具体可以参考 <a href="https://javaguide.cn/java/collection/concurrent-hash-map-source-code.html">ConcurrentHashMap 源码分析</a> 。</p>

<p>多线程环境下，存在一个线程操作该 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 时，其他的线程将该 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 修改的情况，所以无法通过 <code class="language-plaintext highlighter-rouge">containsKey(key)</code> 来判断否存在这个键值对，也就没办法解决二义性问题了。</p>

<p>与此形成对比的是，<code class="language-plaintext highlighter-rouge">HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。如果传入 null 作为参数，就会返回 hash 值为 0 的位置的值。单线程环境下，不存在一个线程操作该 HashMap 时，其他的线程将该 <code class="language-plaintext highlighter-rouge">HashMap</code> 修改的情况，所以可以通过 <code class="language-plaintext highlighter-rouge">contains(key)</code>来做判断是否存在这个键值对，从而做相应的处理，也就不存在二义性问题。</p>

<p>也就是说，多线程下无法正确判定键值对是否存在（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）。</p>

<p>如果你确实需要在 ConcurrentHashMap 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="no">NULL</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
</code></pre></div></div>

<p>最后，再分享一下 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 作者本人 (Doug Lea)对于这个问题的回答：</p>

<blockquote>
  <p>The main reason that nulls aren’t allowed in ConcurrentMaps (ConcurrentHashMaps, ConcurrentSkipListMaps) is that ambiguities that may be just barely tolerable in non-concurrent maps can’t be accommodated. The main one is that if <code class="language-plaintext highlighter-rouge">map.get(key)</code> returns <code class="language-plaintext highlighter-rouge">null</code>, you can’t detect whether the key explicitly maps to <code class="language-plaintext highlighter-rouge">null</code> vs the key isn’t mapped. In a non-concurrent map, you can check this via <code class="language-plaintext highlighter-rouge">map.contains(key)</code>, but in a concurrent one, the map might have changed between calls.</p>
</blockquote>

<p>翻译过来之后的，大致意思还是单线程下可以容忍歧义，而多线程下无法容忍。</p>

<h3 id="concurrenthashmap-能保证复合操作的原子性吗">ConcurrentHashMap 能保证复合操作的原子性吗？</h3>

<p><code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 是线程安全的，意味着它可以保证多个线程同时对它进行读写操作时，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 <code class="language-plaintext highlighter-rouge">HashMap</code> 多线程操作导致死循环问题。但是，这并不意味着它可以保证所有的复合操作都是原子性的，一定不要搞混了！</p>

<p>复合操作是指由多个基本操作(如<code class="language-plaintext highlighter-rouge">put</code>、<code class="language-plaintext highlighter-rouge">get</code>、<code class="language-plaintext highlighter-rouge">remove</code>、<code class="language-plaintext highlighter-rouge">containsKey</code>等)组成的操作，例如先判断某个键是否存在<code class="language-plaintext highlighter-rouge">containsKey(key)</code>，然后根据结果进行插入或更新<code class="language-plaintext highlighter-rouge">put(key, value)</code>。这种操作在执行过程中可能会被其他线程打断，导致结果不符合预期。</p>

<p>例如，有两个线程 A 和 B 同时对 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 进行复合操作，如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 线程 A</span>
<span class="k">if</span> <span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 线程 B</span>
<span class="k">if</span> <span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">anotherValue</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>如果线程 A 和 B 的执行顺序是这样：</p>

<ol>
  <li>线程 A 判断 map 中不存在 key</li>
  <li>线程 B 判断 map 中不存在 key</li>
  <li>线程 B 将 (key, anotherValue) 插入 map</li>
  <li>线程 A 将 (key, value) 插入 map</li>
</ol>

<p>那么最终的结果是 (key, value)，而不是预期的 (key, anotherValue)。这就是复合操作的非原子性导致的问题。</p>

<p><strong>那如何保证 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 复合操作的原子性呢？</strong></p>

<p><code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 提供了一些原子性的复合操作，如 <code class="language-plaintext highlighter-rouge">putIfAbsent</code>、<code class="language-plaintext highlighter-rouge">compute</code>、<code class="language-plaintext highlighter-rouge">computeIfAbsent</code> 、<code class="language-plaintext highlighter-rouge">computeIfPresent</code>、<code class="language-plaintext highlighter-rouge">merge</code>等。这些方法都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中。</p>

<p>上面的代码可以改写为：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 线程 A</span>
<span class="n">map</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
<span class="c1">// 线程 B</span>
<span class="n">map</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">anotherValue</span><span class="o">);</span>
</code></pre></div></div>

<p>或者：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 线程 A</span>
<span class="n">map</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="o">);</span>
<span class="c1">// 线程 B</span>
<span class="n">map</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="n">anotherValue</span><span class="o">);</span>
</code></pre></div></div>

<p>很多同学可能会说了，这种情况也能加锁同步呀！确实可以，但不建议使用加锁的同步机制，违背了使用 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 的初衷。在使用 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 的时候，尽量使用这些原子性的复合操作方法来保证原子性。</p>

<h2 id="collections-工具类不重要">Collections 工具类（不重要）</h2>

<p><strong><code class="language-plaintext highlighter-rouge">Collections</code> 工具类常用方法</strong>:</p>

<ul>
  <li>排序</li>
  <li>查找,替换操作</li>
  <li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li>
</ul>

<h3 id="排序操作">排序操作</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="nc">List</span> <span class="n">list</span><span class="o">)</span><span class="c1">//反转</span>
<span class="kt">void</span> <span class="nf">shuffle</span><span class="o">(</span><span class="nc">List</span> <span class="n">list</span><span class="o">)</span><span class="c1">//随机排序</span>
<span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="nc">List</span> <span class="n">list</span><span class="o">)</span><span class="c1">//按自然排序的升序排序</span>
<span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="nc">List</span> <span class="n">list</span><span class="o">,</span> <span class="nc">Comparator</span> <span class="n">c</span><span class="o">)</span><span class="c1">//定制排序，由Comparator控制排序逻辑</span>
<span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="nc">List</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span><span class="c1">//交换两个索引位置的元素</span>
<span class="kt">void</span> <span class="nf">rotate</span><span class="o">(</span><span class="nc">List</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">distance</span><span class="o">)</span><span class="c1">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span>
</code></pre></div></div>

<h3 id="查找替换操作">查找,替换操作</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="nc">List</span> <span class="n">list</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">key</span><span class="o">)</span><span class="c1">//对List进行二分查找，返回索引，注意List必须是有序的</span>
<span class="kt">int</span> <span class="nf">max</span><span class="o">(</span><span class="nc">Collection</span> <span class="n">coll</span><span class="o">)</span><span class="c1">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span>
<span class="kt">int</span> <span class="nf">max</span><span class="o">(</span><span class="nc">Collection</span> <span class="n">coll</span><span class="o">,</span> <span class="nc">Comparator</span> <span class="n">c</span><span class="o">)</span><span class="c1">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span>
<span class="kt">void</span> <span class="nf">fill</span><span class="o">(</span><span class="nc">List</span> <span class="n">list</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span><span class="c1">//用指定的元素代替指定list中的所有元素</span>
<span class="kt">int</span> <span class="nf">frequency</span><span class="o">(</span><span class="nc">Collection</span> <span class="n">c</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">o</span><span class="o">)</span><span class="c1">//统计元素出现次数</span>
<span class="kt">int</span> <span class="nf">indexOfSubList</span><span class="o">(</span><span class="nc">List</span> <span class="n">list</span><span class="o">,</span> <span class="nc">List</span> <span class="n">target</span><span class="o">)</span><span class="c1">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)</span>
<span class="kt">boolean</span> <span class="nf">replaceAll</span><span class="o">(</span><span class="nc">List</span> <span class="n">list</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">oldVal</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">newVal</span><span class="o">)</span><span class="c1">//用新元素替换旧元素</span>
</code></pre></div></div>

<h3 id="同步控制">同步控制</h3>

<p><code class="language-plaintext highlighter-rouge">Collections</code> 提供了多个<code class="language-plaintext highlighter-rouge">synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p>

<p>我们知道 <code class="language-plaintext highlighter-rouge">HashSet</code>，<code class="language-plaintext highlighter-rouge">TreeSet</code>，<code class="language-plaintext highlighter-rouge">ArrayList</code>,<code class="language-plaintext highlighter-rouge">LinkedList</code>,<code class="language-plaintext highlighter-rouge">HashMap</code>,<code class="language-plaintext highlighter-rouge">TreeMap</code> 都是线程不安全的。<code class="language-plaintext highlighter-rouge">Collections</code> 提供了多个静态方法可以把他们包装成线程同步的集合。</p>

<p><strong>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。</strong></p>

<p>方法如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">synchronizedCollection</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span>  <span class="n">c</span><span class="o">)</span> <span class="c1">//返回指定 collection 支持的同步（线程安全的）collection。</span>
<span class="n">synchronizedList</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span><span class="c1">//返回指定列表支持的同步（线程安全的）List。</span>
<span class="n">synchronizedMap</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span> <span class="c1">//返回由指定映射支持的同步（线程安全的）Map。</span>
<span class="n">synchronizedSet</span><span class="o">(</span><span class="nc">Set</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">)</span> <span class="c1">//返回指定 set 支持的同步（线程安全的）set。</span>
</code></pre></div></div>

<!-- @include: @article-footer.snippet.md -->
