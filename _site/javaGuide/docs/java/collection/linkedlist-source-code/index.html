<!-- @include: @article-header.snippet.md -->

<h2 id="linkedlist-简介">LinkedList 简介</h2>

<p><code class="language-plaintext highlighter-rouge">LinkedList</code> 是一个基于双向链表实现的集合类，经常被拿来和 <code class="language-plaintext highlighter-rouge">ArrayList</code> 做比较。关于 <code class="language-plaintext highlighter-rouge">LinkedList</code> 和<code class="language-plaintext highlighter-rouge">ArrayList</code>的详细对比，我们 <a href="./java-collection-questions-01.md">Java 集合常见面试题总结(上)</a>有详细介绍到。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/bidirectional-linkedlist.png" alt="双向链表" /></p>

<p>不过，我们在项目中一般是不会使用到 <code class="language-plaintext highlighter-rouge">LinkedList</code> 的，需要用到 <code class="language-plaintext highlighter-rouge">LinkedList</code> 的场景几乎都可以使用 <code class="language-plaintext highlighter-rouge">ArrayList</code> 来代替，并且，性能通常会更好！就连 <code class="language-plaintext highlighter-rouge">LinkedList</code> 的作者约书亚 · 布洛克（Josh Bloch）自己都说从来不会使用 <code class="language-plaintext highlighter-rouge">LinkedList</code> 。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/redisimage-20220412110853807.png" alt="" /></p>

<p>另外，不要下意识地认为 <code class="language-plaintext highlighter-rouge">LinkedList</code> 作为链表就最适合元素增删的场景。我在上面也说了，<code class="language-plaintext highlighter-rouge">LinkedList</code> 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的平均时间复杂度都是 O(n) 。</p>

<h3 id="linkedlist-插入和删除元素的时间复杂度">LinkedList 插入和删除元素的时间复杂度？</h3>

<ul>
  <li>头部插入/删除：只需要修改头结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。</li>
  <li>尾部插入/删除：只需要修改尾结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。</li>
  <li>指定位置插入/删除：需要先移动到指定位置，再修改指定节点的指针完成插入/删除，不过由于有头尾指针，可以从较近的指针出发，因此需要遍历平均 n/4 个元素，时间复杂度为 O(n)。</li>
</ul>

<h3 id="linkedlist-为什么不能实现-randomaccess-接口">LinkedList 为什么不能实现 RandomAccess 接口？</h3>

<p><code class="language-plaintext highlighter-rouge">RandomAccess</code> 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 <code class="language-plaintext highlighter-rouge">LinkedList</code> 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 <code class="language-plaintext highlighter-rouge">RandomAccess</code> 接口。</p>

<h2 id="linkedlist-源码分析">LinkedList 源码分析</h2>

<p>这里以 JDK1.8 为例，分析一下 <code class="language-plaintext highlighter-rouge">LinkedList</code> 的底层核心源码。</p>

<p><code class="language-plaintext highlighter-rouge">LinkedList</code> 的类定义如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span>
    <span class="kd">extends</span> <span class="nc">AbstractSequentialList</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span>
    <span class="kd">implements</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;,</span> <span class="nc">Deque</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;,</span> <span class="nc">Cloneable</span><span class="o">,</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span>
<span class="o">{</span>
  <span class="c1">//...</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">LinkedList</code> 继承了 <code class="language-plaintext highlighter-rouge">AbstractSequentialList</code> ，而 <code class="language-plaintext highlighter-rouge">AbstractSequentialList</code> 又继承于 <code class="language-plaintext highlighter-rouge">AbstractList</code> 。</p>

<p>阅读过 <code class="language-plaintext highlighter-rouge">ArrayList</code> 的源码我们就知道，<code class="language-plaintext highlighter-rouge">ArrayList</code> 同样继承了 <code class="language-plaintext highlighter-rouge">AbstractList</code> ， 所以 <code class="language-plaintext highlighter-rouge">LinkedList</code> 会有大部分方法和 <code class="language-plaintext highlighter-rouge">ArrayList</code> 相似。</p>

<p><code class="language-plaintext highlighter-rouge">LinkedList</code> 实现了以下接口：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li>
  <li><code class="language-plaintext highlighter-rouge">Deque</code> ：继承自 <code class="language-plaintext highlighter-rouge">Queue</code> 接口，具有双端队列的特性，支持从两端插入和删除元素，方便实现栈和队列等数据结构。需要注意，<code class="language-plaintext highlighter-rouge">Deque</code> 的发音为 “deck” [dɛk]，这个大部分人都会读错。</li>
  <li><code class="language-plaintext highlighter-rouge">Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li>
  <li><code class="language-plaintext highlighter-rouge">Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li>
</ul>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/linkedlist--class-diagram.png" alt="LinkedList 类图" /></p>

<p><code class="language-plaintext highlighter-rouge">LinkedList</code> 中的元素是通过 <code class="language-plaintext highlighter-rouge">Node</code> 定义的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">E</span> <span class="n">item</span><span class="o">;</span><span class="c1">// 节点值</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span> <span class="c1">// 指向的下一个节点（后继节点）</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">prev</span><span class="o">;</span> <span class="c1">// 指向的前一个节点（前驱结点）</span>

    <span class="c1">// 初始化参数顺序分别是：前驱结点、本身节点值、后继节点</span>
    <span class="nc">Node</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">prev</span><span class="o">,</span> <span class="no">E</span> <span class="n">element</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">item</span> <span class="o">=</span> <span class="n">element</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="初始化">初始化</h3>

<p><code class="language-plaintext highlighter-rouge">LinkedList</code> 中有一个无参构造函数和一个有参构造函数。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建一个空的链表对象</span>
<span class="kd">public</span> <span class="nf">LinkedList</span><span class="o">()</span> <span class="o">{</span>
<span class="o">}</span>

<span class="c1">// 接收一个集合类型作为参数，会创建一个与传入集合相同元素的链表对象</span>
<span class="kd">public</span> <span class="nf">LinkedList</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">();</span>
    <span class="n">addAll</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="插入元素">插入元素</h3>

<p><code class="language-plaintext highlighter-rouge">LinkedList</code> 除了实现了 <code class="language-plaintext highlighter-rouge">List</code> 接口相关方法，还实现了 <code class="language-plaintext highlighter-rouge">Deque</code> 接口的很多方法，所以我们有很多种方式插入元素。</p>

<p>我们这里以 <code class="language-plaintext highlighter-rouge">List</code> 接口中相关的插入方法为例进行源码讲解，对应的是<code class="language-plaintext highlighter-rouge">add()</code> 方法。</p>

<p><code class="language-plaintext highlighter-rouge">add()</code> 方法有两个版本：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">add(E e)</code>：用于在 <code class="language-plaintext highlighter-rouge">LinkedList</code> 的尾部插入元素，即将新元素作为链表的最后一个元素，时间复杂度为 O(1)。</li>
  <li><code class="language-plaintext highlighter-rouge">add(int index, E element)</code>:用于在指定位置插入元素。这种插入方式需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在链表尾部插入元素</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">linkLast</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 在链表指定位置插入元素</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="no">E</span> <span class="n">element</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 下标越界检查</span>
    <span class="n">checkPositionIndex</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>

    <span class="c1">// 判断 index 是不是链表尾部位置</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">size</span><span class="o">)</span>
        <span class="c1">// 如果是就直接调用 linkLast 方法将元素节点插入链表尾部即可</span>
        <span class="n">linkLast</span><span class="o">(</span><span class="n">element</span><span class="o">);</span>
    <span class="k">else</span>
        <span class="c1">// 如果不是则调用 linkBefore 方法将其插入指定元素之前</span>
        <span class="n">linkBefore</span><span class="o">(</span><span class="n">element</span><span class="o">,</span> <span class="n">node</span><span class="o">(</span><span class="n">index</span><span class="o">));</span>
<span class="o">}</span>

<span class="c1">// 将元素节点插入到链表尾部</span>
<span class="kt">void</span> <span class="nf">linkLast</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 将最后一个元素赋值（引用传递）给节点 l</span>
    <span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="c1">// 创建节点，并指定节点前驱为链表尾节点 last，后继引用为空</span>
    <span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">&lt;&gt;(</span><span class="n">l</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="c1">// 将 last 引用指向新节点</span>
    <span class="n">last</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
    <span class="c1">// 判断尾节点是否为空</span>
    <span class="c1">// 如果 l 是null 意味着这是第一次添加元素</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">l</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="c1">// 如果是第一次添加，将first赋值为新节点，此时链表只有一个元素</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
    <span class="k">else</span>
        <span class="c1">// 如果不是第一次添加，将新节点赋值给l（添加前的最后一个元素）的next</span>
        <span class="n">l</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
    <span class="n">size</span><span class="o">++;</span>
    <span class="n">modCount</span><span class="o">++;</span>
<span class="o">}</span>

<span class="c1">// 在指定元素之前插入元素</span>
<span class="kt">void</span> <span class="nf">linkBefore</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">succ</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// assert succ != null;断言 succ不为 null</span>
    <span class="c1">// 定义一个节点元素保存 succ 的 prev 引用，也就是它的前一节点信息</span>
    <span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">succ</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
    <span class="c1">// 初始化节点，并指明前驱和后继节点</span>
    <span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">&lt;&gt;(</span><span class="n">pred</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">succ</span><span class="o">);</span>
    <span class="c1">// 将 succ 节点前驱引用 prev 指向新节点</span>
    <span class="n">succ</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
    <span class="c1">// 判断前驱节点是否为空，为空表示 succ 是第一个节点</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="c1">// 新节点成为第一个节点</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
    <span class="k">else</span>
        <span class="c1">// succ 节点前驱的后继引用指向新节点</span>
        <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
    <span class="n">size</span><span class="o">++;</span>
    <span class="n">modCount</span><span class="o">++;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="获取元素">获取元素</h3>

<p><code class="language-plaintext highlighter-rouge">LinkedList</code>获取元素相关的方法一共有 3 个：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">getFirst()</code>：获取链表的第一个元素。</li>
  <li><code class="language-plaintext highlighter-rouge">getLast()</code>：获取链表的最后一个元素。</li>
  <li><code class="language-plaintext highlighter-rouge">get(int index)</code>：获取链表指定位置的元素。</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取链表的第一个元素</span>
<span class="kd">public</span> <span class="no">E</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">f</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchElementException</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 获取链表的最后一个元素</span>
<span class="kd">public</span> <span class="no">E</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">l</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchElementException</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">l</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 获取链表指定位置的元素</span>
<span class="kd">public</span> <span class="no">E</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// 下标越界检查，如果越界就抛异常</span>
  <span class="n">checkElementIndex</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
  <span class="c1">// 返回链表中对应下标的元素</span>
  <span class="k">return</span> <span class="nf">node</span><span class="o">(</span><span class="n">index</span><span class="o">).</span><span class="na">item</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这里的核心在于 <code class="language-plaintext highlighter-rouge">node(int index)</code> 这个方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 返回指定下标的非空节点</span>
<span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">node</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 断言下标未越界</span>
    <span class="c1">// assert isElementIndex(index);</span>
    <span class="c1">// 如果index小于size的二分之一  从前开始查找（向后查找）  反之向前查找</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="c1">// 遍历，循环向后查找，直至 i == index</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">index</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">get(int index)</code> 或 <code class="language-plaintext highlighter-rouge">remove(int index)</code> 等方法内部都调用了该方法来获取对应的节点。</p>

<p>从这个方法的源码可以看出，该方法通过比较索引值与链表 size 的一半大小来确定从链表头还是尾开始遍历。如果索引值小于 size 的一半，就从链表头开始遍历，反之从链表尾开始遍历。这样可以在较短的时间内找到目标节点，充分利用了双向链表的特性来提高效率。</p>

<h3 id="删除元素">删除元素</h3>

<p><code class="language-plaintext highlighter-rouge">LinkedList</code>删除元素相关的方法一共有 5 个：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">removeFirst()</code>：删除并返回链表的第一个元素。</li>
  <li><code class="language-plaintext highlighter-rouge">removeLast()</code>：删除并返回链表的最后一个元素。</li>
  <li><code class="language-plaintext highlighter-rouge">remove(E e)</code>：删除链表中首次出现的指定元素，如果不存在该元素则返回 false。</li>
  <li><code class="language-plaintext highlighter-rouge">remove(int index)</code>：删除指定索引处的元素，并返回该元素的值。</li>
  <li><code class="language-plaintext highlighter-rouge">void clear()</code>：移除此链表中的所有元素。</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 删除并返回链表的第一个元素</span>
<span class="kd">public</span> <span class="no">E</span> <span class="nf">removeFirst</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">f</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchElementException</span><span class="o">();</span>
    <span class="k">return</span> <span class="nf">unlinkFirst</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 删除并返回链表的最后一个元素</span>
<span class="kd">public</span> <span class="no">E</span> <span class="nf">removeLast</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">l</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchElementException</span><span class="o">();</span>
    <span class="k">return</span> <span class="nf">unlinkLast</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 删除链表中首次出现的指定元素，如果不存在该元素则返回 false</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 如果指定元素为 null，遍历链表找到第一个为 null 的元素进行删除</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">item</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">unlink</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// 如果不为 null ,遍历链表找到要删除的节点</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">o</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">item</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">unlink</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 删除链表指定位置的元素</span>
<span class="kd">public</span> <span class="no">E</span> <span class="nf">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 下标越界检查，如果越界就抛异常</span>
    <span class="n">checkElementIndex</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
    <span class="k">return</span> <span class="nf">unlink</span><span class="o">(</span><span class="n">node</span><span class="o">(</span><span class="n">index</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这里的核心在于 <code class="language-plaintext highlighter-rouge">unlink(Node&lt;E&gt; x)</code> 这个方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">E</span> <span class="nf">unlink</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 断言 x 不为 null</span>
    <span class="c1">// assert x != null;</span>
    <span class="c1">// 获取当前节点（也就是待删除节点）的元素</span>
    <span class="kd">final</span> <span class="no">E</span> <span class="n">element</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
    <span class="c1">// 获取当前节点的下一个节点</span>
    <span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="c1">// 获取当前节点的前一个节点</span>
    <span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>

    <span class="c1">// 如果前一个节点为空，则说明当前节点是头节点</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">prev</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 直接让链表头指向当前节点的下一个节点</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// 如果前一个节点不为空</span>
        <span class="c1">// 将前一个节点的 next 指针指向当前节点的下一个节点</span>
        <span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
        <span class="c1">// 将当前节点的 prev 指针置为 null，，方便 GC 回收</span>
        <span class="n">x</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 如果下一个节点为空，则说明当前节点是尾节点</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 直接让链表尾指向当前节点的前一个节点</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// 如果下一个节点不为空</span>
        <span class="c1">// 将下一个节点的 prev 指针指向当前节点的前一个节点</span>
        <span class="n">next</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
        <span class="c1">// 将当前节点的 next 指针置为 null，方便 GC 回收</span>
        <span class="n">x</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 将当前节点元素置为 null，方便 GC 回收</span>
    <span class="n">x</span><span class="o">.</span><span class="na">item</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">size</span><span class="o">--;</span>
    <span class="n">modCount</span><span class="o">++;</span>
    <span class="k">return</span> <span class="n">element</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">unlink()</code> 方法的逻辑如下：</p>

<ol>
  <li>首先获取待删除节点 x 的前驱和后继节点；</li>
  <li>判断待删除节点是否为头节点或尾节点：
    <ul>
      <li>如果 x 是头节点，则将 first 指向 x 的后继节点 next</li>
      <li>如果 x 是尾节点，则将 last 指向 x 的前驱节点 prev</li>
      <li>如果 x 不是头节点也不是尾节点，执行下一步操作</li>
    </ul>
  </li>
  <li>将待删除节点 x 的前驱的后继指向待删除节点的后继 next，断开 x 和 x.prev 之间的链接；</li>
  <li>将待删除节点 x 的后继的前驱指向待删除节点的前驱 prev，断开 x 和 x.next 之间的链接；</li>
  <li>将待删除节点 x 的元素置空，修改链表长度。</li>
</ol>

<p>可以参考下图理解（图源：<a href="https://www.tianxiaobo.com/2018/01/31/LinkedList-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-JDK-1-8/">LinkedList 源码分析(JDK 1.8)</a>）：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/linkedlist-unlink.jpg" alt="unlink 方法逻辑" /></p>

<h3 id="遍历链表">遍历链表</h3>

<p>推荐使用<code class="language-plaintext highlighter-rouge">for-each</code> 循环来遍历 <code class="language-plaintext highlighter-rouge">LinkedList</code> 中的元素， <code class="language-plaintext highlighter-rouge">for-each</code> 循环最终会转换成迭代器形式。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"apple"</span><span class="o">);</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"banana"</span><span class="o">);</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"pear"</span><span class="o">);</span>

<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">fruit</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">fruit</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">LinkedList</code> 的遍历的核心就是它的迭代器的实现。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 双向迭代器</span>
<span class="kd">private</span> <span class="kd">class</span> <span class="nc">ListItr</span> <span class="kd">implements</span> <span class="nc">ListIterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="c1">// 表示上一次调用 next() 或 previous() 方法时经过的节点；</span>
    <span class="kd">private</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">lastReturned</span><span class="o">;</span>
    <span class="c1">// 表示下一个要遍历的节点；</span>
    <span class="kd">private</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
    <span class="c1">// 表示下一个要遍历的节点的下标，也就是当前节点的后继节点的下标；</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">nextIndex</span><span class="o">;</span>
    <span class="c1">// 表示当前遍历期望的修改计数值，用于和 LinkedList 的 modCount 比较，判断链表是否被其他线程修改过。</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">expectedModCount</span> <span class="o">=</span> <span class="n">modCount</span><span class="o">;</span>
    <span class="err">…………</span>
<span class="o">}</span>
</code></pre></div></div>

<p>下面我们对迭代器 <code class="language-plaintext highlighter-rouge">ListItr</code> 中的核心方法进行详细介绍。</p>

<p>我们先来看下从头到尾方向的迭代：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 判断还有没有下一个节点</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 判断下一个节点的下标是否小于链表的大小，如果是则表示还有下一个元素可以遍历</span>
    <span class="k">return</span> <span class="n">nextIndex</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">// 获取下一个节点</span>
<span class="kd">public</span> <span class="no">E</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 检查在迭代过程中链表是否被修改过</span>
    <span class="n">checkForComodification</span><span class="o">();</span>
    <span class="c1">// 判断是否还有下一个节点可以遍历，如果没有则抛出 NoSuchElementException 异常</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">hasNext</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchElementException</span><span class="o">();</span>
    <span class="c1">// 将 lastReturned 指向当前节点</span>
    <span class="n">lastReturned</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="c1">// 将 next 指向下一个节点</span>
    <span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="n">nextIndex</span><span class="o">++;</span>
    <span class="k">return</span> <span class="n">lastReturned</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>再来看一下从尾到头方向的迭代：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 判断是否还有前一个节点</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasPrevious</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">nextIndex</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 获取前一个节点</span>
<span class="kd">public</span> <span class="no">E</span> <span class="nf">previous</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 检查是否在迭代过程中链表被修改</span>
    <span class="n">checkForComodification</span><span class="o">();</span>
    <span class="c1">// 如果没有前一个节点，则抛出异常</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">hasPrevious</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchElementException</span><span class="o">();</span>
    <span class="c1">// 将 lastReturned 和 next 指针指向上一个节点</span>
    <span class="n">lastReturned</span> <span class="o">=</span> <span class="n">next</span> <span class="o">=</span> <span class="o">(</span><span class="n">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">last</span> <span class="o">:</span> <span class="n">next</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
    <span class="n">nextIndex</span><span class="o">--;</span>
    <span class="k">return</span> <span class="n">lastReturned</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>如果需要删除或插入元素，也可以使用迭代器进行操作。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"apple"</span><span class="o">);</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"banana"</span><span class="o">);</span>

<span class="c1">//  Collection 接口的 removeIf 方法底层依然是基于迭代器</span>
<span class="n">list</span><span class="o">.</span><span class="na">removeIf</span><span class="o">(</span><span class="nl">Objects:</span><span class="o">:</span><span class="n">isNull</span><span class="o">);</span>

<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">fruit</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">fruit</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>迭代器对应的移除元素的方法如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 从列表中删除上次被返回的元素</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 检查是否在迭代过程中链表被修改</span>
    <span class="n">checkForComodification</span><span class="o">();</span>
    <span class="c1">// 如果上次返回的节点为空，则抛出异常</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">lastReturned</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">();</span>

    <span class="c1">// 获取当前节点的下一个节点</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">lastNext</span> <span class="o">=</span> <span class="n">lastReturned</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="c1">// 从链表中删除上次返回的节点</span>
    <span class="n">unlink</span><span class="o">(</span><span class="n">lastReturned</span><span class="o">);</span>
    <span class="c1">// 修改指针</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">next</span> <span class="o">==</span> <span class="n">lastReturned</span><span class="o">)</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">lastNext</span><span class="o">;</span>
    <span class="k">else</span>
        <span class="n">nextIndex</span><span class="o">--;</span>
    <span class="c1">// 将上次返回的节点引用置为 null，方便 GC 回收</span>
    <span class="n">lastReturned</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">expectedModCount</span><span class="o">++;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="linkedlist-常用方法测试">LinkedList 常用方法测试</h2>

<p>代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建 LinkedList 对象</span>
<span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>

<span class="c1">// 添加元素到链表末尾</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"apple"</span><span class="o">);</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"banana"</span><span class="o">);</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"pear"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"链表内容："</span> <span class="o">+</span> <span class="n">list</span><span class="o">);</span>

<span class="c1">// 在指定位置插入元素</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"orange"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"链表内容："</span> <span class="o">+</span> <span class="n">list</span><span class="o">);</span>

<span class="c1">// 获取指定位置的元素</span>
<span class="nc">String</span> <span class="n">fruit</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"索引为 2 的元素："</span> <span class="o">+</span> <span class="n">fruit</span><span class="o">);</span>

<span class="c1">// 修改指定位置的元素</span>
<span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s">"grape"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"链表内容："</span> <span class="o">+</span> <span class="n">list</span><span class="o">);</span>

<span class="c1">// 删除指定位置的元素</span>
<span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"链表内容："</span> <span class="o">+</span> <span class="n">list</span><span class="o">);</span>

<span class="c1">// 删除第一个出现的指定元素</span>
<span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="s">"banana"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"链表内容："</span> <span class="o">+</span> <span class="n">list</span><span class="o">);</span>

<span class="c1">// 获取链表的长度</span>
<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"链表长度："</span> <span class="o">+</span> <span class="n">size</span><span class="o">);</span>

<span class="c1">// 清空链表</span>
<span class="n">list</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"清空后的链表："</span> <span class="o">+</span> <span class="n">list</span><span class="o">);</span>
</code></pre></div></div>

<p>输出：</p>

<pre><code class="language-plain">索引为 2 的元素：banana
链表内容：[apple, orange, banana, grape]
链表内容：[orange, banana, grape]
链表内容：[orange, grape]
链表长度：2
清空后的链表：[]
</code></pre>

<!-- @include: @article-footer.snippet.md -->
