<blockquote>
  <table>
    <tbody>
      <tr>
        <td>本文重构完善自[6000 字</td>
        <td>16 图</td>
        <td>深入理解 Spring Cloud Gateway 的原理 - 悟空聊架构](https://mp.weixin.qq.com/s/XjFYsP1IUqNzWqXZdJn-Aw)这篇文章。</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<h2 id="什么是-spring-cloud-gateway">什么是 Spring Cloud Gateway？</h2>

<p>Spring Cloud Gateway 属于 Spring Cloud 生态系统中的网关，其诞生的目标是为了替代老牌网关 <strong>Zuul</strong>。准确点来说，应该是 Zuul 1.x。Spring Cloud Gateway 起步要比 Zuul 2.x 更早。</p>

<p>为了提升网关的性能，Spring Cloud Gateway 基于 Spring WebFlux 。Spring WebFlux 使用 Reactor 库来实现响应式编程模型，底层基于 Netty 实现同步非阻塞的 I/O。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/springcloud-gateway-%20demo.png" alt="" /></p>

<p>Spring Cloud Gateway 不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，限流。</p>

<p>Spring Cloud Gateway 和 Zuul 2.x 的差别不大，也是通过过滤器来处理请求。不过，目前更加推荐使用 Spring Cloud Gateway 而非 Zuul，Spring Cloud 生态对其支持更加友好。</p>

<ul>
  <li>GitHub 地址： <a href="https://github.com/spring-cloud/spring-cloud-gateway">https://github.com/spring-cloud/spring-cloud-gateway</a></li>
  <li>官网： <a href="https://spring.io/projects/spring-cloud-gateway">https://spring.io/projects/spring-cloud-gateway</a></li>
</ul>

<h2 id="spring-cloud-gateway-的工作流程">Spring Cloud Gateway 的工作流程？</h2>

<p>Spring Cloud Gateway 的工作流程如下图所示：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-workflow.png" alt="Spring Cloud Gateway 的工作流程" /></p>

<p>这是 Spring 官方博客中的一张图，原文地址：<a href="https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter">https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter</a>。</p>

<p>具体的流程分析：</p>

<ol>
  <li><strong>路由判断</strong>：客户端的请求到达网关后，先经过 Gateway Handler Mapping 处理，这里面会做断言（Predicate）判断，看下符合哪个路由规则，这个路由映射后端的某个服务。</li>
  <li><strong>请求过滤</strong>：然后请求到达 Gateway Web Handler，这里面有很多过滤器，组成过滤器链（Filter Chain），这些过滤器可以对请求进行拦截和修改，比如添加请求头、参数校验等等，有点像净化污水。然后将请求转发到实际的后端服务。这些过滤器逻辑上可以称作 Pre-Filters，Pre 可以理解为“在…之前”。</li>
  <li><strong>服务处理</strong>：后端服务会对请求进行处理。</li>
  <li><strong>响应过滤</strong>：后端处理完结果后，返回给 Gateway 的过滤器再次做处理，逻辑上可以称作 Post-Filters，Post 可以理解为“在…之后”。</li>
  <li><strong>响应返回</strong>：响应经过过滤处理后，返回给客户端。</li>
</ol>

<p>总结：客户端的请求先通过匹配规则找到合适的路由，就能映射到具体的服务。然后请求经过过滤器处理后转发给具体的服务，服务处理后，再次经过过滤器处理，最后返回给客户端。</p>

<h2 id="spring-cloud-gateway-的断言是什么">Spring Cloud Gateway 的断言是什么？</h2>

<p>断言（Predicate）这个词听起来极其深奥，它是一种编程术语，我们生活中根本就不会用它。说白了它就是对一个表达式进行 if 判断，结果为真或假，如果为真则做这件事，否则做那件事。</p>

<p>在 Gateway 中，如果客户端发送的请求满足了断言的条件，则映射到指定的路由器，就能转发到指定的服务上进行处理。</p>

<p>断言配置的示例如下，配置了两个路由规则，有一个 predicates 断言配置，当请求 url 中包含 <code class="language-plaintext highlighter-rouge">api/thirdparty</code>，就匹配到了第一个路由 <code class="language-plaintext highlighter-rouge">route_thirdparty</code>。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-predicate-example.png" alt="断言配置示例" /></p>

<p>常见的路由断言规则如下图所示：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-predicate-rules.png" alt="Spring Cloud GateWay 路由断言规则" /></p>

<h2 id="spring-cloud-gateway-的路由和断言是什么关系">Spring Cloud Gateway 的路由和断言是什么关系？</h2>

<p>Route 路由和 Predicate 断言的对应关系如下：：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-predicate-route.png" alt="路由和断言的对应关系" /></p>

<ul>
  <li><strong>一对多</strong>：一个路由规则可以包含多个断言。如上图中路由 Route1 配置了三个断言 Predicate。</li>
  <li><strong>同时满足</strong>：如果一个路由规则中有多个断言，则需要同时满足才能匹配。如上图中路由 Route2 配置了两个断言，客户端发送的请求必须同时满足这两个断言，才能匹配路由 Route2。</li>
  <li><strong>第一个匹配成功</strong>：如果一个请求可以匹配多个路由，则映射第一个匹配成功的路由。如上图所示，客户端发送的请求满足 Route3 和 Route4 的断言，但是 Route3 的配置在配置文件中靠前，所以只会匹配 Route3。</li>
</ul>

<h2 id="spring-cloud-gateway-如何实现动态路由">Spring Cloud Gateway 如何实现动态路由？</h2>

<p>在使用 Spring Cloud Gateway 的时候，官方文档提供的方案总是基于配置文件或代码配置的方式。</p>

<p>Spring Cloud Gateway 作为微服务的入口，需要尽量避免重启，而现在配置更改需要重启服务不能满足实际生产过程中的动态刷新、实时变更的业务需求，所以我们需要在 Spring Cloud Gateway 运行时动态配置网关。</p>

<p>实现动态路由的方式有很多种，其中一种推荐的方式是基于 Nacos 注册中心来做。 Spring Cloud Gateway 可以从注册中心获取服务的元数据（例如服务名称、路径等），然后根据这些信息自动生成路由规则。这样，当你添加、移除或更新服务实例时，网关会自动感知并相应地调整路由规则，无需手动维护路由配置。</p>

<p>其实这些复杂的步骤并不需要我们手动实现，通过 Nacos Server 和 Spring Cloud Alibaba Nacos Config 即可实现配置的动态变更，官方文档地址：<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config">https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config</a> 。</p>

<h2 id="spring-cloud-gateway-的过滤器有哪些">Spring Cloud Gateway 的过滤器有哪些？</h2>

<p>过滤器 Filter 按照请求和响应可以分为两种：</p>

<ul>
  <li><strong>Pre 类型</strong>：在请求被转发到微服务之前，对请求进行拦截和修改，例如参数校验、权限校验、流量监控、日志输出以及协议转换等操作。</li>
  <li><strong>Post 类型</strong>：微服务处理完请求后，返回响应给网关，网关可以再次进行处理，例如修改响应内容或响应头、日志输出、流量监控等。</li>
</ul>

<p>另外一种分类是按照过滤器 Filter 作用的范围进行划分：</p>

<ul>
  <li><strong>GatewayFilter</strong>：局部过滤器，应用在单个路由或一组路由上的过滤器。标红色表示比较常用的过滤器。</li>
  <li><strong>GlobalFilter</strong>：全局过滤器，应用在所有路由上的过滤器。</li>
</ul>

<h3 id="局部过滤器">局部过滤器</h3>

<p>常见的局部过滤器如下图所示：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-gatewayfilters.png" alt="" /></p>

<p>具体怎么用呢？这里有个示例，如果 URL 匹配成功，则去掉 URL 中的 “api”。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">filters</span><span class="pi">:</span> <span class="c1">#过滤器</span>
  <span class="pi">-</span> <span class="s">RewritePath=/api/(?&lt;segment&gt;.*),/$\{segment}</span> <span class="c1"># 将跳转路径中包含的 “api” 替换成空</span>
</code></pre></div></div>

<p>当然我们也可以自定义过滤器，本篇不做展开。</p>

<h3 id="全局过滤器">全局过滤器</h3>

<p>常见的全局过滤器如下图所示：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-globalfilters.png" alt="" /></p>

<p>全局过滤器最常见的用法是进行负载均衡。配置如下所示：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spring</span><span class="pi">:</span>
  <span class="na">cloud</span><span class="pi">:</span>
    <span class="na">gateway</span><span class="pi">:</span>
      <span class="na">routes</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">id</span><span class="pi">:</span> <span class="s">route_member</span> <span class="c1"># 第三方微服务路由规则</span>
          <span class="na">uri</span><span class="pi">:</span> <span class="s">lb://passjava-member</span> <span class="c1"># 负载均衡，将请求转发到注册中心注册的 passjava-member 服务</span>
          <span class="na">predicates</span><span class="pi">:</span> <span class="c1"># 断言</span>
            <span class="pi">-</span> <span class="s">Path=/api/member/**</span> <span class="c1"># 如果前端请求路径包含 api/member，则应用这条路由规则</span>
          <span class="na">filters</span><span class="pi">:</span> <span class="c1">#过滤器</span>
            <span class="pi">-</span> <span class="s">RewritePath=/api/(?&lt;segment&gt;.*),/$\{segment}</span> <span class="c1"># 将跳转路径中包含的api替换成空</span>
</code></pre></div></div>

<p>这里有个关键字 <code class="language-plaintext highlighter-rouge">lb</code>，用到了全局过滤器 <code class="language-plaintext highlighter-rouge">LoadBalancerClientFilter</code>，当匹配到这个路由后，会将请求转发到 passjava-member 服务，且支持负载均衡转发，也就是先将 passjava-member 解析成实际的微服务的 host 和 port，然后再转发给实际的微服务。</p>

<h2 id="spring-cloud-gateway-支持限流吗">Spring Cloud Gateway 支持限流吗？</h2>

<p>Spring Cloud Gateway 自带了限流过滤器，对应的接口是 <code class="language-plaintext highlighter-rouge">RateLimiter</code>，<code class="language-plaintext highlighter-rouge">RateLimiter</code> 接口只有一个实现类 <code class="language-plaintext highlighter-rouge">RedisRateLimiter</code> （基于 Redis + Lua 实现的限流），提供的限流功能比较简易且不易使用。</p>

<p>从 Sentinel 1.6.0 版本开始，Sentinel 引入了 Spring Cloud Gateway 的适配模块，可以提供两种资源维度的限流：route 维度和自定义 API 维度。也就是说，Spring Cloud Gateway 可以结合 Sentinel 实现更强大的网关流量控制。</p>

<h2 id="spring-cloud-gateway-如何自定义全局异常处理">Spring Cloud Gateway 如何自定义全局异常处理？</h2>

<p>在 SpringBoot 项目中，我们捕获全局异常只需要在项目中配置 <code class="language-plaintext highlighter-rouge">@RestControllerAdvice</code>和 <code class="language-plaintext highlighter-rouge">@ExceptionHandler</code>就可以了。不过，这种方式在 Spring Cloud Gateway 下不适用。</p>

<p>Spring Cloud Gateway 提供了多种全局处理的方式，比较常用的一种是实现<code class="language-plaintext highlighter-rouge">ErrorWebExceptionHandler</code>并重写其中的<code class="language-plaintext highlighter-rouge">handle</code>方法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Order</span><span class="o">(-</span><span class="mi">1</span><span class="o">)</span>
<span class="nd">@Component</span>
<span class="nd">@RequiredArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GlobalErrorWebExceptionHandler</span> <span class="kd">implements</span> <span class="nc">ErrorWebExceptionHandler</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">ObjectMapper</span> <span class="n">objectMapper</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">handle</span><span class="o">(</span><span class="nc">ServerWebExchange</span> <span class="n">exchange</span><span class="o">,</span> <span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// ...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="参考">参考</h2>

<ul>
  <li>Spring Cloud Gateway 官方文档：<a href="https://cloud.spring.io/spring-cloud-gateway/reference/html/">https://cloud.spring.io/spring-cloud-gateway/reference/html/</a></li>
  <li>Creating a custom Spring Cloud Gateway Filter：<a href="https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter">https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter</a></li>
  <li>全局异常处理: <a href="https://zhuanlan.zhihu.com/p/347028665">https://zhuanlan.zhihu.com/p/347028665</a></li>
</ul>

<!-- @include: @article-footer.snippet.md -->
