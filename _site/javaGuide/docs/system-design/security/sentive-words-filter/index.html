<p>系统需要对用户输入的文本进行敏感词过滤如色情、政治、暴力相关的词汇。</p>

<p>敏感词过滤用的使用比较多的 <strong>Trie 树算法</strong> 和 <strong>DFA 算法</strong>。</p>

<h2 id="算法实现">算法实现</h2>

<h3 id="trie-树">Trie 树</h3>

<p><strong>Trie 树</strong> 也称为字典树、单词查找树，哈希树的一种变种，通常被用于字符串匹配，用来解决在一组字符串集合中快速查找某个字符串的问题。像浏览器搜索的关键词提示就可以基于 Trie 树来做的。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/brower-trie.png" alt="浏览器 Trie 树效果展示" /></p>

<p>假如我们的敏感词库中有以下敏感词：</p>

<ul>
  <li>高清视频</li>
  <li>高清 CV</li>
  <li>东京冷</li>
  <li>东京热</li>
</ul>

<p>我们构造出来的敏感词 Trie 树就是下面这样的：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/sensitive-word-trie.png" alt="敏感词 Trie 树" /></p>

<p>当我们要查找对应的字符串“东京热”的话，我们会把这个字符串切割成单个的字符“东”、“京”、“热”，然后我们从 Trie 树的根节点开始匹配。</p>

<p>可以看出， <strong>Trie 树的核心原理其实很简单，就是通过公共前缀来提高字符串匹配效率。</strong></p>

<p><a href="https://mvnrepository.com/artifact/org.apache.commons/commons-collections4">Apache Commons Collections</a> 这个库中就有 Trie 树实现：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/common-collections-trie.png" alt="Apache Commons Collections 中的 Trie 树实现" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Trie</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">trie</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PatriciaTrie</span><span class="o">&lt;&gt;();</span>
<span class="n">trie</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"Abigail"</span><span class="o">,</span> <span class="s">"student"</span><span class="o">);</span>
<span class="n">trie</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"Abi"</span><span class="o">,</span> <span class="s">"doctor"</span><span class="o">);</span>
<span class="n">trie</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"Annabel"</span><span class="o">,</span> <span class="s">"teacher"</span><span class="o">);</span>
<span class="n">trie</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"Christina"</span><span class="o">,</span> <span class="s">"student"</span><span class="o">);</span>
<span class="n">trie</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"Chris"</span><span class="o">,</span> <span class="s">"doctor"</span><span class="o">);</span>
<span class="nc">Assertions</span><span class="o">.</span><span class="na">assertTrue</span><span class="o">(</span><span class="n">trie</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="s">"Abigail"</span><span class="o">));</span>
<span class="n">assertEquals</span><span class="o">(</span><span class="s">"{Abi=doctor, Abigail=student}"</span><span class="o">,</span> <span class="n">trie</span><span class="o">.</span><span class="na">prefixMap</span><span class="o">(</span><span class="s">"Abi"</span><span class="o">).</span><span class="na">toString</span><span class="o">());</span>
<span class="n">assertEquals</span><span class="o">(</span><span class="s">"{Chris=doctor, Christina=student}"</span><span class="o">,</span> <span class="n">trie</span><span class="o">.</span><span class="na">prefixMap</span><span class="o">(</span><span class="s">"Chr"</span><span class="o">).</span><span class="na">toString</span><span class="o">());</span>
</code></pre></div></div>

<p>Trie 树是一种利用空间换时间的数据结构，占用的内存会比较大。也正是因为这个原因，实际工程项目中都是使用的改进版 Trie 树例如双数组 Trie 树（Double-Array Trie，DAT）。</p>

<p>DAT 的设计者是日本的 Aoe Jun-ichi，Mori Akira 和 Sato Takuya，他们在 1989 年发表了一篇论文<a href="https://www.co-ding.com/assets/pdf/dat.pdf">《An Efficient Implementation of Trie Structures》</a>，详细介绍了 DAT 的构造和应用，原作者写的示例代码地址：<a href="https://github.com/komiya-atsushi/darts-java/blob/e2986a55e648296cc0a6244ae4a2e457cd89fb82/src/main/java/darts/DoubleArrayTrie.java">https://github.com/komiya-atsushi/darts-java/blob/e2986a55e648296cc0a6244ae4a2e457cd89fb82/src/main/java/darts/DoubleArrayTrie.java</a>。相比较于 Trie 树，DAT 的内存占用极低，可以达到 Trie 树内存的 1%左右。DAT 在中文分词、自然语言处理、信息检索等领域有广泛的应用，是一种非常优秀的数据结构。</p>

<h3 id="ac-自动机">AC 自动机</h3>

<p>Aho-Corasick（AC）自动机是一种建立在 Trie 树上的一种改进算法，是一种多模式匹配算法，由贝尔实验室的研究人员 Alfred V. Aho 和 Margaret J.Corasick 发明。</p>

<table>
  <tbody>
    <tr>
      <td>AC 自动机算法使用 Trie 树来存放模式串的前缀，通过失败匹配指针（失配指针）来处理匹配失败的跳转。关于 AC 自动机的详细介绍，可以查看这篇文章：[地铁十分钟</td>
      <td>AC 自动机](https://zhuanlan.zhihu.com/p/146369212)。</td>
    </tr>
  </tbody>
</table>

<p>如果使用上面提到的 DAT 来表示 AC 自动机 ，就可以兼顾两者的优点，得到一种高效的多模式匹配算法。Github 上已经有了开源 Java 实现版本：<a href="https://github.com/hankcs/AhoCorasickDoubleArrayTrie">https://github.com/hankcs/AhoCorasickDoubleArrayTrie</a> 。</p>

<h3 id="dfa">DFA</h3>

<p><strong>DFA</strong>（Deterministic Finite Automata)即确定有穷自动机，与之对应的是 NFA（Non-Deterministic Finite Automata，不确定有穷自动机)。</p>

<p>关于 DFA 的详细介绍可以看这篇文章：<a href="https://zhuanlan.zhihu.com/p/30009083">有穷自动机 DFA&amp;NFA (学习笔记) - 小蜗牛的文章 - 知乎</a> 。</p>

<p><a href="https://hutool.cn/docs/#/dfa/%E6%A6%82%E8%BF%B0">Hutool</a> 提供了 DFA 算法的实现：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/hutool-dfa.png" alt="Hutool 的 DFA 算法" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">WordTree</span> <span class="n">wordTree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WordTree</span><span class="o">();</span>
<span class="n">wordTree</span><span class="o">.</span><span class="na">addWord</span><span class="o">(</span><span class="s">"大"</span><span class="o">);</span>
<span class="n">wordTree</span><span class="o">.</span><span class="na">addWord</span><span class="o">(</span><span class="s">"大憨憨"</span><span class="o">);</span>
<span class="n">wordTree</span><span class="o">.</span><span class="na">addWord</span><span class="o">(</span><span class="s">"憨憨"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">text</span> <span class="o">=</span> <span class="s">"那人真是个大憨憨！"</span><span class="o">;</span>
<span class="c1">// 获得第一个匹配的关键字</span>
<span class="nc">String</span> <span class="n">matchStr</span> <span class="o">=</span> <span class="n">wordTree</span><span class="o">.</span><span class="na">match</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">matchStr</span><span class="o">);</span>
<span class="c1">// 标准匹配，匹配到最短关键词，并跳过已经匹配的关键词</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">matchStrList</span> <span class="o">=</span> <span class="n">wordTree</span><span class="o">.</span><span class="na">matchAll</span><span class="o">(</span><span class="n">text</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">matchStrList</span><span class="o">);</span>
<span class="c1">//匹配到最长关键词，跳过已经匹配的关键词</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">matchStrList2</span> <span class="o">=</span> <span class="n">wordTree</span><span class="o">.</span><span class="na">matchAll</span><span class="o">(</span><span class="n">text</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">matchStrList2</span><span class="o">);</span>
</code></pre></div></div>

<p>输出：</p>

<pre><code class="language-plain">大
[大, 憨憨]
[大, 大憨憨]
</code></pre>

<h2 id="开源项目">开源项目</h2>

<ul>
  <li><a href="https://github.com/toolgood/ToolGood.Words">ToolGood.Words</a>：一款高性能敏感词(非法词/脏字)检测过滤组件，附带繁体简体互换，支持全角半角互换，汉字转拼音，模糊搜索等功能。</li>
  <li><a href="https://github.com/hooj0/sensitive-words-filter">sensitive-words-filter</a>：敏感词过滤项目，提供 TTMP、DFA、DAT、hash bucket、Tire 算法支持过滤。可以支持文本的高亮、过滤、判词、替换的接口支持。</li>
</ul>

<h2 id="论文">论文</h2>

<ul>
  <li><a href="https://patents.google.com/patent/CN101964000B">一种敏感词自动过滤管理系统</a></li>
  <li><a href="https://patents.google.com/patent/CN103714160A/zh">一种网络游戏中敏感词过滤方法及系统</a></li>
</ul>

<!-- @include: @article-footer.snippet.md -->
