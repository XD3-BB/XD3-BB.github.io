<blockquote>
  <p>作者：<a href="https://github.com/Miki-byte-1024">Miki-byte-1024</a> &amp; <a href="https://github.com/Snailclimb">Snailclimb</a></p>
</blockquote>

<p>每次问到 Spring Boot， 面试官非常喜欢问这个问题：“讲述一下 SpringBoot 自动装配原理？”。</p>

<p>我觉得我们可以从以下几个方面回答：</p>

<ol>
  <li>什么是 SpringBoot 自动装配？</li>
  <li>SpringBoot 是如何实现自动装配的？如何实现按需加载？</li>
  <li>如何实现一个 Starter？</li>
</ol>

<p>篇幅问题，这篇文章并没有深入，小伙伴们也可以直接使用 debug 的方式去看看 SpringBoot 自动装配部分的源代码。</p>

<h2 id="前言">前言</h2>

<p>使用过 Spring 的小伙伴，一定有被 XML 配置统治的恐惧。即使 Spring 后面引入了基于注解的配置，我们在开启某些 Spring 特性或者引入第三方依赖的时候，还是需要用 XML 或 Java 进行显式配置。</p>

<p>举个例子。没有 Spring Boot 的时候，我们写一个 RestFul Web 服务，还首先需要进行如下配置。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RESTConfiguration</span>
<span class="o">{</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">View</span> <span class="nf">jsonTemplate</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">MappingJackson2JsonView</span> <span class="n">view</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MappingJackson2JsonView</span><span class="o">();</span>
        <span class="n">view</span><span class="o">.</span><span class="na">setPrettyPrint</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">view</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">ViewResolver</span> <span class="nf">viewResolver</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">BeanNameViewResolver</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">spring-servlet.xml</code></p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
    <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="na">xmlns:context=</span><span class="s">"http://www.springframework.org/schema/context"</span>
    <span class="na">xmlns:mvc=</span><span class="s">"http://www.springframework.org/schema/mvc"</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context/ http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/mvc/ http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;context:component-scan</span> <span class="na">base-package=</span><span class="s">"com.howtodoinjava.demo"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;mvc:annotation-driven</span> <span class="nt">/&gt;</span>

    <span class="c">&lt;!-- JSON Support --&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">name=</span><span class="s">"viewResolver"</span> <span class="na">class=</span><span class="s">"org.springframework.web.servlet.view.BeanNameViewResolver"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">name=</span><span class="s">"jsonTemplate"</span> <span class="na">class=</span><span class="s">"org.springframework.web.servlet.view.json.MappingJackson2JsonView"</span><span class="nt">/&gt;</span>

<span class="nt">&lt;/beans&gt;</span>
</code></pre></div></div>

<p>但是，Spring Boot 项目，我们只需要添加相关依赖，无需配置，通过启动下面的 <code class="language-plaintext highlighter-rouge">main</code> 方法即可。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootApplication</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoApplication</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">DemoApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>并且，我们通过 Spring Boot 的全局配置文件 <code class="language-plaintext highlighter-rouge">application.properties</code>或<code class="language-plaintext highlighter-rouge">application.yml</code>即可对项目进行设置比如更换端口号，配置 JPA 属性等等。</p>

<p><strong>为什么 Spring Boot 使用起来这么酸爽呢？</strong> 这得益于其自动装配。<strong>自动装配可以说是 Spring Boot 的核心，那究竟什么是自动装配呢？</strong></p>

<h2 id="什么是-springboot-自动装配">什么是 SpringBoot 自动装配？</h2>

<p>我们现在提到自动装配的时候，一般会和 Spring Boot 联系在一起。但是，实际上 Spring Framework 早就实现了这个功能。Spring Boot 只是在其基础上，通过 SPI 的方式，做了进一步优化。</p>

<blockquote>
  <p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的<code class="language-plaintext highlighter-rouge">META-INF/spring.factories</code>文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。
自 Spring Boot 3.0 开始，自动配置包的路径从<code class="language-plaintext highlighter-rouge">META-INF/spring.factories</code> 修改为 <code class="language-plaintext highlighter-rouge">META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>。</p>
</blockquote>

<p>没有 Spring Boot 的情况下，如果我们需要引入第三方依赖，需要手动配置，非常麻烦。但是，Spring Boot 中，我们直接引入一个 starter 即可。比如你想要在项目中使用 redis 的话，直接在项目中引入对应的 starter 即可。</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-data-redis<span class="nt">&lt;/artifactId&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>

<p>引入 starter 之后，我们通过少量注解和一些简单的配置就能使用第三方组件提供的功能了。</p>

<p>在我看来，自动装配可以简单理解为：<strong>通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</strong></p>

<h2 id="springboot-是如何实现自动装配的">SpringBoot 是如何实现自动装配的？</h2>

<p>我们先看一下 SpringBoot 的核心注解 <code class="language-plaintext highlighter-rouge">SpringBootApplication</code> 。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Target</span><span class="o">({</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">})</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Documented</span>
<span class="nd">@Inherited</span>
<span class="o">&lt;</span><span class="mi">1</span><span class="o">.&gt;</span><span class="nd">@SpringBootConfiguration</span>
<span class="o">&lt;</span><span class="mi">2</span><span class="o">.&gt;</span><span class="nd">@ComponentScan</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">.&gt;</span><span class="nd">@EnableAutoConfiguration</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">SpringBootApplication</span> <span class="o">{</span>

<span class="o">}</span>

<span class="nd">@Target</span><span class="o">({</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">})</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Documented</span>
<span class="nd">@Configuration</span> <span class="c1">//实际上它也是一个配置类</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">SpringBootConfiguration</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<p>大概可以把 <code class="language-plaintext highlighter-rouge">@SpringBootApplication</code>看作是 <code class="language-plaintext highlighter-rouge">@Configuration</code>、<code class="language-plaintext highlighter-rouge">@EnableAutoConfiguration</code>、<code class="language-plaintext highlighter-rouge">@ComponentScan</code> 注解的集合。根据 SpringBoot 官网，这三个注解的作用分别是：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li>
  <li><code class="language-plaintext highlighter-rouge">@Configuration</code>：允许在上下文中注册额外的 bean 或导入其他配置类</li>
  <li><code class="language-plaintext highlighter-rouge">@ComponentScan</code>：扫描被<code class="language-plaintext highlighter-rouge">@Component</code> (<code class="language-plaintext highlighter-rouge">@Service</code>,<code class="language-plaintext highlighter-rouge">@Controller</code>)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。如下图所示，容器中将排除<code class="language-plaintext highlighter-rouge">TypeExcludeFilter</code>和<code class="language-plaintext highlighter-rouge">AutoConfigurationExcludeFilter</code>。</li>
</ul>

<p><img src="https://oss.javaguide.cn/p3-juejin/bcc73490afbe4c6ba62acde6a94ffdfd~tplv-k3u1fbpfcp-watermark.png" alt="" /></p>

<p><code class="language-plaintext highlighter-rouge">@EnableAutoConfiguration</code> 是实现自动装配的重要注解，我们以这个注解入手。</p>

<h3 id="enableautoconfiguration实现自动装配的核心注解">@EnableAutoConfiguration:实现自动装配的核心注解</h3>

<p><code class="language-plaintext highlighter-rouge">EnableAutoConfiguration</code> 只是一个简单地注解，自动装配核心功能的实现实际是通过 <code class="language-plaintext highlighter-rouge">AutoConfigurationImportSelector</code>类。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Target</span><span class="o">({</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">})</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Documented</span>
<span class="nd">@Inherited</span>
<span class="nd">@AutoConfigurationPackage</span> <span class="c1">//作用：将main包下的所有组件注册到容器中</span>
<span class="nd">@Import</span><span class="o">({</span><span class="nc">AutoConfigurationImportSelector</span><span class="o">.</span><span class="na">class</span><span class="o">})</span> <span class="c1">//加载自动装配类 xxxAutoconfiguration</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">EnableAutoConfiguration</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="no">ENABLED_OVERRIDE_PROPERTY</span> <span class="o">=</span> <span class="s">"spring.boot.enableautoconfiguration"</span><span class="o">;</span>

    <span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">exclude</span><span class="o">()</span> <span class="k">default</span> <span class="o">{};</span>

    <span class="nc">String</span><span class="o">[]</span> <span class="nf">excludeName</span><span class="o">()</span> <span class="k">default</span> <span class="o">{};</span>
<span class="o">}</span>
</code></pre></div></div>

<p>我们现在重点分析下<code class="language-plaintext highlighter-rouge">AutoConfigurationImportSelector</code> 类到底做了什么？</p>

<h3 id="autoconfigurationimportselector加载自动装配类">AutoConfigurationImportSelector:加载自动装配类</h3>

<p><code class="language-plaintext highlighter-rouge">AutoConfigurationImportSelector</code>类的继承体系如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AutoConfigurationImportSelector</span> <span class="kd">implements</span> <span class="nc">DeferredImportSelector</span><span class="o">,</span> <span class="nc">BeanClassLoaderAware</span><span class="o">,</span> <span class="nc">ResourceLoaderAware</span><span class="o">,</span> <span class="nc">BeanFactoryAware</span><span class="o">,</span> <span class="nc">EnvironmentAware</span><span class="o">,</span> <span class="nc">Ordered</span> <span class="o">{</span>

<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">DeferredImportSelector</span> <span class="kd">extends</span> <span class="nc">ImportSelector</span> <span class="o">{</span>

<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ImportSelector</span> <span class="o">{</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="nf">selectImports</span><span class="o">(</span><span class="nc">AnnotationMetadata</span> <span class="n">var1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>可以看出，<code class="language-plaintext highlighter-rouge">AutoConfigurationImportSelector</code> 类实现了 <code class="language-plaintext highlighter-rouge">ImportSelector</code>接口，也就实现了这个接口中的 <code class="language-plaintext highlighter-rouge">selectImports</code>方法，该方法主要用于<strong>获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</strong>。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="no">NO_IMPORTS</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

<span class="kd">public</span> <span class="nc">String</span><span class="o">[]</span> <span class="nf">selectImports</span><span class="o">(</span><span class="nc">AnnotationMetadata</span> <span class="n">annotationMetadata</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// &lt;1&gt;.判断自动装配开关是否打开</span>
        <span class="k">if</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">isEnabled</span><span class="o">(</span><span class="n">annotationMetadata</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="no">NO_IMPORTS</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="c1">//&lt;2&gt;.获取所有需要装配的bean</span>
            <span class="nc">AutoConfigurationMetadata</span> <span class="n">autoConfigurationMetadata</span> <span class="o">=</span> <span class="nc">AutoConfigurationMetadataLoader</span><span class="o">.</span><span class="na">loadMetadata</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">beanClassLoader</span><span class="o">);</span>
            <span class="nc">AutoConfigurationImportSelector</span><span class="o">.</span><span class="na">AutoConfigurationEntry</span> <span class="n">autoConfigurationEntry</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getAutoConfigurationEntry</span><span class="o">(</span><span class="n">autoConfigurationMetadata</span><span class="o">,</span> <span class="n">annotationMetadata</span><span class="o">);</span>
            <span class="k">return</span> <span class="nc">StringUtils</span><span class="o">.</span><span class="na">toStringArray</span><span class="o">(</span><span class="n">autoConfigurationEntry</span><span class="o">.</span><span class="na">getConfigurations</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>这里我们需要重点关注一下<code class="language-plaintext highlighter-rouge">getAutoConfigurationEntry()</code>方法，这个方法主要负责加载自动配置类的。</p>

<p>该方法调用链如下：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/3c1200712655443ca4b38500d615bb70~tplv-k3u1fbpfcp-watermark.png" alt="" /></p>

<p>现在我们结合<code class="language-plaintext highlighter-rouge">getAutoConfigurationEntry()</code>的源码来详细分析一下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">AutoConfigurationEntry</span> <span class="no">EMPTY_ENTRY</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AutoConfigurationEntry</span><span class="o">();</span>

<span class="nc">AutoConfigurationEntry</span> <span class="nf">getAutoConfigurationEntry</span><span class="o">(</span><span class="nc">AutoConfigurationMetadata</span> <span class="n">autoConfigurationMetadata</span><span class="o">,</span> <span class="nc">AnnotationMetadata</span> <span class="n">annotationMetadata</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//&lt;1&gt;.</span>
        <span class="k">if</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">isEnabled</span><span class="o">(</span><span class="n">annotationMetadata</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="no">EMPTY_ENTRY</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">//&lt;2&gt;.</span>
            <span class="nc">AnnotationAttributes</span> <span class="n">attributes</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getAttributes</span><span class="o">(</span><span class="n">annotationMetadata</span><span class="o">);</span>
            <span class="c1">//&lt;3&gt;.</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">configurations</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getCandidateConfigurations</span><span class="o">(</span><span class="n">annotationMetadata</span><span class="o">,</span> <span class="n">attributes</span><span class="o">);</span>
            <span class="c1">//&lt;4&gt;.</span>
            <span class="n">configurations</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">removeDuplicates</span><span class="o">(</span><span class="n">configurations</span><span class="o">);</span>
            <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">exclusions</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getExclusions</span><span class="o">(</span><span class="n">annotationMetadata</span><span class="o">,</span> <span class="n">attributes</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">checkExcludedClasses</span><span class="o">(</span><span class="n">configurations</span><span class="o">,</span> <span class="n">exclusions</span><span class="o">);</span>
            <span class="n">configurations</span><span class="o">.</span><span class="na">removeAll</span><span class="o">(</span><span class="n">exclusions</span><span class="o">);</span>
            <span class="n">configurations</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">configurations</span><span class="o">,</span> <span class="n">autoConfigurationMetadata</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">fireAutoConfigurationImportEvents</span><span class="o">(</span><span class="n">configurations</span><span class="o">,</span> <span class="n">exclusions</span><span class="o">);</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nc">AutoConfigurationImportSelector</span><span class="o">.</span><span class="na">AutoConfigurationEntry</span><span class="o">(</span><span class="n">configurations</span><span class="o">,</span> <span class="n">exclusions</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<p><strong>第 1 步</strong>:</p>

<p>判断自动装配开关是否打开。默认<code class="language-plaintext highlighter-rouge">spring.boot.enableautoconfiguration=true</code>，可在 <code class="language-plaintext highlighter-rouge">application.properties</code> 或 <code class="language-plaintext highlighter-rouge">application.yml</code> 中设置</p>

<p><img src="https://oss.javaguide.cn/p3-juejin/77aa6a3727ea4392870f5cccd09844ab~tplv-k3u1fbpfcp-watermark.png" alt="" /></p>

<p><strong>第 2 步</strong>：</p>

<p>用于获取<code class="language-plaintext highlighter-rouge">EnableAutoConfiguration</code>注解中的 <code class="language-plaintext highlighter-rouge">exclude</code> 和 <code class="language-plaintext highlighter-rouge">excludeName</code>。</p>

<p><img src="https://oss.javaguide.cn/p3-juejin/3d6ec93bbda1453aa08c52b49516c05a~tplv-k3u1fbpfcp-zoom-1.png" alt="" /></p>

<p><strong>第 3 步</strong></p>

<p>获取需要自动装配的所有配置类，读取<code class="language-plaintext highlighter-rouge">META-INF/spring.factories</code></p>

<pre><code class="language-plain">spring-boot/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories
</code></pre>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/58c51920efea4757aa1ec29c6d5f9e36~tplv-k3u1fbpfcp-watermark.png" alt="" /></p>

<p>从下图可以看到这个文件的配置内容都被我们读取到了。<code class="language-plaintext highlighter-rouge">XXXAutoConfiguration</code>的作用就是按需加载组件。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/94d6e1a060ac41db97043e1758789026~tplv-k3u1fbpfcp-watermark.png" alt="" /></p>

<p>不光是这个依赖下的<code class="language-plaintext highlighter-rouge">META-INF/spring.factories</code>被读取到，所有 Spring Boot Starter 下的<code class="language-plaintext highlighter-rouge">META-INF/spring.factories</code>都会被读取到。</p>

<p>所以，你可以清楚滴看到， druid 数据库连接池的 Spring Boot Starter 就创建了<code class="language-plaintext highlighter-rouge">META-INF/spring.factories</code>文件。</p>

<p>如果，我们自己要创建一个 Spring Boot Starter，这一步是必不可少的。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/68fa66aeee474b0385f94d23bcfe1745~tplv-k3u1fbpfcp-watermark.png" alt="" /></p>

<p><strong>第 4 步</strong>：</p>

<p>到这里可能面试官会问你:“<code class="language-plaintext highlighter-rouge">spring.factories</code>中这么多配置，每次启动都要全部加载么？”。</p>

<p>很明显，这是不现实的。我们 debug 到后面你会发现，<code class="language-plaintext highlighter-rouge">configurations</code> 的值变小了。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/267f8231ae2e48d982154140af6437b0~tplv-k3u1fbpfcp-watermark.png" alt="" /></p>

<p>因为，这一步有经历了一遍筛选，<code class="language-plaintext highlighter-rouge">@ConditionalOnXXX</code> 中的所有条件都满足，该类才会生效。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="c1">// 检查相关的类：RabbitTemplate 和 Channel是否存在</span>
<span class="c1">// 存在才会加载</span>
<span class="nd">@ConditionalOnClass</span><span class="o">({</span> <span class="nc">RabbitTemplate</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">Channel</span><span class="o">.</span><span class="na">class</span> <span class="o">})</span>
<span class="nd">@EnableConfigurationProperties</span><span class="o">(</span><span class="nc">RabbitProperties</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@Import</span><span class="o">(</span><span class="nc">RabbitAnnotationDrivenConfiguration</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RabbitAutoConfiguration</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<p>有兴趣的童鞋可以详细了解下 Spring Boot 提供的条件注解</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@ConditionalOnBean</code>：当容器里有指定 Bean 的条件下</li>
  <li><code class="language-plaintext highlighter-rouge">@ConditionalOnMissingBean</code>：当容器里没有指定 Bean 的情况下</li>
  <li><code class="language-plaintext highlighter-rouge">@ConditionalOnSingleCandidate</code>：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean</li>
  <li><code class="language-plaintext highlighter-rouge">@ConditionalOnClass</code>：当类路径下有指定类的条件下</li>
  <li><code class="language-plaintext highlighter-rouge">@ConditionalOnMissingClass</code>：当类路径下没有指定类的条件下</li>
  <li><code class="language-plaintext highlighter-rouge">@ConditionalOnProperty</code>：指定的属性是否有指定的值</li>
  <li><code class="language-plaintext highlighter-rouge">@ConditionalOnResource</code>：类路径是否有指定的值</li>
  <li><code class="language-plaintext highlighter-rouge">@ConditionalOnExpression</code>：基于 SpEL 表达式作为判断条件</li>
  <li><code class="language-plaintext highlighter-rouge">@ConditionalOnJava</code>：基于 Java 版本作为判断条件</li>
  <li><code class="language-plaintext highlighter-rouge">@ConditionalOnJndi</code>：在 JNDI 存在的条件下差在指定的位置</li>
  <li><code class="language-plaintext highlighter-rouge">@ConditionalOnNotWebApplication</code>：当前项目不是 Web 项目的条件下</li>
  <li><code class="language-plaintext highlighter-rouge">@ConditionalOnWebApplication</code>：当前项目是 Web 项 目的条件下</li>
</ul>

<h2 id="如何实现一个-starter">如何实现一个 Starter</h2>

<p>光说不练假把式，现在就来撸一个 starter，实现自定义线程池</p>

<p>第一步，创建<code class="language-plaintext highlighter-rouge">threadpool-spring-boot-starter</code>工程</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/1ff0ebe7844f40289eb60213af72c5a6~tplv-k3u1fbpfcp-watermark.png" alt="" /></p>

<p>第二步，引入 Spring Boot 相关依赖</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/5e14254276604f87b261e5a80a354cc0~tplv-k3u1fbpfcp-watermark.png" alt="" /></p>

<p>第三步，创建<code class="language-plaintext highlighter-rouge">ThreadPoolAutoConfiguration</code></p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/1843f1d12c5649fba85fd7b4e4a59e39~tplv-k3u1fbpfcp-watermark.png" alt="" /></p>

<p>第四步，在<code class="language-plaintext highlighter-rouge">threadpool-spring-boot-starter</code>工程的 resources 包下创建<code class="language-plaintext highlighter-rouge">META-INF/spring.factories</code>文件</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/97b738321f1542ea8140484d6aaf0728~tplv-k3u1fbpfcp-watermark.png" alt="" /></p>

<p>最后新建工程引入<code class="language-plaintext highlighter-rouge">threadpool-spring-boot-starter</code></p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/edcdd8595a024aba85b6bb20d0e3fed4~tplv-k3u1fbpfcp-watermark.png" alt="" /></p>

<p>测试通过！！！</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/9a265eea4de742a6bbdbbaa75f437307~tplv-k3u1fbpfcp-watermark.png" alt="" /></p>

<h2 id="总结">总结</h2>

<p>Spring Boot 通过<code class="language-plaintext highlighter-rouge">@EnableAutoConfiguration</code>开启自动装配，通过 SpringFactoriesLoader 最终加载<code class="language-plaintext highlighter-rouge">META-INF/spring.factories</code>中的自动配置类实现自动装配，自动配置类其实就是通过<code class="language-plaintext highlighter-rouge">@Conditional</code>按需加载的配置类，想要其生效必须引入<code class="language-plaintext highlighter-rouge">spring-boot-starter-xxx</code>包实现起步依赖</p>

<!-- @include: @article-footer.snippet.md -->
