<blockquote>
  <p>原文地址：<a href="https://juejin.cn/post/7122014462181113887，JavaGuide">https://juejin.cn/post/7122014462181113887，JavaGuide</a> 对本文进行了完善总结。</p>
</blockquote>

<p>我有一个朋友做了一个小破站，现在要实现一个站内信 Web 消息推送的功能，对，就是下图这个小红点，一个很常用的功能。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192380.png" alt="站内信 Web 消息推送" /></p>

<p>不过他还没想好用什么方式做，这里我帮他整理了一下几种方案，并简单做了实现。</p>

<h2 id="什么是消息推送">什么是消息推送？</h2>

<p>推送的场景比较多，比如有人关注我的公众号，这时我就会收到一条推送消息，以此来吸引我点击打开应用。</p>

<p>消息推送通常是指网站的运营工作等人员，通过某种工具对用户当前网页或移动设备 APP 进行的主动消息推送。</p>

<p>消息推送一般又分为 Web 端消息推送和移动端消息推送。</p>

<p>移动端消息推送示例：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/IKleJ9auR1Ojdicyr0bH.png" alt="移动端消息推送示例" /></p>

<p>Web 端消息推送示例：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/image-20220819100512941.png" alt="Web 端消息推送示例" /></p>

<p>在具体实现之前，咱们再来分析一下前边的需求，其实功能很简单，只要触发某个事件（主动分享了资源或者后台主动推送消息），Web 页面的通知小红点就会实时的 <code class="language-plaintext highlighter-rouge">+1</code> 就可以了。</p>

<p>通常在服务端会有若干张消息推送表，用来记录用户触发不同事件所推送不同类型的消息，前端主动查询（拉）或者被动接收（推）用户所有未读的消息数。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192384.png" alt="消息推送表" /></p>

<p>消息推送无非是推（push）和拉（pull）两种形式，下边我们逐个了解下。</p>

<h2 id="消息推送常见方案">消息推送常见方案</h2>

<h3 id="短轮询">短轮询</h3>

<p><strong>轮询(polling)</strong> 应该是实现消息推送方案中最简单的一种，这里我们暂且将轮询分为短轮询和长轮询。</p>

<p>短轮询很好理解，指定的时间间隔，由浏览器向服务器发出 HTTP 请求，服务器实时返回未读消息数据给客户端，浏览器再做渲染显示。</p>

<p>一个简单的 JS 定时器就可以搞定，每秒钟请求一次未读消息数接口，返回的数据展示即可。</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">setInterval</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 方法请求</span>
  <span class="nf">messageCount</span><span class="p">().</span><span class="nf">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">code</span> <span class="o">===</span> <span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">messageCount</span> <span class="o">=</span> <span class="nx">res</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</code></pre></div></div>

<p>效果还是可以的，短轮询实现固然简单，缺点也是显而易见，由于推送数据并不会频繁变更，无论后端此时是否有新的消息产生，客户端都会进行请求，势必会对服务端造成很大压力，浪费带宽和服务器资源。</p>

<h3 id="长轮询">长轮询</h3>

<p>长轮询是对上边短轮询的一种改进版本，在尽可能减少对服务器资源浪费的同时，保证消息的相对实时性。长轮询在中间件中应用的很广泛，比如 Nacos 和 Apollo 配置中心，消息队列 Kafka、RocketMQ 中都有用到长轮询。</p>

<p><a href="https://mp.weixin.qq.com/s/94ftESkDoZI9gAGflLiGwg">Nacos 配置中心交互模型是 push 还是 pull？</a>一文中我详细介绍过 Nacos 长轮询的实现原理，感兴趣的小伙伴可以瞅瞅。</p>

<p>长轮询其实原理跟轮询差不多，都是采用轮询的方式。不过，如果服务端的数据没有发生变更，会 一直 hold 住请求，直到服务端的数据发生变化，或者等待一定时间超时才会返回。返回后，客户端又会立即再次发起下一次长轮询。</p>

<p>这次我使用 Apollo 配置中心实现长轮询的方式，应用了一个类<code class="language-plaintext highlighter-rouge">DeferredResult</code>，它是在 Servlet3.0 后经过 Spring 封装提供的一种异步请求机制，直意就是延迟结果。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192386.png" alt="长轮询示意图" /></p>

<p><code class="language-plaintext highlighter-rouge">DeferredResult</code>可以允许容器线程快速释放占用的资源，不阻塞请求线程，以此接受更多的请求提升系统的吞吐量，然后启动异步工作线程处理真正的业务逻辑，处理完成调用<code class="language-plaintext highlighter-rouge">DeferredResult.setResult(200)</code>提交响应结果。</p>

<p>下边我们用长轮询来实现消息推送。</p>

<p>因为一个 ID 可能会被多个长轮询请求监听，所以我采用了 Guava 包提供的<code class="language-plaintext highlighter-rouge">Multimap</code>结构存放长轮询，一个 key 可以对应多个 value。一旦监听到 key 发生变化，对应的所有长轮询都会响应。前端得到非请求超时的状态码，知晓数据变更，主动查询未读消息数接口，更新页面数据。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/polling"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PollingController</span> <span class="o">{</span>

    <span class="c1">// 存放监听某个Id的长轮询集合</span>
    <span class="c1">// 线程同步结构</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Multimap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">DeferredResult</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">watchRequests</span> <span class="o">=</span> <span class="nc">Multimaps</span><span class="o">.</span><span class="na">synchronizedMultimap</span><span class="o">(</span><span class="nc">HashMultimap</span><span class="o">.</span><span class="na">create</span><span class="o">());</span>

    <span class="cm">/**
     * 设置监听
     */</span>
    <span class="nd">@GetMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"watch/{id}"</span><span class="o">)</span>
    <span class="nd">@ResponseBody</span>
    <span class="kd">public</span> <span class="nc">DeferredResult</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">watch</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="nc">String</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 延迟对象设置超时时间</span>
        <span class="nc">DeferredResult</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">deferredResult</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DeferredResult</span><span class="o">&lt;&gt;(</span><span class="no">TIME_OUT</span><span class="o">);</span>
        <span class="c1">// 异步请求完成时移除 key，防止内存溢出</span>
        <span class="n">deferredResult</span><span class="o">.</span><span class="na">onCompletion</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">watchRequests</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">deferredResult</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="c1">// 注册长轮询请求</span>
        <span class="n">watchRequests</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">deferredResult</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">deferredResult</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 变更数据
     */</span>
    <span class="nd">@GetMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"publish/{id}"</span><span class="o">)</span>
    <span class="nd">@ResponseBody</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">publish</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="nc">String</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 数据变更 取出监听ID的所有长轮询请求，并一一响应处理</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">watchRequests</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">id</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">Collection</span><span class="o">&lt;</span><span class="nc">DeferredResult</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">deferredResults</span> <span class="o">=</span> <span class="n">watchRequests</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">DeferredResult</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">deferredResult</span> <span class="o">:</span> <span class="n">deferredResults</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">deferredResult</span><span class="o">.</span><span class="na">setResult</span><span class="o">(</span><span class="s">"我更新了"</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">Date</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="s">"success"</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>当请求超过设置的超时时间，会抛出<code class="language-plaintext highlighter-rouge">AsyncRequestTimeoutException</code>异常，这里直接用<code class="language-plaintext highlighter-rouge">@ControllerAdvice</code>全局捕获统一返回即可，前端获取约定好的状态码后再次发起长轮询请求，如此往复调用。</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ControllerAdvice</span>
<span class="k">public</span> <span class="kd">class</span> <span class="nc">AsyncRequestTimeoutHandler</span> <span class="p">{</span>

    <span class="nd">@ResponseStatus</span><span class="p">(</span><span class="nc">HttpStatus</span><span class="p">.</span><span class="nc">NOT_MODIFIED</span><span class="p">)</span>
    <span class="nd">@ResponseBody</span>
    <span class="nd">@ExceptionHandler</span><span class="p">(</span><span class="nc">AsyncRequestTimeoutException</span><span class="p">.</span><span class="k">class</span><span class="p">)</span>
    <span class="k">public</span> <span class="nc">String</span> <span class="nf">asyncRequestTimeoutHandler</span><span class="p">(</span><span class="nc">AsyncRequestTimeoutException</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nc">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s">"异步请求超时"</span><span class="p">);</span>
        <span class="k">return</span> <span class="s">"304"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们来测试一下，首先页面发起长轮询请求<code class="language-plaintext highlighter-rouge">/polling/watch/10086</code>监听消息更变，请求被挂起，不变更数据直至超时，再次发起了长轮询请求；紧接着手动变更数据<code class="language-plaintext highlighter-rouge">/polling/publish/10086</code>，长轮询得到响应，前端处理业务逻辑完成后再次发起请求，如此循环往复。</p>

<p>长轮询相比于短轮询在性能上提升了很多，但依然会产生较多的请求，这是它的一点不完美的地方。</p>

<h3 id="iframe-流">iframe 流</h3>

<p>iframe 流就是在页面中插入一个隐藏的<code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code>标签，通过在<code class="language-plaintext highlighter-rouge">src</code>中请求消息数量 API 接口，由此在服务端和客户端之间创建一条长连接，服务端持续向<code class="language-plaintext highlighter-rouge">iframe</code>传输数据。</p>

<p>传输的数据通常是 HTML、或是内嵌的 JavaScript 脚本，来达到实时更新页面的效果。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192388.png" alt="iframe 流示意图" /></p>

<p>这种方式实现简单，前端只要一个<code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code>标签搞定了</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;iframe</span> <span class="na">src=</span><span class="s">"/iframe/message"</span> <span class="na">style=</span><span class="s">"display:none"</span><span class="nt">&gt;&lt;/iframe&gt;</span>
</code></pre></div></div>

<p>服务端直接组装 HTML、JS 脚本数据向 response 写入就行了</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/iframe"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">IframeController</span> <span class="o">{</span>
    <span class="nd">@GetMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"message"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">message</span><span class="o">(</span><span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">response</span><span class="o">.</span><span class="na">setHeader</span><span class="o">(</span><span class="s">"Pragma"</span><span class="o">,</span> <span class="s">"no-cache"</span><span class="o">);</span>
            <span class="n">response</span><span class="o">.</span><span class="na">setDateHeader</span><span class="o">(</span><span class="s">"Expires"</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
            <span class="n">response</span><span class="o">.</span><span class="na">setHeader</span><span class="o">(</span><span class="s">"Cache-Control"</span><span class="o">,</span> <span class="s">"no-cache,no-store"</span><span class="o">);</span>
            <span class="n">response</span><span class="o">.</span><span class="na">setStatus</span><span class="o">(</span><span class="nc">HttpServletResponse</span><span class="o">.</span><span class="na">SC_OK</span><span class="o">);</span>
            <span class="n">response</span><span class="o">.</span><span class="na">getWriter</span><span class="o">().</span><span class="na">print</span><span class="o">(</span><span class="s">" &lt;script type=\"text/javascript\"&gt;\n"</span> <span class="o">+</span>
                    <span class="s">"parent.document.getElementById('clock').innerHTML = \""</span> <span class="o">+</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">+</span> <span class="s">"\";"</span> <span class="o">+</span>
                    <span class="s">"parent.document.getElementById('count').innerHTML = \""</span> <span class="o">+</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">+</span> <span class="s">"\";"</span> <span class="o">+</span>
                    <span class="s">"&lt;/script&gt;"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>iframe 流的服务器开销很大，而且 IE、Chrome 等浏览器一直会处于 loading 状态，图标会不停旋转，简直是强迫症杀手。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192389.png" alt="iframe 流效果" /></p>

<p>iframe 流非常不友好，强烈不推荐。</p>

<h3 id="sse-推荐">SSE (推荐)</h3>

<p>很多人可能不知道，服务端向客户端推送消息，其实除了可以用<code class="language-plaintext highlighter-rouge">WebSocket</code>这种耳熟能详的机制外，还有一种服务器发送事件(Server-Sent Events)，简称 SSE。这是一种服务器端到客户端(浏览器)的单向消息推送。</p>

<p>大名鼎鼎的 ChatGPT 就是采用的 SSE。对于需要长时间等待响应的对话场景，ChatGPT 采用了一种巧妙的策略：它会将已经计算出的数据“推送”给用户，并利用 SSE 技术在计算过程中持续返回数据。这样做的好处是可以避免用户因等待时间过长而选择关闭页面。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/chatgpt-sse.png" alt="ChatGPT 使用 SSE 实现对话" /></p>

<p>SSE 基于 HTTP 协议的，我们知道一般意义上的 HTTP 协议是无法做到服务端主动向客户端推送消息的，但 SSE 是个例外，它变换了一种思路。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192390.png" alt="" /></p>

<p>SSE 在服务器和客户端之间打开一个单向通道，服务端响应的不再是一次性的数据包而是<code class="language-plaintext highlighter-rouge">text/event-stream</code>类型的数据流信息，在有数据变更时从服务器流式传输到客户端。</p>

<p>整体的实现思路有点类似于在线视频播放，视频流会连续不断的推送到浏览器，你也可以理解成，客户端在完成一次用时很长（网络不畅）的下载。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192391.png" alt="SSE 示意图" /></p>

<p>SSE 与 WebSocket 作用相似，都可以建立服务端与浏览器之间的通信，实现服务端向客户端推送消息，但还是有些许不同：</p>

<ul>
  <li>SSE 是基于 HTTP 协议的，它们不需要特殊的协议或服务器实现即可工作；WebSocket 需单独服务器来处理协议。</li>
  <li>SSE 单向通信，只能由服务端向客户端单向通信；WebSocket 全双工通信，即通信的双方可以同时发送和接受信息。</li>
  <li>SSE 实现简单开发成本低，无需引入其他组件；WebSocket 传输数据需做二次解析，开发门槛高一些。</li>
  <li>SSE 默认支持断线重连；WebSocket 则需要自己实现。</li>
  <li>SSE 只能传送文本消息，二进制数据需要经过编码后传送；WebSocket 默认支持传送二进制数据。</li>
</ul>

<p><strong>SSE 与 WebSocket 该如何选择？</strong></p>

<blockquote>
  <p>技术并没有好坏之分，只有哪个更合适</p>
</blockquote>

<p>SSE 好像一直不被大家所熟知，一部分原因是出现了 WebSocket，这个提供了更丰富的协议来执行双向、全双工通信。对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。</p>

<p>但是，在某些情况下，不需要从客户端发送数据。而你只需要一些服务器操作的更新。比如：站内信、未读消息数、状态更新、股票行情、监控数量等场景，SEE 不管是从实现的难易和成本上都更加有优势。此外，SSE 具有 WebSocket 在设计上缺乏的多种功能，例如：自动重新连接、事件 ID 和发送任意事件的能力。</p>

<p>前端只需进行一次 HTTP 请求，带上唯一 ID，打开事件流，监听服务端推送的事件就可以了</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
    <span class="kd">let</span> <span class="nx">source</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">userId</span> <span class="o">=</span> <span class="mi">7777</span>
    <span class="k">if </span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">EventSource</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 建立连接</span>
        <span class="nx">source</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EventSource</span><span class="p">(</span><span class="dl">'</span><span class="s1">http://localhost:7777/sse/sub/</span><span class="dl">'</span><span class="o">+</span><span class="nx">userId</span><span class="p">);</span>
        <span class="nf">setMessageInnerHTML</span><span class="p">(</span><span class="dl">"</span><span class="s2">连接用户=</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">userId</span><span class="p">);</span>
        <span class="cm">/**
         * 连接一旦建立，就会触发open事件
         * 另一种写法：source.onopen = function (event) {}
         */</span>
        <span class="nx">source</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">open</span><span class="dl">'</span><span class="p">,</span> <span class="nf">function </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">setMessageInnerHTML</span><span class="p">(</span><span class="dl">"</span><span class="s2">建立连接。。。</span><span class="dl">"</span><span class="p">);</span>
        <span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
        <span class="cm">/**
         * 客户端收到服务器发来的数据
         * 另一种写法：source.onmessage = function (event) {}
         */</span>
        <span class="nx">source</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">message</span><span class="dl">'</span><span class="p">,</span> <span class="nf">function </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">setMessageInnerHTML</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">setMessageInnerHTML</span><span class="p">(</span><span class="dl">"</span><span class="s2">你的浏览器不支持SSE</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="o">&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span></code></pre></div></div>

<p>服务端的实现更简单，创建一个<code class="language-plaintext highlighter-rouge">SseEmitter</code>对象放入<code class="language-plaintext highlighter-rouge">sseEmitterMap</code>进行管理</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">SseEmitter</span><span class="o">&gt;</span> <span class="n">sseEmitterMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConcurrentHashMap</span><span class="o">&lt;&gt;();</span>

<span class="cm">/**
 * 创建连接
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">SseEmitter</span> <span class="nf">connect</span><span class="o">(</span><span class="nc">String</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// 设置超时时间，0表示不过期。默认30秒</span>
        <span class="nc">SseEmitter</span> <span class="n">sseEmitter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SseEmitter</span><span class="o">(</span><span class="mi">0L</span><span class="o">);</span>
        <span class="c1">// 注册回调</span>
        <span class="n">sseEmitter</span><span class="o">.</span><span class="na">onCompletion</span><span class="o">(</span><span class="n">completionCallBack</span><span class="o">(</span><span class="n">userId</span><span class="o">));</span>
        <span class="n">sseEmitter</span><span class="o">.</span><span class="na">onError</span><span class="o">(</span><span class="n">errorCallBack</span><span class="o">(</span><span class="n">userId</span><span class="o">));</span>
        <span class="n">sseEmitter</span><span class="o">.</span><span class="na">onTimeout</span><span class="o">(</span><span class="n">timeoutCallBack</span><span class="o">(</span><span class="n">userId</span><span class="o">));</span>
        <span class="n">sseEmitterMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">sseEmitter</span><span class="o">);</span>
        <span class="n">count</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">sseEmitter</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"创建新的sse连接异常，当前用户：{}"</span><span class="o">,</span> <span class="n">userId</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/**
 * 给指定用户发送消息
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sendMessage</span><span class="o">(</span><span class="nc">String</span> <span class="n">userId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">sseEmitterMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">userId</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">sseEmitterMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">userId</span><span class="o">).</span><span class="na">send</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"用户[{}]推送异常:{}"</span><span class="o">,</span> <span class="n">userId</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
            <span class="n">removeUser</span><span class="o">(</span><span class="n">userId</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>注意：</strong> SSE 不支持 IE 浏览器，对其他主流浏览器兼容性做的还不错。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192393.png" alt="SSE 兼容性" /></p>

<h3 id="websocket">Websocket</h3>

<p>Websocket 应该是大家都比较熟悉的一种实现消息推送的方式，上边我们在讲 SSE 的时候也和 Websocket 进行过比较。</p>

<p>这是一种在 TCP 连接上进行全双工通信的协议，建立客户端和服务器之间的通信渠道。浏览器和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192394.png" alt="Websocket 示意图" /></p>

<p>WebSocket 的工作过程可以分为以下几个步骤：</p>

<ol>
  <li>客户端向服务器发送一个 HTTP 请求，请求头中包含 <code class="language-plaintext highlighter-rouge">Upgrade: websocket</code> 和 <code class="language-plaintext highlighter-rouge">Sec-WebSocket-Key</code> 等字段，表示要求升级协议为 WebSocket；</li>
  <li>服务器收到这个请求后，会进行升级协议的操作，如果支持 WebSocket，它将回复一个 HTTP 101 状态码，响应头中包含 ，<code class="language-plaintext highlighter-rouge">Connection: Upgrade</code>和 <code class="language-plaintext highlighter-rouge">Sec-WebSocket-Accept: xxx</code> 等字段、表示成功升级到 WebSocket 协议。</li>
  <li>客户端和服务器之间建立了一个 WebSocket 连接，可以进行双向的数据传输。数据以帧（frames）的形式进行传送，而不是传统的 HTTP 请求和响应。WebSocket 的每条消息可能会被切分成多个数据帧（最小单位）。发送端会将消息切割成多个帧发送给接收端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。</li>
  <li>客户端或服务器可以主动发送一个关闭帧，表示要断开连接。另一方收到后，也会回复一个关闭帧，然后双方关闭 TCP 连接。</li>
</ol>

<p>另外，建立 WebSocket 连接之后，通过心跳机制来保持 WebSocket 连接的稳定性和活跃性。</p>

<p>SpringBoot 整合 WebSocket，先引入 WebSocket 相关的工具包，和 SSE 相比有额外的开发成本。</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- 引入websocket --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-websocket<span class="nt">&lt;/artifactId&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>

<p>服务端使用<code class="language-plaintext highlighter-rouge">@ServerEndpoint</code>注解标注当前类为一个 WebSocket 服务器，客户端可以通过<code class="language-plaintext highlighter-rouge">ws://localhost:7777/webSocket/10086</code>来连接到 WebSocket 服务器端。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="nd">@Slf4j</span>
<span class="nd">@ServerEndpoint</span><span class="o">(</span><span class="s">"/websocket/{userId}"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WebSocketServer</span> <span class="o">{</span>
    <span class="c1">//与某个客户端的连接会话，需要通过它来给客户端发送数据</span>
    <span class="kd">private</span> <span class="nc">Session</span> <span class="n">session</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">CopyOnWriteArraySet</span><span class="o">&lt;</span><span class="nc">WebSocketServer</span><span class="o">&gt;</span> <span class="n">webSockets</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CopyOnWriteArraySet</span><span class="o">&lt;&gt;();</span>
    <span class="c1">// 用来存在线连接数</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Session</span><span class="o">&gt;</span> <span class="n">sessionPool</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Session</span><span class="o">&gt;();</span>
    <span class="cm">/**
     * 链接成功调用的方法
     */</span>
    <span class="nd">@OnOpen</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onOpen</span><span class="o">(</span><span class="nc">Session</span> <span class="n">session</span><span class="o">,</span> <span class="nd">@PathParam</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"userId"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">session</span> <span class="o">=</span> <span class="n">session</span><span class="o">;</span>
            <span class="n">webSockets</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
            <span class="n">sessionPool</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">session</span><span class="o">);</span>
            <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"websocket消息: 有新的连接，总数为:"</span> <span class="o">+</span> <span class="n">webSockets</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="cm">/**
     * 收到客户端消息后调用的方法
     */</span>
    <span class="nd">@OnMessage</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onMessage</span><span class="o">(</span><span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"websocket消息: 收到客户端消息:"</span> <span class="o">+</span> <span class="n">message</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="cm">/**
     * 此为单点消息
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sendOneMessage</span><span class="o">(</span><span class="nc">String</span> <span class="n">userId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="n">sessionPool</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">userId</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">session</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">session</span><span class="o">.</span><span class="na">isOpen</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"websocket消: 单点消息:"</span> <span class="o">+</span> <span class="n">message</span><span class="o">);</span>
                <span class="n">session</span><span class="o">.</span><span class="na">getAsyncRemote</span><span class="o">().</span><span class="na">sendText</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>服务端还需要注入<code class="language-plaintext highlighter-rouge">ServerEndpointerExporter</code>，这个 Bean 就会自动注册使用了<code class="language-plaintext highlighter-rouge">@ServerEndpoint</code>注解的 WebSocket 服务器。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WebSocketConfiguration</span> <span class="o">{</span>

    <span class="cm">/**
     * 用于注册使用了 @ServerEndpoint 注解的 WebSocket 服务器
     */</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">ServerEndpointExporter</span> <span class="nf">serverEndpointExporter</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ServerEndpointExporter</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>前端初始化打开 WebSocket 连接，并监听连接状态，接收服务端数据或向服务端发送数据。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
    <span class="kd">var</span> <span class="nx">ws</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WebSocket</span><span class="p">(</span><span class="dl">'</span><span class="s1">ws://localhost:7777/webSocket/10086</span><span class="dl">'</span><span class="p">);</span>
    <span class="c1">// 获取连接状态</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">ws连接状态：</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">ws</span><span class="p">.</span><span class="nx">readyState</span><span class="p">);</span>
    <span class="c1">//监听是否连接成功</span>
    <span class="nx">ws</span><span class="p">.</span><span class="nx">onopen</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">ws连接状态：</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">ws</span><span class="p">.</span><span class="nx">readyState</span><span class="p">);</span>
        <span class="c1">//连接成功则发送一个数据</span>
        <span class="nx">ws</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="dl">'</span><span class="s1">test1</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 接听服务器发回的信息并处理展示</span>
    <span class="nx">ws</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">接收到来自服务器的消息：</span><span class="dl">'</span><span class="p">);</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
        <span class="c1">//完成通信后关闭WebSocket连接</span>
        <span class="nx">ws</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="c1">// 监听连接关闭事件</span>
    <span class="nx">ws</span><span class="p">.</span><span class="nx">onclose</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 监听整个过程中websocket的状态</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">ws连接状态：</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">ws</span><span class="p">.</span><span class="nx">readyState</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 监听并处理error事件</span>
    <span class="nx">ws</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="nf">sendMessage</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">content</span> <span class="o">=</span> <span class="nf">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">#message</span><span class="dl">"</span><span class="p">).</span><span class="nf">val</span><span class="p">();</span>
        <span class="nx">$</span><span class="p">.</span><span class="nf">ajax</span><span class="p">({</span>
            <span class="na">url</span><span class="p">:</span> <span class="dl">'</span><span class="s1">/socket/publish?userId=10086&amp;message=</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">content</span><span class="p">,</span>
            <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">GET</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">data</span><span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">id</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">7777</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">content</span><span class="dl">"</span><span class="p">:</span> <span class="nx">content</span> <span class="p">},</span>
            <span class="na">success</span><span class="p">:</span> <span class="nf">function </span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="o">&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span></code></pre></div></div>

<p>页面初始化建立 WebSocket 连接，之后就可以进行双向通信了，效果还不错。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192395.png" alt="" /></p>

<h3 id="mqtt">MQTT</h3>

<p><strong>什么是 MQTT 协议？</strong></p>

<p>MQTT (Message Queue Telemetry Transport)是一种基于发布/订阅（publish/subscribe）模式的轻量级通讯协议，通过订阅相应的主题来获取消息，是物联网（Internet of Thing）中的一个标准传输协议。</p>

<p>该协议将消息的发布者（publisher）与订阅者（subscriber）进行分离，因此可以在不可靠的网络环境中，为远程连接的设备提供可靠的消息服务，使用方式与传统的 MQ 有点类似。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000022986325.png" alt="MQTT 协议示例" /></p>

<p>TCP 协议位于传输层，MQTT 协议位于应用层，MQTT 协议构建于 TCP/IP 协议上，也就是说只要支持 TCP/IP 协议栈的地方，都可以使用 MQTT 协议。</p>

<p><strong>为什么要用 MQTT 协议？</strong></p>

<p>MQTT 协议为什么在物联网（IOT）中如此受偏爱？而不是其它协议，比如我们更为熟悉的 HTTP 协议呢？</p>

<ul>
  <li>首先 HTTP 协议它是一种同步协议，客户端请求后需要等待服务器的响应。而在物联网（IOT）环境中，设备会很受制于环境的影响，比如带宽低、网络延迟高、网络通信不稳定等，显然异步消息协议更为适合 IOT 应用程序。</li>
  <li>HTTP 是单向的，如果要获取消息客户端必须发起连接，而在物联网（IOT）应用程序中，设备或传感器往往都是客户端，这意味着它们无法被动地接收来自网络的命令。</li>
  <li>通常需要将一条命令或者消息，发送到网络上的所有设备上。HTTP 要实现这样的功能不但很困难，而且成本极高。</li>
</ul>

<p>具体的 MQTT 协议介绍和实践，这里我就不再赘述了，大家可以参考我之前的两篇文章，里边写的也都很详细了。</p>

<ul>
  <li>MQTT 协议的介绍：<a href="https://mp.weixin.qq.com/s/udFE6k9pPetIWsa6KeErrA">我也没想到 SpringBoot + RabbitMQ 做智能家居，会这么简单</a></li>
  <li>MQTT 实现消息推送：<a href="https://mp.weixin.qq.com/s/U-fUGr9i1MVa4PoVyiDFCg">未读消息（小红点），前端 与 RabbitMQ 实时消息推送实践，贼简单~</a></li>
</ul>

<h2 id="总结">总结</h2>

<blockquote>
  <p>以下内容为 JavaGuide 补充</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>介绍</th>
      <th>优点</th>
      <th>缺点</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>短轮询</td>
      <td>客户端定时向服务端发送请求，服务端直接返回响应数据（即使没有数据更新）</td>
      <td>简单、易理解、易实现</td>
      <td>实时性太差，无效请求太多，频繁建立连接太耗费资源</td>
    </tr>
    <tr>
      <td>长轮询</td>
      <td>与短轮询不同是，长轮询接收到客户端请求之后等到有数据更新才返回请求</td>
      <td>减少了无效请求</td>
      <td>挂起请求会导致资源浪费</td>
    </tr>
    <tr>
      <td>iframe 流</td>
      <td>服务端和客户端之间创建一条长连接，服务端持续向<code class="language-plaintext highlighter-rouge">iframe</code>传输数据。</td>
      <td>简单、易理解、易实现</td>
      <td>维护一个长连接会增加开销，效果太差（图标会不停旋转）</td>
    </tr>
    <tr>
      <td>SSE</td>
      <td>一种服务器端到客户端(浏览器)的单向消息推送。</td>
      <td>简单、易实现，功能丰富</td>
      <td>不支持双向通信</td>
    </tr>
    <tr>
      <td>WebSocket</td>
      <td>除了最初建立连接时用 HTTP 协议，其他时候都是直接基于 TCP 协议进行通信的，可以实现客户端和服务端的全双工通信。</td>
      <td>性能高、开销小</td>
      <td>对开发人员要求更高，实现相对复杂一些</td>
    </tr>
    <tr>
      <td>MQTT</td>
      <td>基于发布/订阅（publish/subscribe）模式的轻量级通讯协议，通过订阅相应的主题来获取消息。</td>
      <td>成熟稳定，轻量级</td>
      <td>对开发人员要求更高，实现相对复杂一些</td>
    </tr>
  </tbody>
</table>

<!-- @include: @article-footer.snippet.md -->
