<!-- markdownlint-disable MD024 -->

<h2 id="1-两数相加">1. 两数相加</h2>

<h3 id="题目描述">题目描述</h3>

<blockquote>
  <p>Leetcode:给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p>

  <p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
</blockquote>

<p>示例：</p>

<pre><code class="language-plain">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
输出：7 -&gt; 0 -&gt; 8
原因：342 + 465 = 807
</code></pre>

<h3 id="问题分析">问题分析</h3>

<p>Leetcode 官方详细解答地址：</p>

<p><a href="https://leetcode-cn.com/problems/add-two-numbers/solution/">https://leetcode-cn.com/problems/add-two-numbers/solution/</a></p>

<blockquote>
  <p>要对头结点进行操作时，考虑创建哑节点 dummy，使用 dummy-&gt;next 表示真正的头节点。这样可以避免处理头节点为空的边界问题。</p>
</blockquote>

<p>我们使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐
位相加的过程。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/algorithms/34910956.jpg" alt="图1，对两数相加方法的可视化: 342 + 465 = 807， 每个结点都包含一个数字，并且数字按位逆序存储。" /></p>

<h3 id="solution">Solution</h3>

<p><strong>我们首先从最低有效位也就是列表 l1 和 l2 的表头开始相加。注意需要考虑到进位的情况！</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */</span>
 <span class="c1">//https://leetcode-cn.com/problems/add-two-numbers/description/</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
<span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">addTwoNumbers</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">l1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">l2</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">dummyHead</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="nc">ListNode</span> <span class="n">p</span> <span class="o">=</span> <span class="n">l1</span><span class="o">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">l2</span><span class="o">,</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">dummyHead</span><span class="o">;</span>
    <span class="c1">//carry 表示进位数</span>
    <span class="kt">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">q</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="o">(</span><span class="n">q</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">q</span><span class="o">.</span><span class="na">val</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">carry</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;</span>
        <span class="c1">//进位数</span>
        <span class="n">carry</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">10</span><span class="o">;</span>
        <span class="c1">//新节点的数值为sum % 10</span>
        <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">sum</span> <span class="o">%</span> <span class="mi">10</span><span class="o">);</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">q</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">carry</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">carry</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">dummyHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="2-翻转链表">2. 翻转链表</h2>

<h3 id="题目描述-1">题目描述</h3>

<blockquote>
  <p>剑指 offer:输入一个链表，反转链表后，输出链表的所有元素。</p>
</blockquote>

<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/algorithms/81431871.jpg" alt="翻转链表" /></p>

<h3 id="问题分析-1">问题分析</h3>

<p>这道算法题，说直白点就是：如何让后一个节点指向前一个节点！在下面的代码中定义了一个 next 节点，该节点主要是保存要反转到头的那个节点，防止链表 “断裂”。</p>

<h3 id="solution-1">Solution</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ListNode</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
  <span class="nc">ListNode</span> <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

  <span class="nc">ListNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 *
 * @author Snailclimb
 * @date 2018年9月19日
 * @Description: TODO
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">ReverseList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>

    <span class="nc">ListNode</span> <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 保存要反转到头的那个节点</span>
      <span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
      <span class="c1">// 要反转的那个节点指向已经反转的上一个节点(备注:第一次反转的时候会指向null)</span>
      <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
      <span class="c1">// 上一个已经反转到头部的节点</span>
      <span class="n">pre</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
      <span class="c1">// 一直向链表尾走</span>
      <span class="n">head</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">pre</span><span class="o">;</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>测试方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

    <span class="nc">ListNode</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="nc">ListNode</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="nc">ListNode</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
    <span class="nc">ListNode</span> <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
    <span class="nc">ListNode</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
    <span class="n">a</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
    <span class="n">b</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
    <span class="n">c</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">d</span><span class="o">;</span>
    <span class="n">d</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
    <span class="k">new</span> <span class="nf">Solution</span><span class="o">().</span><span class="na">ReverseList</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
      <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>输出：</p>

<pre><code class="language-plain">5
4
3
2
1
</code></pre>

<h2 id="3-链表中倒数第-k-个节点">3. 链表中倒数第 k 个节点</h2>

<h3 id="题目描述-2">题目描述</h3>

<blockquote>
  <p>剑指 offer: 输入一个链表，输出该链表中倒数第 k 个结点。</p>
</blockquote>

<h3 id="问题分析-2">问题分析</h3>

<blockquote>
  <p><strong>链表中倒数第 k 个节点也就是正数第(L-K+1)个节点，知道了只一点，这一题基本就没问题！</strong></p>
</blockquote>

<p>首先两个节点/指针，一个节点 node1 先开始跑，指针 node1 跑到 k-1 个节点后，另一个节点 node2 开始跑，当 node1 跑到最后时，node2 所指的节点就是倒数第 k 个节点也就是正数第(L-K+1)个节点。</p>

<h3 id="solution-2">Solution</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/</span>

<span class="c1">// 时间复杂度O(n),一次遍历即可</span>
<span class="c1">// https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;tqId=11167&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">FindKthToTail</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 如果链表为空或者k小于等于0</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 声明两个指向头结点的节点</span>
    <span class="nc">ListNode</span> <span class="n">node1</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">node2</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="c1">// 记录节点的个数</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">// 记录k值，后面要使用</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
    <span class="c1">// p指针先跑，并且记录节点数，当node1节点跑了k-1个节点后，node2节点开始跑，</span>
    <span class="c1">// 当node1节点跑到最后时，node2节点所指的节点就是倒数第k个节点</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">node1</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">node1</span> <span class="o">=</span> <span class="n">node1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
      <span class="n">count</span><span class="o">++;</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">node2</span> <span class="o">=</span> <span class="n">node2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="n">k</span><span class="o">--;</span>
    <span class="o">}</span>
    <span class="c1">// 如果节点个数小于所求的倒数第k个节点，则返回空</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">index</span><span class="o">)</span>
      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">node2</span><span class="o">;</span>

  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="4-删除链表的倒数第-n-个节点">4. 删除链表的倒数第 N 个节点</h2>

<blockquote>
  <p>Leetcode:给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
</blockquote>

<p><strong>示例：</strong></p>

<pre><code class="language-plain">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.

</code></pre>

<p><strong>说明：</strong></p>

<p>给定的 n 保证是有效的。</p>

<p><strong>进阶：</strong></p>

<p>你能尝试使用一趟扫描实现吗？</p>

<p>该题在 leetcode 上有详细解答，具体可参考 Leetcode.</p>

<h3 id="问题分析-3">问题分析</h3>

<p>我们注意到这个问题可以容易地简化成另一个问题：删除从列表开头数起的第 (L - n + 1)个结点，其中 L 是列表的长度。只要我们找到列表的长度 L，这个问题就很容易解决。</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/algorithms/94354387.jpg" alt="图 1. 删除列表中的第 L - n + 1 个元素" /></p>

<h3 id="solution-3">Solution</h3>

<p><strong>两次遍历法</strong></p>

<p>首先我们将添加一个 <strong>哑结点</strong> 作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 L。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n) 个结点那里。<strong>我们把第 (L - n)个结点的 next 指针重新链接至第 (L - n + 2)个结点，完成这个算法。</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */</span>
<span class="c1">// https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">removeNthFromEnd</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 哑结点，哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部</span>
    <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="c1">// 哑结点指向头结点</span>
    <span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="c1">// 保存链表长度</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">len</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">len</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">length</span><span class="o">++;</span>
      <span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">n</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">target</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
    <span class="c1">// 找到 L-n 位置的节点</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
      <span class="n">length</span><span class="o">--;</span>
    <span class="o">}</span>
    <span class="c1">// 把第 (L - n)个结点的 next 指针重新链接至第 (L - n + 2)个结点</span>
    <span class="n">target</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>进阶——一次遍历法：</strong></p>

<blockquote>
  <p>链表中倒数第 N 个节点也就是正数第(L - n + 1)个节点。</p>
</blockquote>

<p>其实这种方法就和我们上面第四题找“链表中倒数第 k 个节点”所用的思想是一样的。<strong>基本思路就是：</strong> 定义两个节点 node1、node2;node1 节点先跑，node1 节点 跑到第 n+1 个节点的时候,node2 节点开始跑.当 node1 节点跑到最后一个节点时，node2 节点所在的位置就是第 （L - n ） 个节点（L 代表总链表长度，也就是倒数第 n + 1 个节点）</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">removeNthFromEnd</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>

    <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="c1">// 声明两个指向头结点的节点</span>
    <span class="nc">ListNode</span> <span class="n">node1</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">,</span> <span class="n">node2</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>

    <span class="c1">// node1 节点先跑，node1节点 跑到第 n 个节点的时候,node2 节点开始跑</span>
    <span class="c1">// 当node1 节点跑到最后一个节点时，node2 节点所在的位置就是第 （L-n ） 个节点，也就是倒数第 n+1（L代表总链表长度）</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">node1</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">node1</span> <span class="o">=</span> <span class="n">node1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">node1</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">node2</span> <span class="o">=</span> <span class="n">node2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="n">n</span><span class="o">--;</span>
    <span class="o">}</span>

    <span class="n">node2</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node2</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

    <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="5-合并两个排序的链表">5. 合并两个排序的链表</h2>

<h3 id="题目描述-3">题目描述</h3>

<blockquote>
  <p>剑指 offer:输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
</blockquote>

<h3 id="问题分析-4">问题分析</h3>

<p>我们可以这样分析:</p>

<ol>
  <li>假设我们有两个链表 A,B；</li>
  <li>A 的头节点 A1 的值与 B 的头结点 B1 的值比较，假设 A1 小，则 A1 为头节点；</li>
  <li>A2 再和 B1 比较，假设 B1 小,则，A1 指向 B1；</li>
  <li>A2 再和 B2 比较
就这样循环往复就行了，应该还算好理解。</li>
</ol>

<p>考虑通过递归的方式实现！</p>

<h3 id="solution-4">Solution</h3>

<p><strong>递归版本：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/</span>
<span class="c1">//https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;tqId=11169&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">Merge</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">list1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">list2</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">list1</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">list2</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">list2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">list1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">list1</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;=</span> <span class="n">list2</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">list1</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="nc">Merge</span><span class="o">(</span><span class="n">list1</span><span class="o">.</span><span class="na">next</span><span class="o">,</span> <span class="n">list2</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">list1</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">list2</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="nc">Merge</span><span class="o">(</span><span class="n">list1</span><span class="o">,</span> <span class="n">list2</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">list2</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<!-- @include: @article-footer.snippet.md -->
