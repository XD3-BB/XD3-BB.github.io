<h2 id="贪心算法">贪心算法</h2>

<h3 id="算法思想">算法思想</h3>

<p>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</p>

<h3 id="一般解题步骤">一般解题步骤</h3>

<ul>
  <li>将问题分解为若干个子问题</li>
  <li>找出适合的贪心策略</li>
  <li>求解每一个子问题的最优解</li>
  <li>将局部最优解堆叠成全局最优解</li>
</ul>

<h3 id="leetcode">LeetCode</h3>

<p>455.分发饼干：<a href="https://leetcode.cn/problems/assign-cookies/">https://leetcode.cn/problems/assign-cookies/</a></p>

<p>121.买卖股票的最佳时机：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></p>

<p>122.买卖股票的最佳时机 II：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</a></p>

<p>55.跳跃游戏：<a href="https://leetcode.cn/problems/jump-game/">https://leetcode.cn/problems/jump-game/</a></p>

<p>45.跳跃游戏 II：<a href="https://leetcode.cn/problems/jump-game-ii/">https://leetcode.cn/problems/jump-game-ii/</a></p>

<h2 id="动态规划">动态规划</h2>

<h3 id="算法思想-1">算法思想</h3>

<p>动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的。</p>

<p>经典题目：01 背包、完全背包</p>

<h3 id="一般解题步骤-1">一般解题步骤</h3>

<ul>
  <li>确定 dp 数组（dp table）以及下标的含义</li>
  <li>确定递推公式</li>
  <li>dp 数组如何初始化</li>
  <li>确定遍历顺序</li>
  <li>举例推导 dp 数组</li>
</ul>

<h3 id="leetcode-1">LeetCode</h3>

<p>509.斐波那契数：<a href="https://leetcode.cn/problems/fibonacci-number/">https://leetcode.cn/problems/fibonacci-number/</a></p>

<p>746.使用最小花费爬楼梯：<a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">https://leetcode.cn/problems/min-cost-climbing-stairs/</a></p>

<p>416.分割等和子集：<a href="https://leetcode.cn/problems/partition-equal-subset-sum/">https://leetcode.cn/problems/partition-equal-subset-sum/</a></p>

<p>518.零钱兑换：<a href="https://leetcode.cn/problems/coin-change-ii/">https://leetcode.cn/problems/coin-change-ii/</a></p>

<p>647.回文子串：<a href="https://leetcode.cn/problems/palindromic-substrings/">https://leetcode.cn/problems/palindromic-substrings/</a></p>

<p>516.最长回文子序列：<a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">https://leetcode.cn/problems/longest-palindromic-subsequence/</a></p>

<h2 id="回溯算法">回溯算法</h2>

<h3 id="算法思想-2">算法思想</h3>

<p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条</p>

<p>件时，就“回溯”返回，尝试别的路径。其本质就是穷举。</p>

<p>经典题目：8 皇后</p>

<h3 id="一般解题步骤-2">一般解题步骤</h3>

<ul>
  <li>针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。</li>
  <li>确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。</li>
  <li>以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。</li>
</ul>

<h3 id="leetcode-2">leetcode</h3>

<p>77.组合：<a href="https://leetcode.cn/problems/combinations/">https://leetcode.cn/problems/combinations/</a></p>

<p>39.组合总和：<a href="https://leetcode.cn/problems/combination-sum/">https://leetcode.cn/problems/combination-sum/</a></p>

<p>40.组合总和 II：<a href="https://leetcode.cn/problems/combination-sum-ii/">https://leetcode.cn/problems/combination-sum-ii/</a></p>

<p>78.子集：<a href="https://leetcode.cn/problems/subsets/">https://leetcode.cn/problems/subsets/</a></p>

<p>90.子集 II：<a href="https://leetcode.cn/problems/subsets-ii/">https://leetcode.cn/problems/subsets-ii/</a></p>

<p>51.N 皇后：<a href="https://leetcode.cn/problems/n-queens/">https://leetcode.cn/problems/n-queens/</a></p>

<h2 id="分治算法">分治算法</h2>

<h3 id="算法思想-3">算法思想</h3>

<p>将一个规模为 N 的问题分解为 K 个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。</p>

<p>经典题目：二分查找、汉诺塔问题</p>

<h3 id="一般解题步骤-3">一般解题步骤</h3>

<ul>
  <li>将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</li>
  <li>若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li>
  <li>将各个子问题的解合并为原问题的解。</li>
</ul>

<h3 id="leetcode-3">LeetCode</h3>

<p>108.将有序数组转换成二叉搜索数：<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/</a></p>

<p>148.排序列表：<a href="https://leetcode.cn/problems/sort-list/">https://leetcode.cn/problems/sort-list/</a></p>

<p>23.合并 k 个升序链表：<a href="https://leetcode.cn/problems/merge-k-sorted-lists/">https://leetcode.cn/problems/merge-k-sorted-lists/</a></p>
