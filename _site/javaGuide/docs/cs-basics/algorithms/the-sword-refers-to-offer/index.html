<h2 id="斐波那契数列">斐波那契数列</h2>

<p><strong>题目描述：</strong></p>

<p>大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。
n&lt;=39</p>

<p><strong>问题分析：</strong></p>

<p>可以肯定的是这一题通过递归的方式是肯定能做出来，但是这样会有一个很大的问题，那就是递归大量的重复计算会导致内存溢出。另外可以使用迭代法，用 fn1 和 fn2 保存计算过程中的结果，并复用起来。下面我会把两个方法示例代码都给出来并给出两个方法的运行时间对比。</p>

<p><strong>示例代码：</strong></p>

<p>采用迭代法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">Fibonacci</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">number</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">number</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">second</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">third</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">number</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">third</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="n">second</span><span class="o">;</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">second</span><span class="o">;</span>
        <span class="n">second</span> <span class="o">=</span> <span class="n">third</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">third</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>采用递归：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">Fibonacci</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">||</span><span class="n">n</span><span class="o">==</span><span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="nf">Fibonacci</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="nc">Fibonacci</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="跳台阶问题">跳台阶问题</h2>

<p><strong>题目描述：</strong></p>

<p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>

<p><strong>问题分析：</strong></p>

<p>正常分析法：</p>

<blockquote>
  <p>a.如果两种跳法，1 阶或者 2 阶，那么假定第一次跳的是一阶，那么剩下的是 n-1 个台阶，跳法是 f(n-1);
b.假定第一次跳的是 2 阶，那么剩下的是 n-2 个台阶，跳法是 f(n-2)
c.由 a，b 假设可以得出总跳法为: f(n) = f(n-1) + f(n-2)
d.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2</p>
</blockquote>

<p>找规律分析法：</p>

<blockquote>
  <p>f(1) = 1, f(2) = 2, f(3) = 3, f(4) = 5， 可以总结出 f(n) = f(n-1) + f(n-2)的规律。但是为什么会出现这样的规律呢？假设现在 6 个台阶，我们可以从第 5 跳一步到 6，这样的话有多少种方案跳到 5 就有多少种方案跳到 6，另外我们也可以从 4 跳两步跳到 6，跳到 4 有多少种方案的话，就有多少种方案跳到 6，其他的不能从 3 跳到 6 什么的啦，所以最后就是 f(6) = f(5) + f(4)；这样子也很好理解变态跳台阶的问题了。</p>
</blockquote>

<p><strong>所以这道题其实就是斐波那契数列的问题。</strong></p>

<p>代码只需要在上一题的代码稍做修改即可。和上一题唯一不同的就是这一题的初始元素变为 1 2 3 5 8……而上一题为 1 1 2 3 5 ……。另外这一题也可以用递归做，但是递归效率太低，所以我这里只给出了迭代方式的代码。</p>

<p><strong>示例代码：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">jumpFloor</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">number</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">number</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">second</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">third</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">number</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">third</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="n">second</span><span class="o">;</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">second</span><span class="o">;</span>
        <span class="n">second</span> <span class="o">=</span> <span class="n">third</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">third</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="变态跳台阶问题">变态跳台阶问题</h2>

<p><strong>题目描述：</strong></p>

<p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>

<p><strong>问题分析：</strong></p>

<p>假设 n&gt;=2，第一步有 n 种跳法：跳 1 级、跳 2 级、到跳 n 级
跳 1 级，剩下 n-1 级，则剩下跳法是 f(n-1)
跳 2 级，剩下 n-2 级，则剩下跳法是 f(n-2)
……
跳 n-1 级，剩下 1 级，则剩下跳法是 f(1)
跳 n 级，剩下 0 级，则剩下跳法是 f(0)
所以在 n&gt;=2 的情况下：
f(n)=f(n-1)+f(n-2)+…+f(1)
因为 f(n-1)=f(n-2)+f(n-3)+…+f(1)
所以 f(n)=2*f(n-1) 又 f(1)=1,所以可得<strong>f(n)=2^(number-1)</strong></p>

<p><strong>示例代码：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">JumpFloorII</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">--</span><span class="n">number</span><span class="o">;</span><span class="c1">//2^(number-1)用位移操作进行，更快</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>补充：</strong></p>

<p>java 中有三种移位运算符：</p>

<ol>
  <li>“«” : <strong>左移运算符</strong>，等同于乘 2 的 n 次方</li>
  <li>“»”: <strong>右移运算符</strong>，等同于除 2 的 n 次方</li>
  <li>“»&gt;” : <strong>无符号右移运算符</strong>，不管移动前最高位是 0 还是 1，右移后左侧产生的空位部分都以 0 来填充。与»类似。</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">16</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="o">;</span><span class="c1">//左移2，等同于16 * 2的2次方，也就是16 * 4</span>
<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="o">;</span><span class="c1">//右移2，等同于16 / 2的2次方，也就是16 / 4</span>
</code></pre></div></div>

<h2 id="二维数组查找">二维数组查找</h2>

<p><strong>题目描述：</strong></p>

<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>

<p><strong>问题解析：</strong></p>

<p>这一道题还是比较简单的，我们需要考虑的是如何做，效率最快。这里有一种很好理解的思路：</p>

<blockquote>
  <p>矩阵是有序的，从左下角来看，向上数字递减，向右数字递增，
因此从左下角开始查找，当要查找数字比左下角数字大时。右移
要查找数字比左下角数字小时，上移。这样找的速度最快。</p>
</blockquote>

<p><strong>示例代码：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">Find</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">,</span> <span class="kt">int</span> <span class="o">[][]</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//基本思路从左下角开始找，这样速度最快</span>
    <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="c1">//行</span>
    <span class="kt">int</span> <span class="n">column</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="c1">//列</span>
    <span class="c1">//当行数大于0，当前列数小于总列数时循环条件成立</span>
    <span class="k">while</span><span class="o">((</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)&amp;&amp;</span> <span class="o">(</span><span class="n">column</span><span class="o">&lt;</span> <span class="n">array</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">)){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">column</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">){</span>
            <span class="n">row</span><span class="o">--;</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">column</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">){</span>
            <span class="n">column</span><span class="o">++;</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="替换空格">替换空格</h2>

<p><strong>题目描述：</strong></p>

<p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20Are%20Happy。</p>

<p><strong>问题分析：</strong></p>

<p>这道题不难，我们可以通过循环判断字符串的字符是否为空格，是的话就利用 append()方法添加追加“%20”，否则还是追加原字符。</p>

<p>或者最简单的方法就是利用：replaceAll(String regex,String replacement)方法了，一行代码就可以解决。</p>

<p><strong>示例代码：</strong></p>

<p>常规做法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">String</span> <span class="nf">replaceSpace</span><span class="o">(</span><span class="nc">StringBuffer</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">StringBuffer</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">b</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">b</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="s">" "</span><span class="o">)){</span>
            <span class="n">out</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"%20"</span><span class="o">);</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="n">out</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>一行代码解决：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">String</span> <span class="nf">replaceSpace</span><span class="o">(</span><span class="nc">StringBuffer</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//return str.toString().replaceAll(" ", "%20");</span>
    <span class="c1">//public String replaceAll(String regex,String replacement)</span>
    <span class="c1">//用给定的替换替换与给定的regular expression匹配的此字符串的每个子字符串。</span>
    <span class="c1">//\ 转义字符. 如果你要使用 "\" 本身, 则应该使用 "\\". String类型中的空格用“\s”表示，所以我这里猜测"\\s"就是代表空格的意思</span>
    <span class="k">return</span> <span class="n">str</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"\\s"</span><span class="o">,</span> <span class="s">"%20"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="数值的整数次方">数值的整数次方</h2>

<p><strong>题目描述：</strong></p>

<p>给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。</p>

<p><strong>问题解析：</strong></p>

<p>这道题算是比较麻烦和难一点的一个了。我这里采用的是<strong>二分幂</strong>思想，当然也可以采用<strong>快速幂</strong>。
更具剑指 offer 书中细节，该题的解题思路如下：1.当底数为 0 且指数&lt;0 时，会出现对 0 求倒数的情况，需进行错误处理，设置一个全局变量； 2.判断底数是否等于 0，由于 base 为 double 型，所以不能直接用==判断 3.优化求幂函数（二分幂）。
当 n 为偶数，a^n =（a^n/2）<em>（a^n/2）；
当 n 为奇数，a^n = a^[(n-1)/2]</em> a^[(n-1)/2] * a。时间复杂度 O(logn)</p>

<p><strong>时间复杂度</strong>：O(logn)</p>

<p><strong>示例代码：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
      <span class="kt">boolean</span> <span class="n">invalidInput</span><span class="o">=</span><span class="kc">false</span><span class="o">;</span>
      <span class="kd">public</span> <span class="kt">double</span> <span class="nf">Power</span><span class="o">(</span><span class="kt">double</span> <span class="n">base</span><span class="o">,</span> <span class="kt">int</span> <span class="n">exponent</span><span class="o">)</span> <span class="o">{</span>
          <span class="c1">//如果底数等于0并且指数小于0</span>
          <span class="c1">//由于base为double型，不能直接用==判断</span>
        <span class="k">if</span><span class="o">(</span><span class="n">equal</span><span class="o">(</span><span class="n">base</span><span class="o">,</span><span class="mf">0.0</span><span class="o">)&amp;&amp;</span><span class="n">exponent</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">){</span>
            <span class="n">invalidInput</span><span class="o">=</span><span class="kc">true</span><span class="o">;</span>
            <span class="k">return</span> <span class="mf">0.0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">absexponent</span><span class="o">=</span><span class="n">exponent</span><span class="o">;</span>
         <span class="c1">//如果指数小于0，将指数转正</span>
        <span class="k">if</span><span class="o">(</span><span class="n">exponent</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">)</span>
            <span class="n">absexponent</span><span class="o">=-</span><span class="n">exponent</span><span class="o">;</span>
         <span class="c1">//getPower方法求出base的exponent次方。</span>
        <span class="kt">double</span> <span class="n">res</span><span class="o">=</span><span class="n">getPower</span><span class="o">(</span><span class="n">base</span><span class="o">,</span><span class="n">absexponent</span><span class="o">);</span>
         <span class="c1">//如果指数小于0，所得结果为上面求的结果的倒数</span>
        <span class="k">if</span><span class="o">(</span><span class="n">exponent</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">)</span>
            <span class="n">res</span><span class="o">=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">res</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
  <span class="o">}</span>
    <span class="c1">//比较两个double型变量是否相等的方法</span>
    <span class="kt">boolean</span> <span class="nf">equal</span><span class="o">(</span><span class="kt">double</span> <span class="n">num1</span><span class="o">,</span><span class="kt">double</span> <span class="n">num2</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">num1</span><span class="o">-</span><span class="n">num2</span><span class="o">&gt;-</span><span class="mf">0.000001</span><span class="o">&amp;&amp;</span><span class="n">num1</span><span class="o">-</span><span class="n">num2</span><span class="o">&lt;</span><span class="mf">0.000001</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//求出b的e次方的方法</span>
    <span class="kt">double</span> <span class="nf">getPower</span><span class="o">(</span><span class="kt">double</span> <span class="n">b</span><span class="o">,</span><span class="kt">int</span> <span class="n">e</span><span class="o">){</span>
        <span class="c1">//如果指数为0，返回1</span>
        <span class="k">if</span><span class="o">(</span><span class="n">e</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span>
            <span class="k">return</span> <span class="mf">1.0</span><span class="o">;</span>
        <span class="c1">//如果指数为1，返回b</span>
        <span class="k">if</span><span class="o">(</span><span class="n">e</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">b</span><span class="o">;</span>
        <span class="c1">//e&gt;&gt;1相等于e/2，这里就是求a^n =（a^n/2）*（a^n/2）</span>
        <span class="kt">double</span> <span class="n">result</span><span class="o">=</span><span class="n">getPower</span><span class="o">(</span><span class="n">b</span><span class="o">,</span><span class="n">e</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">result</span><span class="o">*=</span><span class="n">result</span><span class="o">;</span>
        <span class="c1">//如果指数n为奇数，则要再乘一次底数base</span>
        <span class="k">if</span><span class="o">((</span><span class="n">e</span><span class="o">&amp;</span><span class="mi">1</span><span class="o">)==</span><span class="mi">1</span><span class="o">)</span>
            <span class="n">result</span><span class="o">*=</span><span class="n">b</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>当然这一题也可以采用笨方法：累乘。不过这种方法的时间复杂度为 O（n），这样没有前一种方法效率高。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 使用累乘</span>
<span class="kd">public</span> <span class="kt">double</span> <span class="nf">powerAnother</span><span class="o">(</span><span class="kt">double</span> <span class="n">base</span><span class="o">,</span> <span class="kt">int</span> <span class="n">exponent</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">exponent</span><span class="o">);</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">result</span> <span class="o">*=</span> <span class="n">base</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">exponent</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="调整数组顺序使奇数位于偶数前面">调整数组顺序使奇数位于偶数前面</h2>

<p><strong>题目描述：</strong></p>

<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>

<p><strong>问题解析：</strong></p>

<p>这道题有挺多种解法的，给大家介绍一种我觉得挺好理解的方法：
我们首先统计奇数的个数假设为 n,然后新建一个等长数组，然后通过循环判断原数组中的元素为偶数还是奇数。如果是则从数组下标 0 的元素开始，把该奇数添加到新数组；如果是偶数则从数组下标为 n 的元素开始把该偶数添加到新数组中。</p>

<p><strong>示例代码：</strong></p>

<p>时间复杂度为 O（n），空间复杂度为 O（n）的算法</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reOrderArray</span><span class="o">(</span><span class="kt">int</span> <span class="o">[]</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//如果数组长度等于0或者等于1，什么都不做直接返回</span>
        <span class="k">if</span><span class="o">(</span><span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">0</span><span class="o">||</span><span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="c1">//oddCount：保存奇数个数</span>
        <span class="c1">//oddBegin：奇数从数组头部开始添加</span>
        <span class="kt">int</span> <span class="n">oddCount</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span><span class="n">oddBegin</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="c1">//新建一个数组</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">newArray</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="c1">//计算出（数组中的奇数个数）开始添加元素</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">((</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]&amp;</span><span class="mi">1</span><span class="o">)==</span><span class="mi">1</span><span class="o">)</span> <span class="n">oddCount</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="c1">//如果数为基数新数组从头开始添加元素</span>
            <span class="c1">//如果为偶数就从oddCount（数组中的奇数个数）开始添加元素</span>
            <span class="k">if</span><span class="o">((</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]&amp;</span><span class="mi">1</span><span class="o">)==</span><span class="mi">1</span><span class="o">)</span>
                <span class="n">newArray</span><span class="o">[</span><span class="n">oddBegin</span><span class="o">++]=</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">else</span> <span class="n">newArray</span><span class="o">[</span><span class="n">oddCount</span><span class="o">++]=</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">newArray</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="链表中倒数第-k-个节点">链表中倒数第 k 个节点</h2>

<p><strong>题目描述：</strong></p>

<p>输入一个链表，输出该链表中倒数第 k 个结点</p>

<p><strong>问题分析：</strong></p>

<p><strong>一句话概括：</strong>
两个指针一个指针 p1 先开始跑，指针 p1 跑到 k-1 个节点后，另一个节点 p2 开始跑，当 p1 跑到最后时，p2 所指的指针就是倒数第 k 个节点。</p>

<p><strong>思想的简单理解：</strong>
前提假设：链表的结点个数(长度)为 n。
规律一：要找到倒数第 k 个结点，需要向前走多少步呢？比如倒数第一个结点，需要走 n 步，那倒数第二个结点呢？很明显是向前走了 n-1 步，所以可以找到规律是找到倒数第 k 个结点，需要向前走 n-k+1 步。</p>

<p><strong>算法开始：</strong></p>

<ol>
  <li>设两个都指向 head 的指针 p1 和 p2，当 p1 走了 k-1 步的时候，停下来。p2 之前一直不动。</li>
  <li>p1 的下一步是走第 k 步，这个时候，p2 开始一起动了。至于为什么 p2 这个时候动呢？看下面的分析。</li>
  <li>当 p1 走到链表的尾部时，即 p1 走了 n 步。由于我们知道 p2 是在 p1 走了 k-1 步才开始动的，也就是说 p1 和 p2 永远差 k-1 步。所以当 p1 走了 n 步时，p2 走的应该是在 n-(k-1)步。即 p2 走了 n-k+1 步，此时巧妙的是 p2 正好指向的是规律一的倒数第 k 个结点处。
这样是不是很好理解了呢？</li>
</ol>

<p><strong>考察内容：</strong></p>

<p>链表+代码的鲁棒性</p>

<p><strong>示例代码：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
//链表类
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/</span>

<span class="c1">//时间复杂度O(n),一次遍历即可</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">FindKthToTail</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span><span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">pre</span><span class="o">=</span><span class="kc">null</span><span class="o">,</span><span class="n">p</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span>
        <span class="c1">//两个指针都指向头结点</span>
        <span class="n">p</span><span class="o">=</span><span class="n">head</span><span class="o">;</span>
        <span class="n">pre</span><span class="o">=</span><span class="n">head</span><span class="o">;</span>
        <span class="c1">//记录k值</span>
        <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="n">k</span><span class="o">;</span>
        <span class="c1">//记录节点的个数</span>
        <span class="kt">int</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="c1">//p指针先跑，并且记录节点数，当p指针跑了k-1个节点后，pre指针开始跑，</span>
        <span class="c1">//当p指针跑到最后时，pre所指指针就是倒数第k个节点</span>
        <span class="k">while</span><span class="o">(</span><span class="n">p</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">count</span><span class="o">++;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">k</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">){</span>
                <span class="n">pre</span><span class="o">=</span><span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">k</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="c1">//如果节点个数小于所求的倒数第k个节点，则返回空</span>
        <span class="k">if</span><span class="o">(</span><span class="n">count</span><span class="o">&lt;</span><span class="n">a</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">pre</span><span class="o">;</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="反转链表">反转链表</h2>

<p><strong>题目描述：</strong></p>

<p>输入一个链表，反转链表后，输出链表的所有元素。</p>

<p><strong>问题分析：</strong></p>

<p>链表的很常规的一道题，这一道题思路不算难，但自己实现起来真的可能会感觉无从下手，我是参考了别人的代码。
思路就是我们根据链表的特点，前一个节点指向下一个节点的特点，把后面的节点移到前面来。
就比如下图：我们把 1 节点和 2 节点互换位置，然后再将 3 节点指向 2 节点，4 节点指向 3 节点，这样以来下面的链表就被反转了。</p>

<p><img src="https://oss.javaguide.cn/p3-juejin/844773c7300e4373922bb1a6ae2a55a3~tplv-k3u1fbpfcp-zoom-1.png" alt="链表" /></p>

<p><strong>考察内容：</strong></p>

<p>链表+代码的鲁棒性</p>

<p><strong>示例代码：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">ReverseList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
       <span class="nc">ListNode</span> <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
       <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
              <span class="c1">//保存要反转到头来的那个节点</span>
               <span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
               <span class="c1">//要反转的那个节点指向已经反转的上一个节点</span>
               <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
               <span class="c1">//上一个已经反转到头部的节点</span>
               <span class="n">pre</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
               <span class="c1">//一直向链表尾走</span>
               <span class="n">head</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">pre</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="合并两个排序的链表">合并两个排序的链表</h2>

<p><strong>题目描述：</strong></p>

<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>

<p><strong>问题分析：</strong></p>

<p>我们可以这样分析:</p>

<ol>
  <li>假设我们有两个链表 A,B；</li>
  <li>A 的头节点 A1 的值与 B 的头结点 B1 的值比较，假设 A1 小，则 A1 为头节点；</li>
  <li>A2 再和 B1 比较，假设 B1 小,则，A1 指向 B1；</li>
  <li>A2 再和 B2 比较。。。。。。。
就这样循环往复就行了，应该还算好理解。</li>
</ol>

<p><strong>考察内容：</strong></p>

<p>链表+代码的鲁棒性</p>

<p><strong>示例代码：</strong></p>

<p>非递归版本：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">Merge</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">list1</span><span class="o">,</span><span class="nc">ListNode</span> <span class="n">list2</span><span class="o">)</span> <span class="o">{</span>
       <span class="c1">//list1为空，直接返回list2</span>
       <span class="k">if</span><span class="o">(</span><span class="n">list1</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">list2</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//list2为空，直接返回list1</span>
        <span class="k">if</span><span class="o">(</span><span class="n">list2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">list1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">ListNode</span> <span class="n">mergeHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">current</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="c1">//当list1和list2不为空时</span>
        <span class="k">while</span><span class="o">(</span><span class="n">list1</span><span class="o">!=</span><span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">list2</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="c1">//取较小值作头结点</span>
            <span class="k">if</span><span class="o">(</span><span class="n">list1</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;=</span> <span class="n">list2</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">mergeHead</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                   <span class="n">mergeHead</span> <span class="o">=</span> <span class="n">current</span> <span class="o">=</span> <span class="n">list1</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                   <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">list1</span><span class="o">;</span>
                    <span class="c1">//current节点保存list1节点的值因为下一次还要用</span>
                   <span class="n">current</span> <span class="o">=</span> <span class="n">list1</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">//list1指向下一个节点</span>
                <span class="n">list1</span> <span class="o">=</span> <span class="n">list1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">mergeHead</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                   <span class="n">mergeHead</span> <span class="o">=</span> <span class="n">current</span> <span class="o">=</span> <span class="n">list2</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                   <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">list2</span><span class="o">;</span>
                     <span class="c1">//current节点保存list2节点的值因为下一次还要用</span>
                   <span class="n">current</span> <span class="o">=</span> <span class="n">list2</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">//list2指向下一个节点</span>
                <span class="n">list2</span> <span class="o">=</span> <span class="n">list2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">list1</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">list2</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">list1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">mergeHead</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>递归版本：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">Merge</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">list1</span><span class="o">,</span><span class="nc">ListNode</span> <span class="n">list2</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">list1</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
        <span class="k">return</span> <span class="n">list2</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span><span class="o">(</span><span class="n">list2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
        <span class="k">return</span> <span class="n">list1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span><span class="o">(</span><span class="n">list1</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;=</span> <span class="n">list2</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
        <span class="n">list1</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="nc">Merge</span><span class="o">(</span><span class="n">list1</span><span class="o">.</span><span class="na">next</span><span class="o">,</span> <span class="n">list2</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">list1</span><span class="o">;</span>
    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
        <span class="n">list2</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="nc">Merge</span><span class="o">(</span><span class="n">list1</span><span class="o">,</span> <span class="n">list2</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">list2</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="用两个栈实现队列">用两个栈实现队列</h2>

<p><strong>题目描述：</strong></p>

<p>用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 队列中的元素为 int 类型。</p>

<p><strong>问题分析：</strong></p>

<p>先来回顾一下栈和队列的基本特点：
<strong>栈：</strong>后进先出（LIFO）
<strong>队列：</strong> 先进先出
很明显我们需要根据 JDK 给我们提供的栈的一些基本方法来实现。先来看一下 Stack 类的一些基本方法：</p>

<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/algorithms/5985000.jpg" alt="Stack类的一些常见方法" /></p>

<p>既然题目给了我们两个栈，我们可以这样考虑当 push 的时候将元素 push 进 stack1，pop 的时候我们先把 stack1 的元素 pop 到 stack2，然后再对 stack2 执行 pop 操作，这样就可以保证是先进先出的。（负[pop]负[pop]得正[先进先出]）</p>

<p><strong>考察内容：</strong></p>

<p>队列+栈</p>

<p>示例代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//左程云的《程序员代码面试指南》的答案</span>
<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
    <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>

    <span class="c1">//当执行push操作时，将元素添加到stack1</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">stack1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//如果两个队列都为空则抛出异常,说明用户没有push进任何元素</span>
        <span class="k">if</span><span class="o">(</span><span class="n">stack1</span><span class="o">.</span><span class="na">empty</span><span class="o">()&amp;&amp;</span><span class="n">stack2</span><span class="o">.</span><span class="na">empty</span><span class="o">()){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Queue is empty!"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//如果stack2不为空直接对stack2执行pop操作，</span>
        <span class="k">if</span><span class="o">(</span><span class="n">stack2</span><span class="o">.</span><span class="na">empty</span><span class="o">()){</span>
            <span class="k">while</span><span class="o">(!</span><span class="n">stack1</span><span class="o">.</span><span class="na">empty</span><span class="o">()){</span>
                <span class="c1">//将stack1的元素按后进先出push进stack2里面</span>
                <span class="n">stack2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">stack1</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
          <span class="k">return</span> <span class="n">stack2</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="栈的压入弹出序列">栈的压入,弹出序列</h2>

<p><strong>题目描述：</strong></p>

<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4，5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>

<p><strong>题目分析：</strong></p>

<p>这道题想了半天没有思路，参考了 <a href="https://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106">Alias 的答案</a>，他的思路写的也很详细应该很容易看懂。</p>

<p>【思路】借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是 1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是 4，很显然 1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。</p>

<p>举例：</p>

<p>入栈 1,2,3,4,5</p>

<p>出栈 4,5,3,2,1</p>

<p>首先 1 入辅助栈，此时栈顶 1≠4，继续入栈 2</p>

<p>此时栈顶 2≠4，继续入栈 3</p>

<p>此时栈顶 3≠4，继续入栈 4</p>

<p>此时栈顶 4 ＝ 4，出栈 4，弹出序列向后一位，此时为 5，,辅助栈里面是 1,2,3</p>

<p>此时栈顶 3≠5，继续入栈 5</p>

<p>此时栈顶 5=5，出栈 5,弹出序列向后一位，此时为 3，,辅助栈里面是 1,2,3</p>

<p>…….
依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。</p>

<p><strong>考察内容：</strong></p>

<p>栈</p>

<p><strong>示例代码：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>
<span class="c1">//这道题没想出来，参考了Alias同学的答案：https://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">IsPopOrder</span><span class="o">(</span><span class="kt">int</span> <span class="o">[]</span> <span class="n">pushA</span><span class="o">,</span><span class="kt">int</span> <span class="o">[]</span> <span class="n">popA</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">pushA</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">popA</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="c1">//用于标识弹出序列的位置</span>
        <span class="kt">int</span> <span class="n">popIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">pushA</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="n">s</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">pushA</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="c1">//如果栈不为空，且栈顶元素等于弹出序列</span>
            <span class="k">while</span><span class="o">(!</span><span class="n">s</span><span class="o">.</span><span class="na">empty</span><span class="o">()</span> <span class="o">&amp;&amp;</span><span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">==</span> <span class="n">popA</span><span class="o">[</span><span class="n">popIndex</span><span class="o">]){</span>
                <span class="c1">//出栈</span>
                <span class="n">s</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="c1">//弹出序列向后一位</span>
                <span class="n">popIndex</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<!-- @include: @article-footer.snippet.md -->
