<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-11-06T06:05:34+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">小_屮、的博客日记</title><subtitle>WordPress收费，Ghost又太大了，2核2G的服务器跑不起来。。还得是jekyll🥰</subtitle><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/jekyll/update/2024/09/24/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2024-09-24T11:23:41+08:00</published><updated>2024-09-24T11:23:41+08:00</updated><id>http://localhost:4000/jekyll/update/2024/09/24/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2024/09/24/welcome-to-jekyll.html"><![CDATA[<p>You’ll find this post in your <code class="language-plaintext highlighter-rouge">_posts</code> directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run <code class="language-plaintext highlighter-rouge">jekyll serve</code>, which launches a web server and auto-regenerates your site when a file is updated.</p>

<p>Jekyll requires blog post files to be named according to the following format:</p>

<p><code class="language-plaintext highlighter-rouge">YEAR-MONTH-DAY-title.MARKUP</code></p>

<p>Where <code class="language-plaintext highlighter-rouge">YEAR</code> is a four-digit number, <code class="language-plaintext highlighter-rouge">MONTH</code> and <code class="language-plaintext highlighter-rouge">DAY</code> are both two-digit numbers, and <code class="language-plaintext highlighter-rouge">MARKUP</code> is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.</p>

<p>Jekyll also offers powerful support for code snippets:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">'Tom'</span><span class="p">)</span>
<span class="c1">#=&gt; prints 'Hi, Tom' to STDOUT.</span></code></pre></figure>

<p>Check out the <a href="https://jekyllrb.com/docs/home">Jekyll docs</a> for more info on how to get the most out of Jekyll. File all bugs/feature requests at <a href="https://github.com/jekyll/jekyll">Jekyll’s GitHub repo</a>. If you have questions, you can ask them on <a href="https://talk.jekyllrb.com/">Jekyll Talk</a>.</p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.]]></summary></entry><entry><title type="html">虚拟机 Centos K8s二进制部署（未成功）</title><link href="http://localhost:4000/2024/09/13/%E8%99%9A%E6%8B%9F%E6%9C%BA-CentOS-k8s%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2-%E6%9C%AA%E6%88%90%E5%8A%9F.html" rel="alternate" type="text/html" title="虚拟机 Centos K8s二进制部署（未成功）" /><published>2024-09-13T00:00:00+08:00</published><updated>2024-09-13T00:00:00+08:00</updated><id>http://localhost:4000/2024/09/13/%E8%99%9A%E6%8B%9F%E6%9C%BA-CentOS-k8s%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2%EF%BC%88%E6%9C%AA%E6%88%90%E5%8A%9F%EF%BC%89</id><content type="html" xml:base="http://localhost:4000/2024/09/13/%E8%99%9A%E6%8B%9F%E6%9C%BA-CentOS-k8s%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2-%E6%9C%AA%E6%88%90%E5%8A%9F.html"><![CDATA[<p>服务器密码 mfhk12xx</p>

<p>服务启动失败，通过指令查看最近报错</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>journalctl -xe
</code></pre></div></div>

<p>也可通过指令查看最近服务的日志</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tail -f /var/log/messages
</code></pre></div></div>

<p>查看ETCD健康状态</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ETCD_PREFIX='ETCDCTL_API=3 etcdctl --cacert=/opt/etcd/ssl/ca.pem --cert=/opt/etcd/ssl/server.pem --key=/opt/etcd/ssl/server-key.pem --endpoints="https://192.168.100.100:2379,https://192.168.100.101:2379,https://192.168.100.102:2379" --write-out=table'
eval "${ETCD_PREFIX} endpoint health"
</code></pre></div></div>

<p>查看master组件健康状态</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl status kube-proxy
systemctl status kubelet
systemctl status kube-scheduler
systemctl status kube-controller-manager
systemctl status kube-apiserver
kubectl get cs
</code></pre></div></div>

<h1 id="前置操作">前置操作</h1>

<h2 id="搞奇数台linux服务器">搞奇数台linux服务器</h2>

<p>怎么搞的略，我搞了三个</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">host</th>
      <th style="text-align: center">ip</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">k8s-master</td>
      <td style="text-align: center">192.168.100.100</td>
    </tr>
    <tr>
      <td style="text-align: center">k8s-node1</td>
      <td style="text-align: center">192.168.100.101</td>
    </tr>
    <tr>
      <td style="text-align: center">k8s-node2</td>
      <td style="text-align: center">192.168.100.102</td>
    </tr>
  </tbody>
</table>

<h2 id="分配好主从节点">分配好主从节点</h2>

<p>每一台服务器都执行</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt;&gt; /etc/hosts &lt;&lt;EOF
192.168.100.100 k8s-master
192.168.100.101 k8s-node1
192.168.100.102 k8s-node2
EOF

</code></pre></div></div>

<h2 id="关闭防火墙">关闭防火墙</h2>

<p>这样的比较方便</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl stop firewalld
systemctl disable firewalld

</code></pre></div></div>

<h2 id="关闭swap">关闭swap</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sed -ri 's/.*swap.*/#&amp;/' /etc/fstab #永久
#swapoff -a   #临时

</code></pre></div></div>

<h2 id="关闭selinux">关闭selinux</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sed -i 's/enforcing/disabled/' /etc/selinux/config  #永久
#setenforce 0  # 临时 

</code></pre></div></div>

<h2 id="桥接流量转发">桥接流量转发</h2>

<p>每一台服务器都执行</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt;EOF
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.ipv6.conf.all.disable_ipv6=1
net.ipv4.ip_forward=1
EOF
sysctl --system

</code></pre></div></div>

<h2 id="时间同步">时间同步</h2>

<p>每一台服务器都执行</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum install ntpdate -y
ntpdate time.windows.com

</code></pre></div></div>

<h2 id="主机名规划">主机名规划</h2>

<p>按照规划在对应ip的服务器执行对应的set-hostname</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hostnamectl set-hostname k8s-master 
hostnamectl set-hostname k8s-node1
hostnamectl set-hostname k8s-node2

</code></pre></div></div>

<h2 id="服务部署">服务部署</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">ip</th>
      <th style="text-align: center">host</th>
      <th style="text-align: center">服务</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">192.168.100.100</td>
      <td style="text-align: center">k8s-master</td>
      <td style="text-align: center">kube-proxy<br />kubelet<br />kube-scheduler<br />kube-controller-manager<br />kube-apiserver</td>
    </tr>
    <tr>
      <td style="text-align: center">192.168.100.101</td>
      <td style="text-align: center">k8s-node1</td>
      <td style="text-align: center">kube-proxy<br />kubelet</td>
    </tr>
    <tr>
      <td style="text-align: center">192.168.100.102</td>
      <td style="text-align: center">k8s-node2</td>
      <td style="text-align: center">kube-proxy<br />kubelet</td>
    </tr>
  </tbody>
</table>

<h1 id="部署etcd">部署ETCD</h1>

<h2 id="下载cfssl">下载cfssl</h2>

<p>在某一台服务器上下载就行了</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://github.com/cloudflare/cfssl/releases/download/v1.6.3/cfssl_1.6.3_linux_amd64 -O /usr/local/bin/cfssl
wget https://github.com/cloudflare/cfssl/releases/download/v1.6.3/cfssljson_1.6.3_linux_amd64 -O /usr/local/bin/cfssljson
wget https://github.com/cloudflare/cfssl/releases/download/v1.6.3/cfssl-certinfo_1.6.3_linux_amd64 -O /usr/local/bin/cfssl-certinfo

chmod +x /usr/local/bin/cfssl /usr/local/bin/cfssljson /usr/local/bin/cfssl-certinfo 

cp cfssl_1.6.3_linux_amd64 cfssl
cp cfssl-certinfo_1.6.3_linux_amd64 cfssl-certinfo
cp cfssljson_1.6.3_linux_amd64 cfssljson
</code></pre></div></div>

<p>wget下载不下来可以手动下载</p>

<h2 id="etcd证书创建">ETCD证书创建</h2>

<p>在下载了cfssl的服务器上执行</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir /opt/etcd/{bin,cfg,ssl} -p
cd /opt/etcd/ssl/
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi ca-config.json
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "signing": {
        "default": {
            "expiry": "87600h"
        },
        "profiles": {
            "etcd": {
                "expiry": "87600h",
                "usages": [
                    "signing",
                    "key encipherment",
                    "server auth",
                    "client auth"
                ]
            }
        }
    }
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi ca-csr.json
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "CN": "etcd CA",
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "ST": "Beijing",
            "L": "Beijing"
        }
    ]
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi server-csr.json
</code></pre></div></div>

<p>下面的hosts需要改成自己的</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "CN": "etcd",
    "hosts": [
         "192.168.100.100",
         "192.168.100.101",
         "192.168.100.102"
        ],
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "ST": "Beijing",
            "L": "Beijing"
        }
    ]
}
</code></pre></div></div>

<p>生成</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cfssl gencert -initca ca-csr.json | cfssljson -bare ca
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=etcd server-csr.json | cfssljson -bare server
</code></pre></div></div>

<p>证书拷贝到所有节点的相同位置，主要是ca.pem、server.pem、server-key.pem三个文件，我放在/opt/etcd/ssl/内部</p>

<h2 id="etcd集群搭建">ETCD集群搭建</h2>

<p>在一台服务器下载etcd</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ETCD_VER=v3.4.24

//这两个都可以
GOOGLE_URL=https://storage.googleapis.com/etcd
GITHUB_URL=https://github.com/etcd-io/etcd/releases/download
DOWNLOAD_URL=${GOOGLE_URL}

rm -f /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz
rm -rf /tmp/etcd-download-test &amp;&amp; mkdir -p /tmp/etcd-download-test

curl -L ${DOWNLOAD_URL}/${ETCD_VER}/etcd-${ETCD_VER}-linux-amd64.tar.gz -o /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz
tar xzvf /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz -C /tmp/etcd-download-test --strip-components=1
rm -f /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /tmp/etcd-download-test/
cp etcd etcdctl /usr/local/bin/
</code></pre></div></div>

<p>这里的etcd、etcdctl两个文件拷贝到全部节点的/usr/local/bin/目录内</p>

<p>对所有节点进行下面的操作，配置文件注意改一部分</p>

<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi /opt/etcd/cfg/etcd.conf
</code></pre></div></div>

<p>配置文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ETCD_INITIAL_CLUSTER_STATEETCD_INITIAL_CLUSTER_STATE#[Member]
ETCD_DATA_DIR="/var/lib/etcd/default.etcd"
ETCD_NAME="etcd01"#修改为ETCD_INITIAL_CLUSTER中=右边为本机ip的左边的name
ETCD_LISTEN_PEER_URLS="https://192.168.100.100:2380" #修改为本机ip
ETCD_LISTEN_CLIENT_URLS="https://192.168.100.100:2379,http://127.0.0.1:2379"#修改为本机ip
#[Clustering]
ETCD_INITIAL_ADVERTISE_PEER_URLS="https://192.168.100.100:2380"#修改为本机ip
ETCD_ADVERTISE_CLIENT_URLS="https://192.168.100.100:2379"#修改为本机ip

#下面的名字跟ip需要事先规划下
ETCD_INITIAL_CLUSTER="etcd01=https://192.168.100.100:2380,etcd02=https://192.168.100.101:2380,etcd03=https://192.168.100.102:2380"
ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"
ETCD_INITIAL_CLUSTER_STATE="new"
#[Security]

#这里是前面cfssl创建的证书，用于开启TLS
ETCD_CERT_FILE="/opt/etcd/ssl/server.pem"
ETCD_KEY_FILE="/opt/etcd/ssl/server-key.pem"
ETCD_TRUSTED_CA_FILE="/opt/etcd/ssl/ca.pem"
ETCD_CLIENT_CERT_AUTH="true"
ETCD_PEER_CERT_FILE="/opt/etcd/ssl/server.pem"
ETCD_PEER_KEY_FILE="/opt/etcd/ssl/server-key.pem"
ETCD_PEER_TRUSTED_CA_FILE="/opt/etcd/ssl/ca.pem"
ETCD_PEER_CLIENT_CERT_AUTH="true"
</code></pre></div></div>

<p>字段介绍，下面的代码块是介绍，看看就行</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--initial-cluster：集群当中的其他节点
--cert-file：etcd证书路径
--key-file：etcd私钥路径
--peer-cert-file：对等证书(双向证书)路径
--peer-key-file：对等证书(双向证书)私钥路径
--trusted-ca-file：作为客户端时的CA证书路径
--peer-trusted-ca-file：对等证书的CA证书路径
--initial-advertise-peer-urls：列出集群成员通信的URL，用于通告集群其他成员
--listen-peer-urls：用于监听集群其他成员的URL列表
--listen-client-urls：用于监听客户端通讯的URL列表
--advertise-client-urls：通告客户端的URL，用于列出所有客户端
--initial-cluster-token：etcd集群的初始集群令牌，服务器必须通过令牌才能加入etcd集群
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi /usr/lib/systemd/system/etcd.service
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Unit]
Description=Etcd Server
After=network.target
After=network-online.target
Wants=network-online.target

[Service]
Type=notify
EnvironmentFile=-/opt/etcd/cfg/etcd.conf
ExecStart=/usr/local/bin/etcd
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
</code></pre></div></div>

<p>然后启动服务，组成集群的几个节点需要同时开启etcd服务，从上到下的指令分别是：</p>

<p>读取服务文件、开机启动etcd、开启etcd服务、查看etcd运行状态</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl daemon-reload
systemctl enable etcd
systemctl start etcd
systemctl status etcd

</code></pre></div></div>

<p>运行状态是running就行</p>

<p>这里的服务启动要同时，ETCD_INITIAL_CLUSTER配置有几台就要在几台启动。</p>

<p>服务启动要是报错了有提示、可以百度看看哪里有问题</p>

<hr />

<p>到这里就部署完毕了，后面是对部署结果的查看</p>

<p>使用脚手架的固定前缀，证书位置自己定，服务器ip自己改</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ETCD_PREFIX='ETCDCTL_API=3 etcdctl --cacert=/opt/etcd/ssl/ca.pem --cert=/opt/etcd/ssl/server.pem --key=/opt/etcd/ssl/server-key.pem --endpoints="https://192.168.100.100:2379,https://192.168.100.101:2379,https://192.168.100.102:2379" --write-out=table'
</code></pre></div></div>

<p>查看成员信息</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>eval "${ETCD_PREFIX} member list"
</code></pre></div></div>

<p>查看集群状态</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>eval "${ETCD_PREFIX} endpoint health"
</code></pre></div></div>

<p>全部的health列都是true表示部署完成，这个时候如果有某一个health是false，重启那一个etcd。</p>

<p>重启前修改配置的ETCD_INITIAL_CLUSTER_STATE为”existing”，然后执行下面的指令即可</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl restart etcd
</code></pre></div></div>

<h1 id="部署containerd">部署Containerd</h1>

<p>全部节点按照下面的步骤进行container部署</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir /opt/{containerd,cni/bin} -p
</code></pre></div></div>

<p>下container的载gz安装包跟cni的gz安装包还有runc的二进制包，这里container使用1.7.0版本，cni使用1.2.0，runc使用1.1.4</p>

<p>containerd下载</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://github.com/containerd/containerd/releases/download/v1.7.0/containerd-1.7.0-linux-amd64.tar.gz
</code></pre></div></div>

<p>cni插件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://github.com/containernetworking/plugins/releases/download/v1.2.0/cni-plugins-linux-amd64-v1.2.0.tgz
</code></pre></div></div>

<p>runc插件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://github.com/opencontainers/runc/releases/download/v1.1.4/runc.amd64
</code></pre></div></div>

<p>containerd文件放到/opt/containerd解压，ctr放到系统环境</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cp /opt/containerd/bin/ctr  /usr/local/bin
</code></pre></div></div>

<p>cni放到/opt/cni/bin解压</p>

<p>解压命令</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tar -zxf *gz
</code></pre></div></div>

<p>在放置runc.amd64的地方运行</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>install -m 755 runc.amd64 /usr/local/sbin/runc
</code></pre></div></div>

<p>先启动一次</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt; /etc/systemd/system/containerd.service &lt;&lt;EOF
[Unit]
Description=containerd container runtime
Documentation=https://containerd.io
After=network.target local-fs.target
 
[Service]
ExecStartPre=-/sbin/modprobe overlay
ExecStart=/opt/containerd/bin/containerd
Type=notify
Delegate=yes
KillMode=process
Restart=always
RestartSec=5
LimitNPROC=infinity
LimitCORE=infinity
LimitNOFILE=infinity
TasksMax=infinity
OOMScoreAdjust=-999
 
[Install]
WantedBy=multi-user.target
EOF
systemctl daemon-reload
systemctl enable containerd
systemctl start containerd
systemctl status containerd
</code></pre></div></div>

<p>配置Containerd所需的模块</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt; /etc/modules-load.d/containerd.conf &lt;&lt;EOF
overlay
br_netfilter
EOF
systemctl restart systemd-modules-load.service
</code></pre></div></div>

<p>配置Containerd所需的内核</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt;&gt; /etc/sysctl.d/99-kubernetes-cri.conf &lt;&lt; EOF
net.bridge.bridge-nf-call-iptables  = 1
net.ipv4.ip_forward                 = 1
net.bridge.bridge-nf-call-ip6tables = 1
EOF
sysctl --system
</code></pre></div></div>

<p>创建cni配置文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir /etc/cni/net.d/ -p
cat &gt; /etc/cni/net.d/10-mynet.conf &lt;&lt;EOF
{
    "cniVersion": "1.0.0",
    "name": "mynet",
    "type": "bridge",
    "bridge": "cni0",
    "isGateway": true,
    "ipMasq": true,
    "ipam": {
        "type": "host-local",
        "subnet": "10.88.0.0/16",
        "routes": [
            {
                "dst": "0.0.0.0/0"
            }
        ]
    }
}
EOF
cat &gt; /etc/cni/net.d/99-loopback.conf &lt;&lt;EOF
{
    "cniVerion": "1.0.0",
    "name": "lo",
    "type": "loopback"
}
EOF
</code></pre></div></div>

<p>创建Containerd的配置文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir /etc/containerd
/opt/containerd/bin/containerd config default | tee /etc/containerd/config.toml
</code></pre></div></div>

<p><strong>修改Containerd的配置文件/etc/containerd/config.toml，几个配置是分开的</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#这个配置里的[plugins."io.containerd.grpc.v1.cri"]
sandbox_image = "registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.6"
#这个配置里的[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc.options] SystemdCgroup注释掉
# SystemdCgroup = true
</code></pre></div></div>

<p>查看配置里的这一项config_path，没有自己加</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[plugins."io.containerd.grpc.v1.cri".registry]
  config_path = "/etc/containerd/certs.d"
</code></pre></div></div>

<p>查看命名空间</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ctr namespaces ls
</code></pre></div></div>

<p>创建命名空间的配置</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir /etc/containerd/certs.d/k8s.io -p
</code></pre></div></div>

<p>配置镜像加速host.后面的改成自己阿里云的免费镜像加速地址</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt;  /etc/containerd/certs.d/k8s.io/hosts.toml  &lt;&lt;EOF
server = "https://k8s.io"

[host."https://d68wvxw0.mirror.aliyuncs.com"]
  capabilities = ["pull", "resolve", "push"]
EOF
</code></pre></div></div>

<p>启动测试</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl restart containerd
ctr version

</code></pre></div></div>

<p>##</p>

<h1 id="主节点部署master组件">主节点部署Master组件</h1>

<h2 id="下载源码">下载源码</h2>

<p>这里有全部版本的日志，进去这个页面下滑有很多版本</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://github.com/kubernetes/kubernetes/tree/master/CHANGELOG
</code></pre></div></div>

<p>点击版本进去后就能看到版本的下载链接</p>

<p>点击Download for xxx，进去找到Server Binaries，是Server，下载第一个kubernetes-server-linux-amd64.tar.gz</p>

<p>我下载的1.26.3版本，之后到规划的Master服务器跑代码</p>

<p>规划一个放k8s的文件夹</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir -p /opt/kubernetes/{bin,cfg,ssl,logs} 
</code></pre></div></div>

<p>将下载的gz文件放在/opt/kubernetes/目录下</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /opt/kubernetes
tar zxvf kubernetes-server-linux-amd64.tar.gz
cd kubernetes/server/bin
cp kube-apiserver kube-scheduler kube-controller-manager kubelet kube-proxy kubectl kubeadm /opt/kubernetes/bin
cp kubectl kubeadm /usr/bin/
</code></pre></div></div>

<h2 id="部署kube-apiserver">部署kube-apiserver</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir /opt/kubernetes/ssl/kube-apiserver

cd /opt/kubernetes/ssl/kube-apiserver


cat &gt; ca-config.json &lt;&lt; EOF
{
  "signing": {
    "default": {
      "expiry": "87600h"
    },
    "profiles": {
      "kubernetes": {
         "expiry": "87600h",
         "usages": [
            "signing",
            "key encipherment",
            "server auth",
            "client auth"
        ]
      }
    }
  }
}
EOF
cat &gt; ca-csr.json &lt;&lt; EOF
{
    "CN": "kubernetes",
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "L": "Beijing",
            "ST": "Beijing",
            "O": "k8s",
            "OU": "System"
        }
    ]
}
EOF

cat &gt; server-csr.json &lt;&lt; EOF
{
    "CN": "kubernetes",
    "hosts": [
      "127.0.0.1",
      "192.168.100.100",
      "192.168.100.101",
      "192.168.100.102",
      "k8s-master",
      "k8s-node1",
      "k8s-node2"
    ],
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "L": "BeiJing",
            "ST": "BeiJing",
            "O": "k8s",
            "OU": "System"
        }
    ]
}
EOF

</code></pre></div></div>

<p>生成证书</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cfssl gencert -initca ca-csr.json | cfssljson -bare ca -
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes server-csr.json | cfssljson -bare server

</code></pre></div></div>

<p>创建配置</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt; /opt/kubernetes/cfg/kube-apiserver.conf &lt;&lt; EOF
KUBE_APISERVER_OPTS="--v=2 \\
--etcd-servers=https://192.168.100.100:2379,https://192.168.100.101:2379,https://192.168.100.102:2379 \\
--etcd-cafile=/opt/etcd/ssl/ca.pem \\
--etcd-certfile=/opt/etcd/ssl/server.pem \\
--etcd-keyfile=/opt/etcd/ssl/server-key.pem \\
--bind-address=192.168.100.100 \\
--secure-port=6443 \\
--advertise-address=192.168.100.100 \\
--allow-privileged=true \\
--authorization-mode=RBAC,Node \\
--token-auth-file=/opt/kubernetes/cfg/token.csv \\
--enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,ResourceQuota,NodeRestriction \\
--enable-bootstrap-token-auth=true \\
--service-cluster-ip-range=10.0.0.0/24 \\
--service-node-port-range=30000-32767 \\
--service-account-issuer=api \\
--service-account-key-file=/opt/kubernetes/ssl/kube-apiserver/ca-key.pem \\
--service-account-signing-key-file=/opt/kubernetes/ssl/kube-apiserver/server-key.pem \\
--proxy-client-cert-file=/opt/kubernetes/ssl/kube-apiserver/server.pem \\
--proxy-client-key-file=/opt/kubernetes/ssl/kube-apiserver/server-key.pem \\
--kubelet-client-certificate=/opt/kubernetes/ssl/kube-apiserver/server.pem \\
--kubelet-client-key=/opt/kubernetes/ssl/kube-apiserver/server-key.pem \\
--tls-cert-file=/opt/kubernetes/ssl/kube-apiserver/server.pem  \\
--tls-private-key-file=/opt/kubernetes/ssl/kube-apiserver/server-key.pem \\
--client-ca-file=/opt/kubernetes/ssl/kube-apiserver/ca.pem \\
--requestheader-client-ca-file=/opt/kubernetes/ssl/kube-apiserver/ca.pem \\
--requestheader-allowed-names=kubernetes \\
--requestheader-extra-headers-prefix=X-Remote-Extra- \\
--requestheader-group-headers=X-Remote-Group \\
--requestheader-username-headers=X-Remote-User \\
--enable-aggregator-routing=true \\
--audit-log-maxage=30 \\
--audit-log-maxbackup=3 \\
--audit-log-maxsize=100 \\
--audit-log-path=/opt/kubernetes/logs/k8s-audit.log"
EOF

</code></pre></div></div>

<p>生成一个token</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>head -c 16 /dev/urandom | od -An -t x | tr -d ' '

</code></pre></div></div>

<p>写入bootstraping验证token的文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt; /opt/kubernetes/cfg/token.csv &lt;&lt; EOF
dcbfd5e168fde8abda5ed8b0fda3291f,kubelet-bootstrap,10001,"system:node-bootstrapper"
EOF

</code></pre></div></div>

<p>创建apiserver服务</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt; /usr/lib/systemd/system/kube-apiserver.service &lt;&lt; EOF
[Unit]
Description=Kubernetes API Server
Documentation=https://github.com/kubernetes/kubernetes

[Service]
EnvironmentFile=/opt/kubernetes/cfg/kube-apiserver.conf
ExecStart=/opt/kubernetes/bin/kube-apiserver \$KUBE_APISERVER_OPTS
Restart=on-failure

[Install]
WantedBy=multi-user.target
EOF

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl daemon-reload
systemctl enable kube-apiserver
systemctl start kube-apiserver 
systemctl status kube-apiserver 

</code></pre></div></div>

<p>状态是running就ok</p>

<h2 id="部署kube-controller-manager">部署kube-controller-manager</h2>

<p>创建配置</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt; /opt/kubernetes/cfg/kube-controller-manager.conf &lt;&lt; EOF
KUBE_CONTROLLER_MANAGER_OPTS="--v=2 \\
--leader-elect=true \\
--kubeconfig=/opt/kubernetes/cfg/kube-controller-manager.kubeconfig \\
--bind-address=127.0.0.1 \\
--allocate-node-cidrs=true \\
--cluster-cidr=10.244.0.0/16 \\
--service-cluster-ip-range=10.0.0.0/24 \\
--cluster-signing-cert-file=/opt/kubernetes/ssl/kube-apiserver/ca.pem \\
--cluster-signing-key-file=/opt/kubernetes/ssl/kube-apiserver/ca-key.pem  \\
--root-ca-file=/opt/kubernetes/ssl/kube-apiserver/ca.pem \\
--service-account-private-key-file=/opt/kubernetes/ssl/kube-apiserver/ca-key.pem \\
--cluster-signing-duration=87600h0m0s"
EOF

</code></pre></div></div>

<p>生成证书</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir /opt/kubernetes/ssl/kube-controller-manager
cd /opt/kubernetes/ssl/kube-controller-manager
cp /opt/kubernetes/ssl/kube-apiserver/ca* /opt/kubernetes/ssl/kube-controller-manager
cat &gt; kube-controller-manager-csr.json &lt;&lt; EOF
{
  "CN": "system:kube-controller-manager",
  "hosts": [],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "L": "BeiJing", 
      "ST": "BeiJing",
      "O": "system:masters",
      "OU": "System"
    }
  ]
}
EOF
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-controller-manager-csr.json | cfssljson -bare kube-controller-manager

</code></pre></div></div>

<p>shell执行以下命令生成kubeconfig文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KUBE_CONFIG="/opt/kubernetes/cfg/kube-controller-manager.kubeconfig"
KUBE_APISERVER="https://192.168.100.100:6443"

kubectl config set-cluster kubernetes \
  --certificate-authority=/opt/kubernetes/ssl/kube-apiserver/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=${KUBE_CONFIG}
  
kubectl config set-credentials kube-controller-manager \
  --client-certificate=/opt/kubernetes/ssl/kube-controller-manager/kube-controller-manager.pem \
  --client-key=/opt/kubernetes/ssl/kube-controller-manager/kube-controller-manager-key.pem \
  --embed-certs=true \
  --kubeconfig=${KUBE_CONFIG}
  
kubectl config set-context default \
  --cluster=kubernetes \
  --user=kube-controller-manager \
  --kubeconfig=${KUBE_CONFIG}
  
kubectl config use-context default --kubeconfig=${KUBE_CONFIG}

</code></pre></div></div>

<p>创建服务</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt; /usr/lib/systemd/system/kube-controller-manager.service &lt;&lt; EOF
[Unit]
Description=Kubernetes Controller Manager
Documentation=https://github.com/kubernetes/kubernetes

[Service]
EnvironmentFile=/opt/kubernetes/cfg/kube-controller-manager.conf
ExecStart=/opt/kubernetes/bin/kube-controller-manager \$KUBE_CONTROLLER_MANAGER_OPTS
Restart=on-failure

[Install]
WantedBy=multi-user.target
EOF

</code></pre></div></div>

<p>启动</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl daemon-reload
systemctl enable kube-controller-manager
systemctl start kube-controller-manager
systemctl status kube-controller-manager

</code></pre></div></div>

<p>状态是running就ok</p>

<h2 id="部署-kube-scheduler">部署 kube-scheduler</h2>

<p>创建配置</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt; /opt/kubernetes/cfg/kube-scheduler.conf &lt;&lt; EOF
KUBE_SCHEDULER_OPTS="--v=2 \\
--leader-elect \\
--kubeconfig=/opt/kubernetes/cfg/kube-scheduler.kubeconfig \\
--bind-address=127.0.0.1"
EOF

</code></pre></div></div>

<p>生成证书</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir /opt/kubernetes/ssl/kube-scheduler
cd /opt/kubernetes/ssl/kube-scheduler
cp /opt/kubernetes/ssl/kube-apiserver/ca* /opt/kubernetes/ssl/kube-scheduler
# 创建证书请求文件
cat &gt; kube-scheduler-csr.json &lt;&lt; EOF
{
  "CN": "system:kube-scheduler",
  "hosts": [],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "L": "BeiJing",
      "ST": "BeiJing",
      "O": "system:masters",
      "OU": "System"
    }
  ]
}
EOF
# 生成证书
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-scheduler-csr.json | cfssljson -bare kube-scheduler

</code></pre></div></div>

<p>生成</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KUBE_CONFIG="/opt/kubernetes/cfg/kube-scheduler.kubeconfig"
KUBE_APISERVER="https://192.168.100.100:6443"

kubectl config set-cluster kubernetes \
  --certificate-authority=/opt/kubernetes/ssl/kube-apiserver/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=${KUBE_CONFIG}
  
kubectl config set-credentials kube-scheduler \
  --client-certificate=/opt/kubernetes/ssl/kube-scheduler/kube-scheduler.pem \
  --client-key=/opt/kubernetes/ssl/kube-scheduler/kube-scheduler-key.pem \
  --embed-certs=true \
  --kubeconfig=${KUBE_CONFIG}
  
kubectl config set-context default \
  --cluster=kubernetes \
  --user=kube-scheduler \
  --kubeconfig=${KUBE_CONFIG}
    
kubectl config use-context default --kubeconfig=${KUBE_CONFIG}

</code></pre></div></div>

<p>创建服务管理</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt; /usr/lib/systemd/system/kube-scheduler.service &lt;&lt; EOF
[Unit]
Description=Kubernetes Scheduler
Documentation=https://github.com/kubernetes/kubernetes

[Service]
EnvironmentFile=/opt/kubernetes/cfg/kube-scheduler.conf
ExecStart=/opt/kubernetes/bin/kube-scheduler \$KUBE_SCHEDULER_OPTS
Restart=on-failure

[Install]
WantedBy=multi-user.target
EOF

</code></pre></div></div>

<p>启动</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl daemon-reload
systemctl enable kube-scheduler
systemctl start kube-scheduler
systemctl status kube-scheduler

</code></pre></div></div>

<h2 id="集群管理前配置">集群管理前配置</h2>

<p>生成集群链接证书</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir /opt/kubernetes/ssl/kube-link
cd /opt/kubernetes/ssl/kube-link
cp /opt/kubernetes/ssl/kube-apiserver/ca* /opt/kubernetes/ssl/kube-link

cat &gt; admin-csr.json &lt;&lt;EOF
{
  "CN": "admin",
  "hosts": [],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "L": "BeiJing",
      "ST": "BeiJing",
      "O": "system:masters",
      "OU": "System"
    }
  ]
}
EOF

cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin

</code></pre></div></div>

<p>创建kubeconfig文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir /root/.kube

KUBE_CONFIG="/root/.kube/config"
KUBE_APISERVER="https://192.168.100.100:6443"

kubectl config set-cluster kubernetes \
  --certificate-authority=/opt/kubernetes/ssl/kube-link/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=${KUBE_CONFIG}
  
kubectl config set-credentials cluster-admin \
  --client-certificate=/opt/kubernetes/ssl/kube-link/admin.pem \
  --client-key=/opt/kubernetes/ssl/kube-link/admin-key.pem \
  --embed-certs=true \
  --kubeconfig=${KUBE_CONFIG}
  
kubectl config set-context default \
  --cluster=kubernetes \
  --user=cluster-admin \
  --kubeconfig=${KUBE_CONFIG}
  
kubectl config use-context default --kubeconfig=${KUBE_CONFIG}

</code></pre></div></div>

<p>查看节点组件状态</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl get cs
</code></pre></div></div>

<p>health全是true就是组件正常</p>

<p>创建用户</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create clusterrolebinding kubelet-bootstrap \
--clusterrole=system:node-bootstrapper \
--user=kubelet-bootstrap

</code></pre></div></div>

<h1 id="集群全部节点部署">集群全部节点部署</h1>

<h2 id="安装ctictl">安装ctictl</h2>

<p>下载</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://github.com/kubernetes-sigs/cri-tools/releases/download/v1.26.1/crictl-v1.26.1-linux-amd64.tar.gz
</code></pre></div></div>

<p>解压后移动到环境变量里</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tar -zxvf crictl-v1.26.1-linux-amd64.tar.gz
mv crictl /usr/local/bin/
</code></pre></div></div>

<p>添加crictl配置</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt; /etc/crictl.yaml &lt;&lt;EOF
runtime-endpoint: unix:///run/containerd/containerd.sock
image-endpoint: unix:///run/containerd/containerd.sock
timeout: 2
debug: false
pull-image-on-create: false
disable-pull-on-run: false
EOF

</code></pre></div></div>

<h2 id="master部署kubelet">（master）部署kubelet</h2>

<p>先在master节点按照下面的步骤kubelet部署</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt; /opt/kubernetes/cfg/kubelet-config.yml &lt;&lt; EOF
kind: KubeletConfiguration
apiVersion: kubelet.config.k8s.io/v1beta1
address: 0.0.0.0
port: 10250
readOnlyPort: 10255
cgroupDriver: cgroupfs
clusterDNS:
- 10.0.0.2
clusterDomain: k8s-master 
failSwapOn: false
authentication:
  anonymous:
    enabled: false
  webhook:
    cacheTTL: 2m0s
    enabled: true
  x509:
    clientCAFile: /opt/kubernetes/ssl/kube-apiserver/ca.pem 
authorization:
  mode: Webhook
  webhook:
    cacheAuthorizedTTL: 5m0s
    cacheUnauthorizedTTL: 30s
evictionHard:
  imagefs.available: 15%
  memory.available: 100Mi
  nodefs.available: 10%
  nodefs.inodesFree: 5%
maxOpenFiles: 1000000
maxPods: 110
EOF

</code></pre></div></div>

<p>创建bootstrap.kubeconfig</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KUBE_CONFIG="/opt/kubernetes/cfg/bootstrap.kubeconfig"
KUBE_APISERVER="https://192.168.100.100:6443" 
TOKEN="dcbfd5e168fde8abda5ed8b0fda3291f"

kubectl config set-cluster kubernetes \
  --certificate-authority=/opt/kubernetes/ssl/kube-apiserver/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=${KUBE_CONFIG}
  
kubectl config set-credentials "kubelet-bootstrap" \
  --token=${TOKEN} \
  --kubeconfig=${KUBE_CONFIG}
  
kubectl config set-context default \
  --cluster=kubernetes \
  --user="kubelet-bootstrap" \
  --kubeconfig=${KUBE_CONFIG}
  
kubectl config use-context default --kubeconfig=${KUBE_CONFIG}

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt; /opt/kubernetes/cfg/kubelet.conf &lt;&lt; EOF
KUBELET_OPTS="--hostname-override=k8s-master \\
--kubeconfig=/opt/kubernetes/cfg/kubelet.kubeconfig \\
--bootstrap-kubeconfig=/opt/kubernetes/cfg/bootstrap.kubeconfig \\
--config=/opt/kubernetes/cfg/kubelet-config.yml \\
--cert-dir=/opt/kubernetes/ssl/kube-link \\
--container-runtime-endpoint=unix:///run/containerd/containerd.sock"
EOF

</code></pre></div></div>

<p>创建服务</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt; /usr/lib/systemd/system/kubelet.service &lt;&lt; EOF
[Unit]
Description=Kubernetes Kubelet
After=docker.service

[Service]
EnvironmentFile=/opt/kubernetes/cfg/kubelet.conf
ExecStart=/opt/kubernetes/bin/kubelet \$KUBELET_OPTS
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
EOF

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl daemon-reload
systemctl enable kubelet
systemctl start kubelet
systemctl status kubelet

</code></pre></div></div>

<p>允许kubelet证书申请并加入集群</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get csr
#上面的命令执行后的表格，取name那一块作为下面命令的参数
kubectl certificate approve node-csr-t8Gq2LXx4SJ-WDa-HFeuc0ESNvEZ8oMTsZcaybs1NII
#执行下面的命令能看到k8s-master展示列表状态为ready
kubectl get nodes

</code></pre></div></div>

<h2 id="master部署kube-proxy">（master）部署kube-proxy</h2>

<p>创建配置</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt; /opt/kubernetes/cfg/kube-proxy.conf &lt;&lt; EOF
KUBE_PROXY_OPTS="--v=2 \\
--config=/opt/kubernetes/cfg/kube-proxy-config.yml"
EOF
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt; /opt/kubernetes/cfg/kube-proxy-config.yml &lt;&lt; EOF
kind: KubeProxyConfiguration
apiVersion: kubeproxy.config.k8s.io/v1alpha1
bindAddress: 0.0.0.0
metricsBindAddress: 0.0.0.0:10249
clientConnection:
  kubeconfig: /opt/kubernetes/cfg/kube-proxy.kubeconfig
hostnameOverride: k8s-master
clusterCIDR: 10.244.0.0/16
EOF
</code></pre></div></div>

<p>创建证书</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir /opt/kubernetes/ssl/kube-proxy
cd /opt/kubernetes/ssl/kube-proxy
cp /opt/kubernetes/ssl/kube-apiserver/ca* /opt/kubernetes/ssl/kube-proxy
cat &gt; kube-proxy-csr.json &lt;&lt; EOF
{
  "CN": "system:kube-proxy",
  "hosts": [],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "L": "BeiJing",
      "ST": "BeiJing",
      "O": "k8s",
      "OU": "System"
    }
  ]
}
EOF
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy

</code></pre></div></div>

<p>生成kube-proxy.kubeconfig文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KUBE_CONFIG="/opt/kubernetes/cfg/kube-proxy.kubeconfig"
KUBE_APISERVER="https://192.168.100.100:6443"
CERT_PATH="/opt/kubernetes/ssl/kube-proxy"

kubectl config set-cluster kubernetes \
  --certificate-authority=${CERT_PATH}/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=${KUBE_CONFIG}
  
kubectl config set-credentials kube-proxy \
  --client-certificate=${CERT_PATH}/kube-proxy.pem \
  --client-key=${CERT_PATH}/kube-proxy-key.pem \
  --embed-certs=true \
  --kubeconfig=${KUBE_CONFIG}
  
kubectl config set-context default \
  --cluster=kubernetes \
  --user=kube-proxy \
  --kubeconfig=${KUBE_CONFIG}
  
kubectl config use-context default --kubeconfig=${KUBE_CONFIG}

</code></pre></div></div>

<p>创建服务</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt; /usr/lib/systemd/system/kube-proxy.service &lt;&lt; EOF
[Unit]
Description=Kubernetes Proxy
After=network.target

[Service]
    EnvironmentFile=/opt/kubernetes/cfg/kube-proxy.conf
ExecStart=/opt/kubernetes/bin/kube-proxy \$KUBE_PROXY_OPTS
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
EOF

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl daemon-reload
systemctl enable kube-proxy
systemctl start kube-proxy
systemctl status kube-proxy

</code></pre></div></div>

<h2 id="master添加网络管理组件">（master）添加网络管理组件</h2>

<p>下载calicotl</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://github.com/projectcalico/calico/releases/download/v3.25.0/calicoctl-linux-amd64
</code></pre></div></div>

<p>放到/usr/local/bin/中</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mv /usr/local/bin/calicoctl-linux-amd64 /usr/local/bin/calicoctl
chmod +x /usr/local/bin/calicoctl
</code></pre></div></div>

<p>下载配置</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://raw.githubusercontent.com/projectcalico/calico/v3.25.0/manifests/calico.yaml
</code></pre></div></div>

<p>放到/opt/kubernetes/cfg/中</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply -f /opt/kubernetes/cfg/calico.yaml
kubectl get pods -n kube-system
</code></pre></div></div>

<h2 id="node复制节点">（node）复制节点</h2>

<p>master节点</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /opt/kubernetes
tar zvcf kube.gz bin/ cfg/ ssl/

</code></pre></div></div>

<p>将/opt/kubernetes/下的kube.gz文件下载下来</p>

<p>子节点</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir /opt/kubernetes

</code></pre></div></div>

<p>将刚刚下载的kube.gz文件上传到/opt/kubernetes/</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> tar -zxvf kube.gz
 
</code></pre></div></div>

<p>删除部分配置，每个节点不同</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rm -f /opt/kubernetes/cfg/kubelet.kubeconfig 
rm -f /opt/kubernetes/ssl/kube-link/kubelet*

</code></pre></div></div>

<p>修改主机名称</p>

<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi /opt/kubernetes/cfg/kubelet.conf

</code></pre></div></div>

<p>修改：–hostname-override=k8s-node1</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi /opt/kubernetes/cfg/kube-proxy-config.yml

</code></pre></div></div>

<p>修改：hostnameOverride: k8s-node1</p>

<hr />

<p>创建软连接（创建服务）kubelet与kube-proxy</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt; /usr/lib/systemd/system/kubelet.service &lt;&lt; EOF
[Unit]
Description=Kubernetes Kubelet
After=docker.service

[Service]
EnvironmentFile=/opt/kubernetes/cfg/kubelet.conf
ExecStart=/opt/kubernetes/bin/kubelet \$KUBELET_OPTS
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
EOF
cat &gt; /usr/lib/systemd/system/kube-proxy.service &lt;&lt; EOF
[Unit]
Description=Kubernetes Proxy
After=network.target

[Service]
    EnvironmentFile=/opt/kubernetes/cfg/kube-proxy.conf
ExecStart=/opt/kubernetes/bin/kube-proxy \$KUBE_PROXY_OPTS
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
EOF

</code></pre></div></div>

<p>这里可以开一个新的ssh专门打日志</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> tail -f /var/log/messages
</code></pre></div></div>

<p>开启kubelet</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl daemon-reload
systemctl enable kubelet
systemctl start kubelet
systemctl status kubelet

</code></pre></div></div>

<p>开启kube-proxy</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl daemon-reload
systemctl enable kube-proxy
systemctl start kube-proxy
systemctl status kube-proxy

</code></pre></div></div>

<p>在Master上同意新的Node kubelet证书申请</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get csr
kubectl certificate approve #后面是上面语句获取的NAME列的一行
</code></pre></div></div>

<p>查看节点</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get nodes
</code></pre></div></div>

<p>有三个Ready的</p>]]></content><author><name></name></author><category term="运维" /><category term="linux" /><category term="CentOS" /><category term="虚拟机" /><category term="k8s" /><category term="kubernetes" /><category term="containerd" /><summary type="html"><![CDATA[服务器密码 mfhk12xx]]></summary></entry><entry><title type="html">Linux Centos 如何注册自己的服务</title><link href="http://localhost:4000/2023/09/06/Linux-CentOS-%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1.html" rel="alternate" type="text/html" title="Linux Centos 如何注册自己的服务" /><published>2023-09-06T00:00:00+08:00</published><updated>2023-09-06T00:00:00+08:00</updated><id>http://localhost:4000/2023/09/06/Linux-CentOS-%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1</id><content type="html" xml:base="http://localhost:4000/2023/09/06/Linux-CentOS-%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1.html"><![CDATA[<p>脚本内的地址需要写全路径，且需以</p>

<p><strong>#! /bin/bash</strong></p>

<p>开头</p>

<p>创建 你的服务.service 文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Unit]
Description=test
After=network.target

[Service]
Type=forking
ExecStart=启动操作时执行的脚本
ExecReload=重新启动操作时执行的脚本
ExecStop=关闭操作时执行的脚本
PrivateTmp=true

 [Install]
WantedBy=multi-user.target
</code></pre></div></div>

<p>复制脚本到系统服务中 /usr/lib/systemd/system/</p>

<p>systemctl daemon-reload</p>

<p>systemctl start 你的服务</p>

<p>设置开机自启</p>

<p>systemctl enable 你的服务</p>]]></content><author><name></name></author><category term="运维" /><category term="linux" /><category term="CentOS" /><category term="服务" /><summary type="html"><![CDATA[脚本内的地址需要写全路径，且需以]]></summary></entry><entry><title type="html">Linux Centos Git服务器搭建</title><link href="http://localhost:4000/2022/10/14/Linux-CentOS-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA.html" rel="alternate" type="text/html" title="Linux Centos Git服务器搭建" /><published>2022-10-14T00:00:00+08:00</published><updated>2022-10-14T00:00:00+08:00</updated><id>http://localhost:4000/2022/10/14/Linux-CentOS-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA</id><content type="html" xml:base="http://localhost:4000/2022/10/14/Linux-CentOS-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA.html"><![CDATA[<p>文章来源： https://www.runoob.com/git/git-server.html</p>

<h2 id="1安装gitroot用户">1、安装Git[root用户]</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel
yum install git
</code></pre></div></div>

<p>创建一个git用户组和用户，用来运行git服务：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>groupadd git
useradd git -g git
passwd git
//设置密码
</code></pre></div></div>

<h2 id="2创建证书登录root用户">2、创建证书登录[root用户]</h2>

<p>将我们的公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。</p>

<p>公钥位于本地的C:\Users\用户名\ .ssh\id_rsa.pub文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /home/git/
mkdir .ssh
chmod 755 .ssh
touch .ssh/authorized_keys
chmod 644 .ssh/authorized_keys
chown git:git .ssh/
</code></pre></div></div>

<h2 id="3初始化git仓库root用户">3、初始化Git仓库[root用户]</h2>

<p>首先我们选定一个目录作为Git仓库，假定是/usr/local/gitRepo/demo.git，在/usr/local/gitRepo目录下输入命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /usr/local
mkdir gitRepo
chown git:git gitRepo/
cd gitRepo

git init --bare demo.git

//Initialized empty Git repository in /usr/local/gitRepo/demo.git/
</code></pre></div></div>

<p>以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chown -R git:git demo.git
</code></pre></div></div>

<h2 id="4克隆仓库git用户">4、克隆仓库[Git用户]</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone git@127.0.0.1:/usr/local/gitRepo/demo.git

Cloning into 'runoob'...
warning: You appear to have cloned an empty repository.
Checking connectivity... done.
</code></pre></div></div>

<p>192.168.45.4 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip。</p>

<p>这样我们的 Git 服务器安装就完成。</p>

<h2 id="5整点好玩的--git仓库触发提交git用户">5、整点好玩的  git仓库触发提交[Git用户]</h2>

<p>修改云端仓库hooks中的post-receive函数</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /usr/local/gitRepo/demo.git/hooks
vim post-receive
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/sh
read local_ref local_sha remote_ref remote_sha
DIR=`pwd`
DIR=${DIR%.*}
branch=${remote_ref##*/}
cd ${DIR}
unset GIT_DIR
echo "${branch}开始拉取，项目文件夹`pwd`"
chmod 755 restart-demo.sh
./restart-demo.sh ${branch}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chmod 755 post-receive
</code></pre></div></div>

<p>服务器拉取项目</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir /usr/local/gitRepo/demo
cd /usr/local/gitRepo/
git init demo
cd demo
git config --local user.name "xc"
git config --local user.email '1960481101@qq.com'
ssh-keygen -t rsa
</code></pre></div></div>

<p>找到生成的文件的公钥/home/git/.ssh/id_rsa.pub，添加到 /home/git/.ssh/authorized_keys,然后克隆项目</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /usr/local/gitRepo/demo
git remote add origin git@127.0.0.1:/usr/local/gitRepo/demo.git
git pull
</code></pre></div></div>

<p>项目中创建脚本  restart-demo.sh</p>

<p>脚本在项目最外侧，方便,mvn位置自己改</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#! /bin/bash
date

updateBranch=master

branch=$1
if [ "$branch" ! = "$updateBranch" ]; then
  echo "分支为${updateBranch}才进行更新"
  exit 1
fi

repoPath=$(pwd)
profile=$branch
cd $repoPath
git reset --hard origin/$branch
git checkout -f -b cache origin/$branch
git branch -D $branch
git checkout -f -b $branch origin/$branch
git branch -D cache
git pull --no-edit

/usr/local/custom/maven/bin/mvn clean package -P$profile

cd target
file=$(ls *.jar | awk '{print $1}')
sp_pid=$(ps -ef | grep $file | grep -v grep | awk '{print $2}')
if [ -z "$sp_pid" ]; then
  echo "[ not find sp-tomcat pid ]"
else
  echo "find result: $sp_pid "
  kill -9 $sp_pid
fi
logPath=$repoPath/${file%.*}.out
nohup java -jar $file &gt;$logPath 2&gt;&amp;1 &amp;
echo "--启动ok,日志见$logPath--"

</code></pre></div></div>

<p>将项目代码文件夹其拥有者设置为git</p>

<p>注意，项目中所有输出路径都需要用户git有操作权限</p>]]></content><author><name></name></author><category term="运维" /><category term="linux" /><category term="CentOS" /><category term="git" /><category term="git服务器" /><category term="自动部署" /><summary type="html"><![CDATA[文章来源： https://www.runoob.com/git/git-server.html]]></summary></entry><entry><title type="html">Linux Centos Redis安装</title><link href="http://localhost:4000/2022/10/12/Linux-CentOS-redis%E5%AE%89%E8%A3%85.html" rel="alternate" type="text/html" title="Linux Centos Redis安装" /><published>2022-10-12T00:00:00+08:00</published><updated>2022-10-12T00:00:00+08:00</updated><id>http://localhost:4000/2022/10/12/Linux-CentOS-redis%E5%AE%89%E8%A3%85</id><content type="html" xml:base="http://localhost:4000/2022/10/12/Linux-CentOS-redis%E5%AE%89%E8%A3%85.html"><![CDATA[<p>redis是个好东西啊，编译安装需要gcc</p>

<p><strong>yum -y install gcc</strong></p>

<h2 id="一单机redis安装">一、单机redis安装</h2>

<h3 id="1下载">1、下载</h3>

<p>wget https://download.redis.io/releases/redis-6.2.7.tar.gz</p>

<h3 id="2解压">2、解压</h3>

<p>tar xzf redis-6.2.7.tar.gz</p>

<h3 id="3改名">3、改名</h3>

<p>mv redis-6.2.7 redis</p>

<h3 id="4编译安装">4、编译安装</h3>

<p>cd redis</p>

<p>make &amp;&amp; make install</p>

<h3 id="5修改配置">5、修改配置</h3>

<p>vi redis.conf</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#注释掉绑定用于远程登陆
#bind 127.0.0.1 -::1
#这里讲原来的no改为yes,目的是为了设置后台运行
daemonize yes
#这里讲原来的yes改为no,目的是为了解决安全模式引起的报错
protected-mode no
#此处本来是注释状态，取消注释后，设置redis永远的登陆密码
requirepass redis连接密码
</code></pre></div></div>

<h2 id="二redis集群配置">二、redis集群配置</h2>

<p>redis集群最少要6个redis，资源有限，可以一台机器配置6个redis</p>

<h3 id="1创建配置路径">1、创建配置路径</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#配置存放路径
mkdir -p /usr/local/redis/6380
mkdir -p /usr/local/redis/6381
mkdir -p /usr/local/redis/6382
mkdir -p /usr/local/redis/6383
mkdir -p /usr/local/redis/6384
mkdir -p /usr/local/redis/6385
#日志存放路径
mkdir -p /usr/local/redis/logs
#redis数据库存放路径
mkdir -p /usr/local/redis/redisdata6380
mkdir -p /usr/local/redis/redisdata6381
mkdir -p /usr/local/redis/redisdata6382
mkdir -p /usr/local/redis/redisdata6383
mkdir -p /usr/local/redis/redisdata6384
mkdir -p /usr/local/redis/redisdata6385
</code></pre></div></div>

<h3 id="2拷贝修改配置">2、拷贝修改配置</h3>

<p>拷贝首份配置</p>

<p>cp /usr/local/redis/redis.conf /usr/local/redis/6380/</p>

<p>修改几个配置</p>

<p>vim /usr/local/redis/6380/redis.conf</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#端口
port 6380
#取消绑定
#bind 127.0.0.1  -::1
#开启集群
cluster-enabled yes
cluster-node-timeout 15000
#可后台运行
daemonize yes
#可远程连接
protected-mode no
#文件输出路径改下
cluster-config-file nodes-6380.conf
pidfile /var/run/redis_6380.pid
logfile "/usr/local/redis/logs/redis-6380.log"
dir /usr/local/redis/redisdata6380
#密码及master密码
requirepass redis连接密码
masterauth redis连接密码
</code></pre></div></div>

<p>其他库配置只需将首份配置拷贝，然后全局替换端口</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cp /usr/local/redis/6380/redis.conf /usr/local/redis/6381/
cp /usr/local/redis/6380/redis.conf /usr/local/redis/6382/
cp /usr/local/redis/6380/redis.conf /usr/local/redis/6383/
cp /usr/local/redis/6380/redis.conf /usr/local/redis/6384/
cp /usr/local/redis/6380/redis.conf /usr/local/redis/6385/
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /usr/local/redis/6381/redis.conf   
:%s/6380/6381/g
:wq
vim /usr/local/redis/6382/redis.conf   
:%s/6380/6382/g
:wq
vim /usr/local/redis/6383/redis.conf   
:%s/6380/6383/g
:wq
vim /usr/local/redis/6384/redis.conf   
:%s/6380/6384/g
:wq
vim /usr/local/redis/6385/redis.conf   
:%s/6380/6385/g
:wq
</code></pre></div></div>

<h3 id="3启动服务">3、启动服务</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/usr/local/redis/src/redis-server /usr/local/redis/6380/redis.conf
/usr/local/redis/src/redis-server /usr/local/redis/6381/redis.conf
/usr/local/redis/src/redis-server /usr/local/redis/6382/redis.conf
/usr/local/redis/src/redis-server /usr/local/redis/6383/redis.conf
/usr/local/redis/src/redis-server /usr/local/redis/6384/redis.conf
/usr/local/redis/src/redis-server /usr/local/redis/6385/redis.conf
</code></pre></div></div>

<p>以上设置，可以将他们放在不同服务器中，比如6380与6381在一台服务器，6382与6383在一台服务器，6384与6385在一台服务器</p>

<p>在其中一台服务器执行以下命令</p>

<p>src/redis-cli –cluster create   <strong>6380redis所在ip:6380</strong>    <strong>6381redis所在ip:6381</strong>      <strong>6382redis所在ip:6382</strong>      <strong>6383redis所在ip:6383 **     **6384redis所在ip:6384</strong>      <strong>6385redis所在ip:6385</strong>  –cluster-replicas 1 -a <strong>redis连接密码</strong></p>

<p>都在一起可以使用127.0.0.1代替ip</p>

<p>src/redis-cli –cluster create 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 127.0.0.1:6385  –cluster-replicas 1 -a redisPass</p>

<p>中间会询问几次，直接输入yes后回车,最后展示如下即表示成功</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
[OK] All 16384 slots covered.
</code></pre></div></div>

<p>集群登录，挑一个节点登录即可</p>

<p>src/redis-cli -h 127.0.0.1 -p 6380 -c -a 设置的密码</p>

<h3 id="4查看集群状态">4、查看集群状态</h3>

<p>cluster nodes</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5e3d9195c01ce5ab069b3042e2e27171241814dc 127.0.0.1:6381@16381 master - 0 1661353971336 2 connected 5461-10922
601e269d458e6f2a6af9b183316e9cd3fc3bbeb1 127.0.0.1:6383@16383 slave 5e3d9195c01ce5ab069b3042e2e27171241814dc 0 1661353968324 2 connected
afb32dc53068eb5bfe3b544fd3ae5adfad29ea7f 127.0.0.1:6385@16385 slave 9a6b56517eceab367aebc0105238c010792aa36c 0 1661353970333 1 connected
f6b538e2df80fea1e948fda3024647bdccae3f33 127.0.0.1:6382@16382 master - 0 1661353970000 3 connected 10923-16383
b8e79566afa7b55b1a451024f50c142f658ec4a2 127.0.0.1:6384@16384 slave f6b538e2df80fea1e948fda3024647bdccae3f33 0 1661353968000 3 connected
9a6b56517eceab367aebc0105238c010792aa36c 127.0.0.1:6380@16380 myself,master - 0 1661353969000 1 connected 0-5460

</code></pre></div></div>

<h2 id="附录">附录</h2>

<p>集群重启脚本，仅适用单服务器，按照以上方式配置的集群</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ports=('6380' '6381' '6382' '6383' '6384' '6385')
path=/usr/local/custom/redis/
dataDirPre=redisdata

pid=`ps -ef | grep redis-server | grep -v grep | awk '{print $2}'`
if [ -z "$pid" ];
	then
		echo "[ not find pid ]"
else
	for id in $pid
		do
			echo "kill -9 pid:" $id
			kill -9 $id
		done
	echo "开始删除数据"
	for port in ${ports[@]}
 		do
			echo $path$port
			echo $path$dataDirPre$port
			rm -rf $path$port/dump.rdb
			rm -rf $path$port/appendonly.aof
			rm -rf $path$port/nodes-*.*
			rm -rf $path$dataDirPre$port/dump.rdb
			rm -rf $path$dataDirPre$port/appendonly.aof
			rm -rf $path$dataDirPre$port/nodes-*.*
		done
	echo "开始创建集群"
	for port in ${ports[@]}
		do
			str=$str" 127.0.0.1:"$port" "
			$path"src/redis-server" $path"/"$port"/redis.conf"
		done
	$path'src/redis-cli' --cluster create $str  --cluster-replicas 1 -a redisPass		
fi
echo "----------------------日志详见/usr/local/custom/redis/logs---------------"
</code></pre></div></div>]]></content><author><name></name></author><category term="运维" /><category term="linux" /><category term="CentOS" /><category term="redis" /><category term="redis集群" /><summary type="html"><![CDATA[redis是个好东西啊，编译安装需要gcc]]></summary></entry><entry><title type="html">Linux Centos Rabbitmq安装</title><link href="http://localhost:4000/2022/08/26/Linux-CentOS-rabbitMQ%E5%AE%89%E8%A3%85.html" rel="alternate" type="text/html" title="Linux Centos Rabbitmq安装" /><published>2022-08-26T00:00:00+08:00</published><updated>2022-08-26T00:00:00+08:00</updated><id>http://localhost:4000/2022/08/26/Linux-CentOS-rabbitMQ%E5%AE%89%E8%A3%85</id><content type="html" xml:base="http://localhost:4000/2022/08/26/Linux-CentOS-rabbitMQ%E5%AE%89%E8%A3%85.html"><![CDATA[<p>文档提供RabbitMQ版本3.10.7，Erlang版本25.0.3，Linux版本CenterOS7.9</p>

<h2 id="零版本对应">零、版本对应</h2>

<p>https://www.rabbitmq.com/which-erlang.html</p>

<h2 id="一epel安装">一、EPEL安装</h2>

<p>官方文档：</p>

<p>https://docs.fedoraproject.org/en-US/epel/#_quickstart</p>

<p>yum install -y epel-release</p>

<h2 id="二erlang安装">二、Erlang安装</h2>

<p>首先安装依赖：</p>

<p>yum -y install gcc glibc-devel make ncurses-devel openssl-devel xmlto perl wget gtk2-devel binutils-devel</p>

<p>然后，区分安装方式</p>

<h3 id="1yum安装未经试验">1、yum安装（未经试验）</h3>

<p>openssl版本限定只能是1.0.1，且编译时CFLAG参数添加-fPIC</p>

<p>获取需要的版本的rpm包</p>

<p>https://www.erlang-solutions.com/downloads/</p>

<p>然后将链接用于wget</p>

<p>wget https://packages.erlang-solutions.com/erlang/rpm/centos/7/x86_64/esl-erlang_25.0.3-1~centos~7_amd64.rpm</p>

<p>此处↓可能会遇到问题①</p>

<p>rpm -Uvh esl-erlang_25.0.3-1~centos~7_amd64.rpm</p>

<p>rpm –import https://packages.erlang-solutions.com/rpm/erlang_solutions.asc</p>

<p>vi /etc/yum.repos.d/erlang_solutions.repo</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[erlang-solutions]
name=CentOS $releasever - $basearch - Erlang Solutions
baseurl=https://packages.erlang-solutions.com/rpm/centos/$releasever/$basearch
gpgcheck=1
gpgkey=https://packages.erlang-solutions.com/rpm/erlang_solutions.asc
enabled=1
</code></pre></div></div>

<p>sudo yum install erlang</p>

<h3 id="2源码编译安装">2、源码编译安装</h3>

<p>这玩意儿不好装啊，环境要求真鸡儿多</p>

<h4 id="1依赖环境安装">1.依赖环境安装</h4>

<p>依赖环境一堆，wxWidgets 到这里下载https://www.wxwidgets.org/downloads/</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum install unixODBC-devel
yum list *gtk+*
yum install mesa*
bzip2 -dkv wxWidgets-3.2.0.tar.bz2
tar -xvf wxWidgets-3.2.0.tar
cd wxWidgets-3.2.0/
./configure --with-opengl --enable-debug --enable-unicode
#这个好久。
make &amp;&amp; make install
#测试
wx-config
</code></pre></div></div>

<h4 id="2开装">2.开装</h4>

<p>git地址，那需要的版本链接</p>

<p>https://github.com/erlang/otp/releases</p>

<p>wget https://github.com/erlang/otp/releases/download/OTP-25.0.3/otp_src_25.0.3.tar.gz</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tar -zxvf otp_src_25.0.3.tar.gz
mv otp_src_25.0.3 erlang_opt
cd erlang_opt
mkdir ../erlang
./configure --prefix=/usr/local/custom/erlang
</code></pre></div></div>

<p>有这个info不管他</p>

<p>wx：Widgets was not compiled with –enable-webview or wxWebView developer package is not installed, wxWebView will NOT be available</p>

<p>直接执行</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make &amp;&amp; make install
</code></pre></div></div>

<p>vim /etc/profile</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export PATH=$PATH:/usr/local/custom/erlang/bin
</code></pre></div></div>

<p>source /etc/profile</p>

<p>erl</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Erlang/OTP 25 [erts-13.0.3] [source] [64-bit] [smp:2:2] [ds:2:2:10] [async-threads:1] [jit:ns]
Eshell V13.0.3  (abort with ^G)
halt().
#这个Erlang/OTP 25的25就是版本号
</code></pre></div></div>

<h2 id="三安装rabbitmq">三、安装RabbitMQ</h2>

<p>官网选择需要的版本</p>

<p>https://github.com/rabbitmq/rabbitmq-server/releases</p>

<p>wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.10.7/rabbitmq-server-generic-unix-3.10.7.tar.xz</p>

<p>yum install -y xz</p>

<p>xz -d rabbitmq-server-generic-unix-3.10.7.tar.xz</p>

<p>tar -xvf rabbitmq-server-generic-unix-3.10.7.tar</p>

<p>mv rabbitmq_server-3.10.7/ /usr/local/</p>

<p>mv /usr/local/rabbitmq_server-3.10.7 /usr/local/rabbitmq</p>

<p>echo ‘export PATH=$PATH:/usr/local/rabbitmq/sbin’ » /etc/profile</p>

<p>source /etc/profile</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#启动
rabbitmq-server -detached
#停止
rabbitmqctl stop
#状态
rabbitmqctl status
#开启web插件
rabbitmq-plugins enable rabbitmq_management
</code></pre></div></div>

<p>开启端口15672</p>

<p>登录默认账号：guest/ guest</p>

<p>注意，安全起见rabbitmq3.3.0之后，默认情况下rabbitmq的guest/guest账户将不能实现远程登录，只能在本地登录。</p>

<p>解决方案：创建远程登陆账户</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#查看用户列表
rabbitmqctl list_users
#新增账户
rabbitmqctl add_user 用户名 密码
#设置角色
#用户角色可以分为超级管理员administrator、监控者monitoring、策略制定者policymaker、普通管理者management等
rabbitmqctl set_user_tags 用户名 administrator
#赋予权限
rabbitmqctl set_permissions -p / 用户名 "." "." ".*"
#忘记密码更新密码
rabbitmqctl  change_password  用户名 新密码
</code></pre></div></div>

<h2 id="附录">附录</h2>

<h3 id="附带学习简单队列git项目">附带学习简单队列git项目</h3>

<p>https://download.csdn.net/download/zpcandzhj/10585077</p>

<h3 id="可能遇到的问题">可能遇到的问题</h3>

<p>①yum安装报了这个</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>错误：依赖检测失败：
        libcrypto.so.10()(64bit) 被 esl-erlang-25.0.3-1.x86_64 需要
        libcrypto.so.10(OPENSSL_1.0.1_EC)(64bit) 被 esl-erlang-25.0.3-1.x86_64 需要
        libcrypto.so.10(OPENSSL_1.0.2)(64bit) 被 esl-erlang-25.0.3-1.x86_64 需要
        libcrypto.so.10(libcrypto.so.10)(64bit) 被 esl-erlang-25.0.3-1.x86_64 需要
        libodbc.so.2()(64bit) 被 esl-erlang-25.0.3-1.x86_64 需要
</code></pre></div></div>

<p>解决：</p>

<p>wget http://www.openssl.org/source/openssl-1.0.1f.tar.gz</p>

<p>tar zxvf openssl-1.0.1f.tar.gz</p>

<p>cd openssl-1.0.1f</p>

<p>./config –prefix=/opt/ssl （下载目录）</p>

<p>vim Makefile</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#CFLAG参数列表里加上-fPIC
CC= gcc  
CFLAG= -fPIC -DOP........
</code></pre></div></div>

<p>make &amp;&amp; make install</p>

<p>此时可能报错</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POD document had syntax errors at /usr/bin/pod2man line 69.
make: *** [Makefile:641：install_docs] 错误 255
</code></pre></div></div>

<p>找到pod2man对应行数直接注释</p>

<p>然后指定ssl路径编译安装</p>

<p>./configure –with-ssl=/opt/ssl/ –prefix=/opt/erlang</p>

<p>make &amp;&amp; make install</p>]]></content><author><name></name></author><category term="运维" /><category term="linux" /><category term="CentOS" /><category term="rebbitMQ" /><summary type="html"><![CDATA[文档提供RabbitMQ版本3.10.7，Erlang版本25.0.3，Linux版本CenterOS7.9]]></summary></entry><entry><title type="html">Linux Centos Maven安装</title><link href="http://localhost:4000/2022/08/24/Linux-CentOS-maven%E5%AE%89%E8%A3%85.html" rel="alternate" type="text/html" title="Linux Centos Maven安装" /><published>2022-08-24T00:00:00+08:00</published><updated>2022-08-24T00:00:00+08:00</updated><id>http://localhost:4000/2022/08/24/Linux-CentOS-maven%E5%AE%89%E8%A3%85</id><content type="html" xml:base="http://localhost:4000/2022/08/24/Linux-CentOS-maven%E5%AE%89%E8%A3%85.html"><![CDATA[<p>maven版本查看https://dlcdn.apache.org/maven/maven-3/</p>

<p>安装maven，就四步</p>

<h2 id="1下载">1、下载</h2>

<p>wget https://dlcdn.apache.org/maven/maven-3/3.8.6/binaries/apache-maven-3.8.6-bin.tar.gz</p>

<h2 id="2解压">2、解压</h2>

<p>tar -zxvf apache-maven-3.8.6-bin.tar.gz</p>

<h2 id="3改名">3、改名</h2>

<p>mv apache-maven-3.8.6 maven</p>

<h2 id="4添加环境变量">4、添加环境变量</h2>

<p>放在末尾</p>

<p>vim /etc/profile</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export MAVEN_HOME=/usr/local/maven/
export PATH=${PATH}:${MAVEN_HOME}/bin
</code></pre></div></div>]]></content><author><name></name></author><category term="运维" /><category term="linux" /><category term="CentOS" /><category term="maven" /><summary type="html"><![CDATA[maven版本查看https://dlcdn.apache.org/maven/maven-3/]]></summary></entry><entry><title type="html">Linux Centos Nginx安装</title><link href="http://localhost:4000/2022/08/24/Linux-CentOS-nginx%E5%AE%89%E8%A3%85.html" rel="alternate" type="text/html" title="Linux Centos Nginx安装" /><published>2022-08-24T00:00:00+08:00</published><updated>2022-08-24T00:00:00+08:00</updated><id>http://localhost:4000/2022/08/24/Linux-CentOS-nginx%E5%AE%89%E8%A3%85</id><content type="html" xml:base="http://localhost:4000/2022/08/24/Linux-CentOS-nginx%E5%AE%89%E8%A3%85.html"><![CDATA[<p>官网挑选版本下载</p>

<p>http://nginx.org/en/download.html</p>

<h2 id="一安装依赖">一、安装依赖</h2>

<p>yum -y install gcc pcre-devel zlib-devel openssl openssl-devel</p>

<h2 id="二下载">二、下载</h2>

<p>wget http://nginx.org/download/nginx-1.22.0.tar.gz</p>

<h2 id="三解压">三、解压</h2>

<p>tar -zxvf nginx-1.22.0.tar.gz</p>

<h2 id="四编译安装">四、编译安装</h2>

<p>mv nginx-1.22.0 nginx</p>

<p>cd nginx</p>

<p>./configure</p>

<p>make &amp; make install</p>

<h2 id="五启动">五、启动</h2>

<p>cd /usr/local/nginx/sbin</p>

<p>./nginx</p>

<h2 id="附常用命令">附：常用命令</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#用某个路径下的配置启动
nginx -c /usr/local/nginx/conf/nginx.conf 
#快速关闭
nginx -s stop
#安全关闭
nginx -s quit
#重载配置
nginx -s reload
#重新打开一个日志文件
nginx -s reopen
#验证配置是否正确，后接路径，不接代表默认配置
nginx -t /home/test/conf/nginx.conf
</code></pre></div></div>]]></content><author><name></name></author><category term="运维" /><category term="linux" /><category term="CentOS" /><category term="nginx" /><summary type="html"><![CDATA[官网挑选版本下载]]></summary></entry><entry><title type="html">Linux Centos Nacos安装</title><link href="http://localhost:4000/2022/08/24/Linux-CentOS-nacos%E5%AE%89%E8%A3%85.html" rel="alternate" type="text/html" title="Linux Centos Nacos安装" /><published>2022-08-24T00:00:00+08:00</published><updated>2022-08-24T00:00:00+08:00</updated><id>http://localhost:4000/2022/08/24/Linux-CentOS-nacos%E5%AE%89%E8%A3%85</id><content type="html" xml:base="http://localhost:4000/2022/08/24/Linux-CentOS-nacos%E5%AE%89%E8%A3%85.html"><![CDATA[<p>nacos注册中心，需要安装maven作为前置</p>

<p>nacos查看版本</p>

<p>https://github.com/alibaba/nacos/releases</p>

<h2 id="一下载">一、下载</h2>

<p>wget https://github.com/alibaba/nacos/releases/download/1.4.3/nacos-server-1.4.3.tar.gz</p>

<h2 id="二解压">二、解压</h2>

<p>tar -zxvf nacos-server-1.4.3.tar.gz</p>

<h2 id="三数据源配置">三、数据源配置</h2>

<p>vim nacos/conf/application.properties</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#几个重要配置
#数据库连接类型
spring.datasource.platform=mysql
#数据库链接数量
db.num=1
#数据库连接路径
db.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC
#数据库账号
db.user.0=root
#数据库密码
db.password.0=password
#是否开启用户认证，开启后，项目启动连接nacos时，需要配置连接账号密码（nacos登录账号密码）
nacos.core.auth.enabled=true
</code></pre></div></div>

<h3 id="四nacos启动">四、nacos启动</h3>

<p>sh nacos/bin/startup.sh -m standalone</p>

<p>查看启动状态</p>

<p>tail -100f nacos/logs/start.out</p>]]></content><author><name></name></author><category term="运维" /><category term="linux" /><category term="CentOS" /><category term="nacos" /><summary type="html"><![CDATA[nacos注册中心，需要安装maven作为前置]]></summary></entry><entry><title type="html">Linux Centos Mysql安装</title><link href="http://localhost:4000/2022/08/24/Linux-CentOS-mysql%E5%AE%89%E8%A3%85.html" rel="alternate" type="text/html" title="Linux Centos Mysql安装" /><published>2022-08-24T00:00:00+08:00</published><updated>2022-08-24T00:00:00+08:00</updated><id>http://localhost:4000/2022/08/24/Linux-CentOS-mysql%E5%AE%89%E8%A3%85</id><content type="html" xml:base="http://localhost:4000/2022/08/24/Linux-CentOS-mysql%E5%AE%89%E8%A3%85.html"><![CDATA[<p>mysql数据库安装操作</p>

<h2 id="一清理数据">一、清理数据</h2>

<h3 id="1首先检查是否安装过mysql">1、首先检查是否安装过mysql</h3>

<table>
  <tbody>
    <tr>
      <td>rpm -qa</td>
      <td>grep mysql</td>
    </tr>
  </tbody>
</table>

<p>若有则清理干净再安装</p>

<p>whereis mysql</p>

<p>找到文件夹目录，再把它删除。</p>

<p>rpm -e –nodeps mysql-xxxx</p>

<h3 id="2检查你系统是否自带mariadb输入如下检查">2、检查你系统是否自带mariadb，输入如下检查。</h3>

<table>
  <tbody>
    <tr>
      <td>rpm -qa</td>
      <td>grep mariadb</td>
    </tr>
  </tbody>
</table>

<p>如果有则需要把它卸载掉，因为会和Mysql引起冲突，输入如下卸载掉。</p>

<p>rpm -e –nodeps mariadb-libs</p>

<h2 id="二下载地址或者使用本地安装包">二、下载地址或者使用本地安装包</h2>

<p>安装目录选择在/usr/local</p>

<p>cd /usr/local</p>

<h3 id="1下载">1、下载</h3>

<p>wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.39-linux-glibc2.12-x86_64.tar.gz</p>

<h3 id="2解压">2、解压</h3>

<p>tar -xzvf mysql-5.7.39-linux-glibc2.12-x86_64.tar.gz</p>

<h3 id="3修改文件目录">3、修改文件目录</h3>

<p>mv mysql-5.7.39-linux-glibc2.12-x86_64 mysql</p>

<h3 id="4更改mysql目录下所有的目录及文件夹所属组合用户">4、更改mysql目录下所有的目录及文件夹所属组合用户</h3>

<p>groupadd mysql</p>

<p>useradd -r -g mysql mysql</p>

<p>chown -R mysql:mysql mysql/</p>

<p>chmod -R 777 mysql/</p>

<h3 id="5编辑配置文件">5、编辑配置文件</h3>

<p>vi /usr/local/mysql/my.cnf</p>

<p>修改配置文件为如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[client]
#password=88888888
socket=/usr/local/mysql/mysql.sock

[mysql]
socket=/usr/local/mysql/mysql.sock
# 设置mysql客户端默认字符集
default-character-set=utf8

[mysqld]
pid-file=/usr/local/mysql/mysql.pid
log-error = /usr/local/mysql/log/mysql-error.log
#设置3306端口
port = 3306
# 设置mysql的安装目录
basedir=/usr/local/mysql
# 设置mysql数据库的数据的存放目录
datadir=/usr/local/mysql/data
#sock
socket=/usr/local/mysql/mysql.sock
# 允许最大连接数
max_connections=200
# 服务端使用的字符集默认为8比特编码的latin1字符集
character-set-server=utf8mb4
# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
#允许时间类型的数据为零(去掉NO_ZERO_IN_DATE,NO_ZERO_DATE)
sql_mode=ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
#ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
lower_case_table_names=1
</code></pre></div></div>

<h3 id="6编译安装">6、编译安装</h3>

<p>创建data文件夹</p>

<p>mkdir /usr/local/mysql/data</p>

<p>执行安装，账号默认root<strong>（需要注意最后行显示的是root的密码）</strong></p>

<p>/usr/local/mysql/bin/mysqld –initialize –user=mysql –datadir=/usr/local/mysql/data –basedir=/usr/local/mysql</p>

<p>添加文件夹</p>

<p>mkdir /usr/local/mysql/log</p>

<p>touch /usr/local/mysql/log/mysql-error.log</p>

<p>chmod -R 777 /usr/local/mysql/log</p>

<h3 id="7服务及mysql命令软链接">7、服务及mysql命令软链接</h3>

<p>ln -s /usr/local/mysql/bin/mysql /usr/bin</p>

<p>ln -s /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql</p>

<h3 id="8启动服务并登入更改root密码">8、启动服务并登入更改root密码</h3>

<p>service mysql start</p>

<p>ln -s /usr/local/mysql/mysql.sock /tmp/mysql.sock</p>

<p>mysql -u root -p <strong>刚刚编译生成的默认密码</strong></p>

<p>set password for root@localhost = password(‘<strong>新密码</strong>’);</p>

<p>flush privileges;</p>

<h3 id="9设置远程登入">9、设置远程登入：</h3>

<p>use mysql;</p>

<p>update user set host=’%’ where host=’localhost’;</p>

<p>flush privileges;</p>

<h2 id="三主从互备">三、主从互备</h2>

<h3 id="1修改配置文件">1、修改配置文件</h3>

<p>主库配置文件</p>

<p>vim /etc/my.cnf</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[mysqld]
server_id=1
log-bin=mysql-bin
log-bin-index=master-bin.index
relay-log=relay-log
relay-log-index=relay-log.index
</code></pre></div></div>

<p>从库配置文件</p>

<p>vim /etc/my.cnf</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[mysqld]
server_id=2
log-bin=mysql-bin
log-bin-index=master-bin.index
relay-log=relay-log
relay-log-index=relay-log.index
</code></pre></div></div>

<p>上面修改配置文件需重启服务</p>

<p>service mysql restart</p>

<h3 id="2登录主库设置授权从库">2、登录主库设置授权从库</h3>

<p>[root@servername fold]# mysql -u root -p</p>

<p>Enter password:（<strong>密码输入不可见</strong>）</p>

<p>mysql&gt; grant replication slave on <em>.</em> to ‘root’@’<strong>从库的ip地址</strong>’ identified by ‘<strong>从库主库连接密码</strong>’;</p>

<p>mysql&gt;flush privileges;</p>

<p>查看master的状态</p>

<p>mysql&gt;show master status;</p>

<p><img src="C:\Users\19604\AppData\Roaming\Typora\typora-user-images\image-20220824221121472.png" alt="image-20220824221121472" /></p>

<p>主库进行锁表</p>

<p>mysql&gt;flush tables with read lock;</p>

<h3 id="3从库配置操作">3、从库配置操作</h3>

<p>[root@servername fold]# mysql -u root -p</p>

<p>Enter password:（<strong>密码输入不可见</strong>）</p>

<p>mysql&gt; change master to master_host=’<strong>主库ip地址</strong>‘,master_user=’root’, master_password=’<strong>从库主库连接密码</strong>‘,master_log_file=’<strong>主库File</strong>‘,master_log_pos=（<strong>主库position</strong>）;</p>

<p>mysql&gt;start slave;</p>

<p>查看连接状态</p>

<p>mysql&gt;show slave status\G;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                Slave_IO_State: Waiting for master to send event
                   Master_Host: 119.3.131.252
                   Master_User: root
                   Master_Port: 3306
                 Connect_Retry: 60
               Master_Log_File: mysql-bin.000007
           Read_Master_Log_Pos: 154
                Relay_Log_File: relay-log.000002
                 Relay_Log_Pos: 320
         Relay_Master_Log_File: mysql-bin.000007
              Slave_IO_Running: Yes				#此处两个地方
             Slave_SQL_Running: Yes				#全部为Yes即成功
               Replicate_Do_DB: 
           Replicate_Ignore_DB: 
            Replicate_Do_Table: 
        Replicate_Ignore_Table: 
       Replicate_Wild_Do_Table: 
   Replicate_Wild_Ignore_Table: 
          			Last_Errno: 0
          			Last_Error: 
         		  Skip_Counter: 0
     	   Exec_Master_Log_Pos: 154
      		   Relay_Log_Space: 521
       		   Until_Condition: None
        		Until_Log_File: 
        		 Until_Log_Pos: 0
            Master_SSL_Allowed: No
            Master_SSL_CA_File: 
            Master_SSL_CA_Path: 
    	  	   Master_SSL_Cert: 
     		 Master_SSL_Cipher: 
        		Master_SSL_Key: 
    	 Seconds_Behind_Master: 0
 Master_SSL_Verify_Server_Cert: No
                 Last_IO_Errno: 0
                 Last_IO_Error: 
                Last_SQL_Errno: 0
                Last_SQL_Error: 
   Replicate_Ignore_Server_Ids: 
       		  Master_Server_Id: 2
         		   Master_UUID: 8823ac3e-0983-11ed-97a9-fa163e59f44f
       		  Master_Info_File: /usr/local/mysql/data/master.info
              		 SQL_Delay: 0
           SQL_Remaining_Delay: NULL
       Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates
          	Master_Retry_Count: 86400
        		   Master_Bind: 
       Last_IO_Error_Timestamp: 
      Last_SQL_Error_Timestamp: 
                Master_SSL_Crl: 
            Master_SSL_Crlpath: 
            Retrieved_Gtid_Set: 
             Executed_Gtid_Set: 
                 Auto_Position: 0
          Replicate_Rewrite_DB: 
                  Channel_Name: 
            Master_TLS_Version: 
1 row in set (0.00 sec)

ERROR: 
No query specified
</code></pre></div></div>

<h3 id="4解锁主库别漏了">4、解锁主库（别漏了）</h3>

<p>mysql&gt; unlock tables;</p>

<h2 id="四主主互备">四、主主互备</h2>

<p>主主互备、即将主从互备反过来，重新执行一遍流程即可</p>]]></content><author><name></name></author><category term="运维" /><category term="linux" /><category term="CentOS" /><category term="mysql" /><category term="mysql5.7" /><category term="主主互备" /><category term="主从备份" /><summary type="html"><![CDATA[mysql数据库安装操作]]></summary></entry></feed>